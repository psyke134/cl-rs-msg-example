pub use crate::clBindings::clArchHeaders::*;
/* automatically generated by rust-bindgen 0.66.1 */

pub const CL_TRUE: u32 = 1;
pub const CL_FALSE: u32 = 0;
pub const CL_YES: u32 = 1;
pub const CL_NO: u32 = 0;
pub const CL_ENABLE: u32 = 1;
pub const CL_DISABLE: u32 = 0;
pub const CL_MICRO_TO_NANO: u32 = 1000;
pub const CL_MILLI_TO_MICRO: u32 = 1000;
pub const CL_SEC_TO_MILLI: u32 = 1000;
pub const CL_MILLI_TO_NANO: u32 = 1000000;
pub const CL_SEC_TO_NANO: u32 = 1000000000;
pub const CL_TIME_END: u64 = 9223372036854775807;
pub const CL_TIME_FOREVER: u64 = 9223372036854775807;
pub const CL_MAX_NAME_LENGTH: u32 = 256;
pub const CL_FORCED_TO_8BITS: u32 = 255;
pub const CL_FORCED_TO_16BITS: u32 = 65535;
pub const CL_FORCED_TO_32BITS: u32 = 4294967295;
pub const CL_BITS_PER_BYTE: u32 = 8;
pub const CL_EO_ACTION_CUSTOM: u32 = 1;
pub const CL_EO_ACTION_EVENT: u32 = 2;
pub const CL_EO_ACTION_LOG: u32 = 4;
pub const CL_EO_ACTION_NOT: u32 = 8;
pub const CL_EO_ACTION_MAX: u32 = 2147483648;
#[doc = " This determines that the node/component is down."]
pub const ClStatusT_CL_STATUS_DOWN: ClStatusT = 0;
#[doc = " This determines that the node/component is up."]
pub const ClStatusT_CL_STATUS_UP: ClStatusT = 1;
#[doc = " These define all the possible states that a component/node can be in."]
pub type ClStatusT = ::std::os::raw::c_uint;
pub type ClUint64T = ::std::os::raw::c_ulonglong;
pub type ClInt64T = ::std::os::raw::c_longlong;
pub type ClUint32T = ::std::os::raw::c_uint;
pub type ClInt32T = ::std::os::raw::c_int;
pub type ClUint16T = ::std::os::raw::c_ushort;
pub type ClInt16T = ::std::os::raw::c_short;
pub type ClUint8T = ::std::os::raw::c_uchar;
pub type ClInt8T = ::std::os::raw::c_schar;
pub type ClCharT = ::std::os::raw::c_char;
pub type ClFdT = ::std::os::raw::c_int;
pub type ClWordT = ::std::os::raw::c_ulong;
pub type ClBoolT = ClUint16T;
pub type ClPidT = ClWordT;
#[doc = " Time duration specified in nanoseconds"]
pub type ClTimeT = ClInt64T;
pub type ClHandleT = ClUint64T;
#[doc = " # of bytes in a buffer or object"]
pub type ClSizeT = ClUint64T;
#[doc = " Offset of a buffer or object within another"]
pub type ClOffsetT = ClInt64T;
pub type ClInvocationT = ClUint64T;
pub type ClSelectionObjectT = ClUint64T;
pub type ClNtfIdentifierT = ClUint64T;
pub type ClAddrT = *mut ClInt8T;
pub type ClPtrT = *mut ::std::os::raw::c_void;
#[doc = " Clovis return code type.\n\\sa clCommonErrors.h"]
pub type ClRcT = ClUint32T;
#[doc = " \\brief Definition of a generic single argument callback function.\n\n \\param invocation A \"cookie\". The caller can pass a piece of arbitrary data\n along with the function pointer in all calls that take a callback.  This data\n passed as the \"invocation\" parameter to the callback.\n"]
pub type ClCallbackT = ::std::option::Option<unsafe extern "C" fn(invocation: ClPtrT) -> ClRcT>;
#[repr(C)]
#[derive(Copy, Clone)]
pub union cl_u64_u {
    pub DWord: cl_u64_u__bindgen_ty_1,
    pub dWords: [ClUint32T; 2usize],
    pub words: [ClUint16T; 4usize],
    pub bytes: [ClInt8T; 8usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cl_u64_u__bindgen_ty_1 {
    pub high: ClUint32T,
    pub low: ClUint32T,
}
#[test]
fn bindgen_test_layout_cl_u64_u__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<cl_u64_u__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cl_u64_u__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(cl_u64_u__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<cl_u64_u__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(cl_u64_u__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).high) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_u64_u__bindgen_ty_1),
            "::",
            stringify!(high)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).low) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_u64_u__bindgen_ty_1),
            "::",
            stringify!(low)
        )
    );
}
#[test]
fn bindgen_test_layout_cl_u64_u() {
    const UNINIT: ::std::mem::MaybeUninit<cl_u64_u> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cl_u64_u>(),
        8usize,
        concat!("Size of: ", stringify!(cl_u64_u))
    );
    assert_eq!(
        ::std::mem::align_of::<cl_u64_u>(),
        4usize,
        concat!("Alignment of ", stringify!(cl_u64_u))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DWord) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_u64_u),
            "::",
            stringify!(DWord)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dWords) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_u64_u),
            "::",
            stringify!(dWords)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).words) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_u64_u),
            "::",
            stringify!(words)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bytes) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cl_u64_u),
            "::",
            stringify!(bytes)
        )
    );
}
pub type ClUnion64T = cl_u64_u;
#[doc = " A name"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ClNameT {
    #[doc = " Length of the name in bytes excluding '\\0'"]
    pub length: ClUint16T,
    #[doc = " Actual name represented as a null terminated ASCII string"]
    pub value: [ClCharT; 256usize],
}
#[test]
fn bindgen_test_layout_ClNameT() {
    const UNINIT: ::std::mem::MaybeUninit<ClNameT> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ClNameT>(),
        258usize,
        concat!("Size of: ", stringify!(ClNameT))
    );
    assert_eq!(
        ::std::mem::align_of::<ClNameT>(),
        2usize,
        concat!("Alignment of ", stringify!(ClNameT))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ClNameT),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(ClNameT),
            "::",
            stringify!(value)
        )
    );
}
extern "C" {
    #[doc = " \\brief  Load the ClNameT structure.\n\\param  name The structure you want to load\n\\param  str  The value to be put into the ClNameT structure\n\nIf str is too long, then this function will ASSERT in debug mode, and crop in production mode"]
    pub fn clNameSet(name: *mut ClNameT, str_: *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " \\brief  Load the ClNameT structure.\n\\param  name The structure you want to load\n\\param  name The structure to be put into the ClNameT structure\n\nIf length is too long, then this function will ASSERT in debug mode, and crop in production mode"]
    pub fn clNameCopy(nameOut: *mut ClNameT, nameIn: *const ClNameT);
}
extern "C" {
    #[doc = " \\brief  Join ClNameT structures\n\\param  nameOut The result\n\\param  prefix The beginning string.  Pass NULL if there is no beginning\n\\param  separator The middle string. Pass NULL for no separator\n\\param  suffix The ending string. Pass NULL for no ending\n\nIf the sum of the lengths of the prefix, separator, and suffix is too long, the function will crop."]
    pub fn clNameConcat(
        nameOut: *mut ClNameT,
        prefix: *const ClNameT,
        separator: *const ::std::os::raw::c_char,
        suffix: *const ClNameT,
    );
}
extern "C" {
    #[doc = " \\brief  Duplicate a string\n\\param  str The string to be duplicated\n\\retval Storage pointed to a duplicated string or NULL\n\n\\par Description:\nThis API is used to duplicate a string. The storage pointed by the returned string\nshould be freed using ASP heap API: clHeapFree."]
    pub fn clStrdup(str_: *const ClCharT) -> *mut ClCharT;
}
extern "C" {
    pub fn clParseEnvBoolean(envvar: *mut ClCharT) -> ClBoolT;
}
extern "C" {
    pub fn clParseEnvStr(envvar: *const ClCharT) -> *mut ClCharT;
}
extern "C" {
    pub fn clCreatePipe(fds: *mut ClInt32T, numMsgs: ClUint32T, msgSize: ClUint32T) -> ClInt32T;
}
extern "C" {
    pub fn clBinaryPower(size: ClUint32T) -> ClUint32T;
}
#[doc = " Version Information for various services"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ClVersionT {
    #[doc = " single ASCII capitol letter \"A-Z\""]
    pub releaseCode: ClUint8T,
    #[doc = " Major Number in range of [01-255]"]
    pub majorVersion: ClUint8T,
    #[doc = " Minor Number in range of [01-255]"]
    pub minorVersion: ClUint8T,
}
#[test]
fn bindgen_test_layout_ClVersionT() {
    const UNINIT: ::std::mem::MaybeUninit<ClVersionT> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ClVersionT>(),
        3usize,
        concat!("Size of: ", stringify!(ClVersionT))
    );
    assert_eq!(
        ::std::mem::align_of::<ClVersionT>(),
        1usize,
        concat!("Alignment of ", stringify!(ClVersionT))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).releaseCode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ClVersionT),
            "::",
            stringify!(releaseCode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).majorVersion) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(ClVersionT),
            "::",
            stringify!(majorVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).minorVersion) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(ClVersionT),
            "::",
            stringify!(minorVersion)
        )
    );
}
pub const ClDispatchFlagsT_CL_DISPATCH_ONE: ClDispatchFlagsT = 1;
pub const ClDispatchFlagsT_CL_DISPATCH_ALL: ClDispatchFlagsT = 2;
pub const ClDispatchFlagsT_CL_DISPATCH_BLOCKING: ClDispatchFlagsT = 3;
#[doc = " Dispatch flags"]
pub type ClDispatchFlagsT = ::std::os::raw::c_uint;
#[doc = " Unspecified"]
pub const ClCompIdT_CL_CID_UNSPECIFIED: ClCompIdT = 0;
#[doc = " OS Abstraction Layer"]
pub const ClCompIdT_CL_CID_OSAL: ClCompIdT = 1;
#[doc = " Hardware Abstraction Layer"]
pub const ClCompIdT_CL_CID_HAL: ClCompIdT = 2;
#[doc = " Database Abstraction Layer"]
pub const ClCompIdT_CL_CID_DBAL: ClCompIdT = 3;
#[doc = " Execution Object"]
pub const ClCompIdT_CL_CID_EO: ClCompIdT = 4;
#[doc = " Intelligent Object Communication"]
pub const ClCompIdT_CL_CID_IOC: ClCompIdT = 5;
#[doc = " Remote Method Dispatch"]
pub const ClCompIdT_CL_CID_RMD: ClCompIdT = 6;
#[doc = " Name Service"]
pub const ClCompIdT_CL_CID_NAMES: ClCompIdT = 7;
#[doc = " Timer"]
pub const ClCompIdT_CL_CID_TIMER: ClCompIdT = 8;
#[doc = " Shared Memory Support"]
pub const ClCompIdT_CL_CID_SHM: ClCompIdT = 9;
#[doc = " Distributed Shared Memory"]
pub const ClCompIdT_CL_CID_DSHM: ClCompIdT = 10;
#[doc = " Logging"]
pub const ClCompIdT_CL_CID_LOG: ClCompIdT = 11;
#[doc = " Message Service"]
pub const ClCompIdT_CL_CID_MSG: ClCompIdT = 12;
#[doc = " Diagnostics"]
pub const ClCompIdT_CL_CID_DIAG: ClCompIdT = 13;
#[doc = " Debug"]
pub const ClCompIdT_CL_CID_DEBUG: ClCompIdT = 14;
#[doc = " Component Management"]
pub const ClCompIdT_CL_CID_CPM: ClCompIdT = 15;
#[doc = " Capability Management (for future use)"]
pub const ClCompIdT_CL_CID_CAP: ClCompIdT = 16;
#[doc = " Resource Management (for future use)"]
pub const ClCompIdT_CL_CID_RES: ClCompIdT = 17;
#[doc = " Group Membership Service"]
pub const ClCompIdT_CL_CID_GMS: ClCompIdT = 18;
#[doc = " Event Service"]
pub const ClCompIdT_CL_CID_EVENTS: ClCompIdT = 19;
#[doc = " Distributed Locking (for future use)"]
pub const ClCompIdT_CL_CID_DLOCK: ClCompIdT = 20;
#[doc = " Transactions"]
pub const ClCompIdT_CL_CID_TXN: ClCompIdT = 21;
#[doc = " Checkpointing Service"]
pub const ClCompIdT_CL_CID_CKPT: ClCompIdT = 22;
#[doc = " Clovis Object Registry"]
pub const ClCompIdT_CL_CID_COR: ClCompIdT = 23;
#[doc = " Containers"]
pub const ClCompIdT_CL_CID_CNT: ClCompIdT = 24;
#[doc = " Distributed Containers (for future use)"]
pub const ClCompIdT_CL_CID_DCNT: ClCompIdT = 25;
#[doc = " Resilient Containers (for future use)"]
pub const ClCompIdT_CL_CID_RCNT: ClCompIdT = 26;
#[doc = " Alarm Manager"]
pub const ClCompIdT_CL_CID_ALARMS: ClCompIdT = 27;
#[doc = " Policy Engine"]
pub const ClCompIdT_CL_CID_POLICY: ClCompIdT = 28;
#[doc = " Rule Base Engine"]
pub const ClCompIdT_CL_CID_RULE: ClCompIdT = 29;
#[doc = " Scripting Engine (for future use)"]
pub const ClCompIdT_CL_CID_SCRIPTING: ClCompIdT = 30;
#[doc = " Chassis Manager"]
pub const ClCompIdT_CL_CID_CM: ClCompIdT = 31;
#[doc = " Hardware Platform Interface"]
pub const ClCompIdT_CL_CID_HPI: ClCompIdT = 32;
#[doc = " Fault Management"]
pub const ClCompIdT_CL_CID_FAULTS: ClCompIdT = 33;
#[doc = " Availability Management Service"]
pub const ClCompIdT_CL_CID_AMS: ClCompIdT = 34;
#[doc = " Mediation Library"]
pub const ClCompIdT_CL_CID_MED: ClCompIdT = 35;
#[doc = " Buffer Management"]
pub const ClCompIdT_CL_CID_BUFFER: ClCompIdT = 36;
#[doc = " Queue Management"]
pub const ClCompIdT_CL_CID_QUEUE: ClCompIdT = 37;
#[doc = " Circular List Management"]
pub const ClCompIdT_CL_CID_CLIST: ClCompIdT = 38;
#[doc = " SNMP Agent"]
pub const ClCompIdT_CL_CID_SNMP: ClCompIdT = 39;
#[doc = " Name Service"]
pub const ClCompIdT_CL_CID_NS: ClCompIdT = 40;
#[doc = " Object Manager"]
pub const ClCompIdT_CL_CID_OM: ClCompIdT = 41;
#[doc = " Pool Management"]
pub const ClCompIdT_CL_CID_POOL: ClCompIdT = 42;
#[doc = " Common Diagnostics (for future use)"]
pub const ClCompIdT_CL_CID_CD: ClCompIdT = 43;
#[doc = " Diagnostics Manager (for future use)"]
pub const ClCompIdT_CL_CID_DM: ClCompIdT = 44;
#[doc = " OAMP RT parser"]
pub const ClCompIdT_CL_CID_OAMP_RT: ClCompIdT = 45;
#[doc = " Provisioning Manager"]
pub const ClCompIdT_CL_CID_PROV: ClCompIdT = 46;
#[doc = " Upgrade Manager (for future use)"]
pub const ClCompIdT_CL_CID_UM: ClCompIdT = 47;
#[doc = " Handle Database"]
pub const ClCompIdT_CL_CID_HANDLE: ClCompIdT = 48;
#[doc = " Version Checker Library"]
pub const ClCompIdT_CL_CID_VERSION: ClCompIdT = 49;
#[doc = " XDR Library"]
pub const ClCompIdT_CL_CID_XDR: ClCompIdT = 50;
#[doc = " IDL"]
pub const ClCompIdT_CL_CID_IDL: ClCompIdT = 51;
#[doc = " Heap Management"]
pub const ClCompIdT_CL_CID_HEAP: ClCompIdT = 52;
#[doc = " Memory Management"]
pub const ClCompIdT_CL_CID_MEM: ClCompIdT = 53;
#[doc = " Parser"]
pub const ClCompIdT_CL_CID_PARSER: ClCompIdT = 54;
#[doc = " Parser"]
pub const ClCompIdT_CL_CID_BACKING_STORAGE: ClCompIdT = 55;
#[doc = " Parser"]
pub const ClCompIdT_CL_CID_JOB: ClCompIdT = 56;
#[doc = " Parser"]
pub const ClCompIdT_CL_CID_JOBQUEUE: ClCompIdT = 56;
#[doc = " Parser"]
pub const ClCompIdT_CL_CID_THREADPOOL: ClCompIdT = 57;
#[doc = " Parser"]
pub const ClCompIdT_CL_CID_TASKPOOL: ClCompIdT = 57;
#[doc = " Bitmap Management"]
pub const ClCompIdT_CL_CID_BITMAP: ClCompIdT = 58;
#[doc = " Bitmap Management"]
pub const ClCompIdT_CL_CID_LEAKY_BUCKET: ClCompIdT = 59;
#[doc = " Mso Services Management"]
pub const ClCompIdT_CL_CID_MSO: ClCompIdT = 60;
#[doc = " Performance Management"]
pub const ClCompIdT_CL_CID_PM: ClCompIdT = 61;
#[doc = " SAF Notification service"]
pub const ClCompIdT_CL_CID_NF: ClCompIdT = 62;
#[doc = " This will help validate if needs to be"]
pub const ClCompIdT_CL_CID_MAX: ClCompIdT = 63;
#[doc = "  Clovis Component Ids"]
pub type ClCompIdT = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ClWaterMark {
    pub lowLimit: ClUint64T,
    pub highLimit: ClUint64T,
}
#[test]
fn bindgen_test_layout_ClWaterMark() {
    const UNINIT: ::std::mem::MaybeUninit<ClWaterMark> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ClWaterMark>(),
        16usize,
        concat!("Size of: ", stringify!(ClWaterMark))
    );
    assert_eq!(
        ::std::mem::align_of::<ClWaterMark>(),
        8usize,
        concat!("Alignment of ", stringify!(ClWaterMark))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lowLimit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ClWaterMark),
            "::",
            stringify!(lowLimit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).highLimit) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ClWaterMark),
            "::",
            stringify!(highLimit)
        )
    );
}
pub type ClWaterMarkT = ClWaterMark;
pub const ClEoWaterMarkFlagT_CL_WM_LOW_LIMIT: ClEoWaterMarkFlagT = 0;
pub const ClEoWaterMarkFlagT_CL_WM_HIGH_LIMIT: ClEoWaterMarkFlagT = 1;
pub type ClEoWaterMarkFlagT = ::std::os::raw::c_uint;
pub const ClWaterMarkIdT_CL_WM_LOW: ClWaterMarkIdT = 0;
pub const ClWaterMarkIdT_CL_WM_HIGH: ClWaterMarkIdT = 1;
pub const ClWaterMarkIdT_CL_WM_MED: ClWaterMarkIdT = 2;
pub const ClWaterMarkIdT_CL_WM_SENDQ: ClWaterMarkIdT = 3;
pub const ClWaterMarkIdT_CL_WM_RECVQ: ClWaterMarkIdT = 4;
pub const ClWaterMarkIdT_CL_WM_MAX: ClWaterMarkIdT = 5;
pub type ClWaterMarkIdT = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ClEoActionInfo {
    #[doc = "<The bitmap of functions that are enabled."]
    pub bitMap: ClUint32T,
}
#[test]
fn bindgen_test_layout_ClEoActionInfo() {
    const UNINIT: ::std::mem::MaybeUninit<ClEoActionInfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ClEoActionInfo>(),
        4usize,
        concat!("Size of: ", stringify!(ClEoActionInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<ClEoActionInfo>(),
        4usize,
        concat!("Alignment of ", stringify!(ClEoActionInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bitMap) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ClEoActionInfo),
            "::",
            stringify!(bitMap)
        )
    );
}
pub type ClEoActionInfoT = ClEoActionInfo;
#[doc = " The argument list that can be provided to the custom action taken\n on water mark hit."]
pub type ClEoActionArgListT = *mut ClPtrT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ClStringT {
    pub length: ClUint32T,
    pub pValue: *mut ClCharT,
}
#[test]
fn bindgen_test_layout_ClStringT() {
    const UNINIT: ::std::mem::MaybeUninit<ClStringT> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ClStringT>(),
        16usize,
        concat!("Size of: ", stringify!(ClStringT))
    );
    assert_eq!(
        ::std::mem::align_of::<ClStringT>(),
        8usize,
        concat!("Alignment of ", stringify!(ClStringT))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ClStringT),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pValue) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ClStringT),
            "::",
            stringify!(pValue)
        )
    );
}
extern "C" {
    pub fn clStringDup(arg1: *const ClStringT) -> *mut ClStringT;
}
