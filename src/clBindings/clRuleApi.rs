pub use crate::clBindings::clCommon::*;
pub use crate::clBindings::clCommonErrors::*;
/* automatically generated by rust-bindgen 0.66.1 */

#[repr(C)]
pub struct __BindgenUnionField<T>(::std::marker::PhantomData<T>);
impl<T> __BindgenUnionField<T> {
    #[inline]
    pub const fn new() -> Self {
        __BindgenUnionField(::std::marker::PhantomData)
    }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T {
        ::std::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T {
        ::std::mem::transmute(self)
    }
}
impl<T> ::std::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self {
        Self::new()
    }
}
impl<T> ::std::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self {
        Self::new()
    }
}
impl<T> ::std::marker::Copy for __BindgenUnionField<T> {}
impl<T> ::std::fmt::Debug for __BindgenUnionField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.write_str("__BindgenUnionField")
    }
}
impl<T> ::std::hash::Hash for __BindgenUnionField<T> {
    fn hash<H: ::std::hash::Hasher>(&self, _state: &mut H) {}
}
impl<T> ::std::cmp::PartialEq for __BindgenUnionField<T> {
    fn eq(&self, _other: &__BindgenUnionField<T>) -> bool {
        true
    }
}
impl<T> ::std::cmp::Eq for __BindgenUnionField<T> {}
pub const CL_RULE_EXPR_FLAG_BITS: u32 = 2;
pub const CL_RULE_ARCH_FLAG_MASK: u32 = 3;
pub const CL_RULE_EXPR_FLAG_MASK: i32 = -4;
#[doc = "  Little endian."]
pub const ClRuleExprFlagsT_CL_RULE_LITTLE_END: ClRuleExprFlagsT = 1;
#[doc = "  Big endian."]
pub const ClRuleExprFlagsT_CL_RULE_BIG_END: ClRuleExprFlagsT = 2;
#[doc = "  Non-zero match."]
pub const ClRuleExprFlagsT_CL_RULE_NON_ZERO_MATCH: ClRuleExprFlagsT = 4;
#[doc = "  Exact match."]
pub const ClRuleExprFlagsT_CL_RULE_MATCH_EXACT: ClRuleExprFlagsT = 8;
#[doc = "  Appending two RBE expression with AND relation."]
pub const ClRuleExprFlagsT_CL_RULE_EXPR_CHAIN_AND: ClRuleExprFlagsT = 16;
#[doc = "  Appending a grouping expression with a AND/OR"]
pub const ClRuleExprFlagsT_CL_RULE_EXPR_CHAIN_GROUP_OR: ClRuleExprFlagsT = 64;
#[doc = "  Its filters acc,  filter the data based on the rule.Expression qualification."]
pub type ClRuleExprFlagsT = ::std::os::raw::c_uint;
#[doc = "  Expression evaluated failed."]
pub const ClRuleResultT_CL_RULE_FALSE: ClRuleResultT = 0;
#[doc = "  Expression evaluation passed."]
pub const ClRuleResultT_CL_RULE_TRUE: ClRuleResultT = 1;
#[doc = "  Unknown result (not used)."]
pub const ClRuleResultT_CL_RULE_UNKNOWN: ClRuleResultT = 2;
#[doc = "  RBE result enum."]
pub type ClRuleResultT = ::std::os::raw::c_uint;
#[doc = "  Rule to filter data.Expression definition."]
#[repr(C)]
pub struct ClRuleExpr {
    #[doc = "  Architecture and other flags."]
    pub flags: ClUint8T,
    #[doc = "  Expression length in multiples of four bytes."]
    pub len: ClUint8T,
    #[doc = "  Offset with the data where expression is applied."]
    pub offset: ClUint16T,
    #[doc = "  Multiple RBEs can be chained to build complex expression."]
    pub next: *mut ClRuleExpr,
    pub BI_u: ClRuleExpr__bindgen_ty_1,
}
#[repr(C)]
pub struct ClRuleExpr__bindgen_ty_1 {
    #[doc = "  Expression mask and value array."]
    pub Byte: __BindgenUnionField<[ClUint8T; 1usize]>,
    pub Int: __BindgenUnionField<[ClUint32T; 1usize]>,
    pub bindgen_union_field: u32,
}
#[test]
fn bindgen_test_layout_ClRuleExpr__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<ClRuleExpr__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ClRuleExpr__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(ClRuleExpr__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<ClRuleExpr__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(ClRuleExpr__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Byte) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ClRuleExpr__bindgen_ty_1),
            "::",
            stringify!(Byte)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Int) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ClRuleExpr__bindgen_ty_1),
            "::",
            stringify!(Int)
        )
    );
}
#[test]
fn bindgen_test_layout_ClRuleExpr() {
    const UNINIT: ::std::mem::MaybeUninit<ClRuleExpr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ClRuleExpr>(),
        24usize,
        concat!("Size of: ", stringify!(ClRuleExpr))
    );
    assert_eq!(
        ::std::mem::align_of::<ClRuleExpr>(),
        8usize,
        concat!("Alignment of ", stringify!(ClRuleExpr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ClRuleExpr),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(ClRuleExpr),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).offset) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(ClRuleExpr),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ClRuleExpr),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).BI_u) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ClRuleExpr),
            "::",
            stringify!(BI_u)
        )
    );
}
#[doc = "  Rule to filter data.Expression definition."]
pub type ClRuleExprT = ClRuleExpr;
extern "C" {
    #[doc = "  \\brief Allocates RBE expression.\n\n  \\par Header File:\n  clRuleApi.h\n\n  \\par Library Name:\n  libClUtils\n\n  \\param len Length of the mask or value in multiple of four bytes.\n  \\param ppExpr (out) Allocated expression is returned here.\n\n  \\retval CL_OK The API executed successfully.\n  \\retval CL_ERR_NULL_POINTER Error\n  \\retval CL_ERR_NO_MEMORY Error\n\n  \\par Description:\n  This function allocates a RBE expression and initializes it\n  appropriately.\n\n  \\sa clRuleExprDeallocate()\n"]
    pub fn clRuleExprAllocate(len: ClUint8T, ppExpr: *mut *mut ClRuleExprT) -> ClRcT;
}
extern "C" {
    #[doc = "  \\brief Frees an RBE expression.\n\n  \\par Header File:\n  clRuleApi.h\n\n  \\par Library Name:\n\n  \\param Expr RBE Expression to be freed.\n\n  \\retval CL_OK The API executed successfully.\n  \\retval CL_ERR_NULL_POINTER when the pExpr is NULL.\n\n  \\par Description:\n  This function Frees an RBE Expression (memory or structures used by RBE expression).\n\n  \\sa clRuleExprAllocate()\n"]
    pub fn clRuleExprDeallocate(pExpr: *mut ClRuleExprT) -> ClRcT;
}
extern "C" {
    #[doc = "  \\brief Appends a RBE expression.\n\n  \\par Header File:\n  clRuleApi.h\n\n  \\par Library Name:\n\n  \\param pFirstExpr RBE Expression on which pNextExpr needs to be appended.\n  \\param pNextExpr RBE Expression which will be appended to pFirstExpr.\n\n  \\retval CL_OK The API executed successfully.\n  \\retval CL_ERR_NULL_POINTER If any one of the two input expressions is null.\n\n  \\par Description:\n  This function appends a expression to another. It is used\n  to create more complex expression by combining existing expressions.\n\n  \\sa clRuleExprAllocate()\n"]
    pub fn clRuleExprAppend(pFirstExpr: *mut ClRuleExprT, pNextExpr: *mut ClRuleExprT) -> ClRcT;
}
extern "C" {
    pub fn clRuleExprDuplicate(
        pSrcExpr: *mut ClRuleExprT,
        ppDstExpr: *mut *mut ClRuleExprT,
    ) -> ClRcT;
}
extern "C" {
    #[doc = "  \\brief Evaluates a complex RBE Expression.\n\n  \\par Header File:\n  clRuleApi.h\n\n  \\par Library Name:\n\n  \\param pExpr RBE Expression to be evaluated.\n  \\param pData Data pointer against which the RBE needs to be compared.\n  \\param dataLen Length of the data in multiples of 4 bytes.\n\n  \\retval CL_RULE_TRUE On true.\n  \\retval CL_RULE_FALSE On false.\n\n  \\par Description:\n  This function evaluates a RBE Expression. RBE expression\n  could be a complex expression, i.e., multiple expressions\n  can be chained together against a flat buffer pData of\n  dataLen length.\n\n  \\sa clRuleDoubleExprEvaluate()\n"]
    pub fn clRuleExprEvaluate(
        pExpr: *mut ClRuleExprT,
        pData: *mut ClUint32T,
        dataLen: ::std::os::raw::c_int,
    ) -> ClRuleResultT;
}
extern "C" {
    #[doc = "  \\brief Evaluates Double RBE Expressions.\n\n  \\par Header File:\n  clRuleApi.h\n\n  \\par Library Name:\n\n  \\param pExpr1 First RBE Expression to be evaluated.\n  \\param pExpr2 Second RBE Expression to be evaluated.\n  \\param dataLen Length of the data in multiples of 4 bytes.\n\n  \\retval CL_RULE_TRUE On true.\n  \\retval CL_RULE_FALSE On false.\n\n  \\par Description:\n  This function evaluates a RBE Expression against another RBE expr.\n  Both expressions are assumed to be of simple type.\n\n  \\sa clRuleExprEvaluate()\n"]
    pub fn clRuleDoubleExprEvaluate(
        pExpr1: *mut ClRuleExprT,
        pExpr2: *mut ClRuleExprT,
    ) -> ClRuleResultT;
}
extern "C" {
    pub fn clRuleExprLocalConvert(pExpr: *mut ClRuleExprT) -> ClRcT;
}
extern "C" {
    pub fn clRuleExprConvert(pExpr: *mut ClRuleExprT) -> ClRcT;
}
extern "C" {
    #[doc = "  \\brief Sets Flags of an RBE expression.\n\n  \\par Header File:\n  clRuleApi.h\n\n  \\par Library Name:\n\n  \\param pExpr RBE Expression for which flags to be set.\n  \\param flags Flags to be set.\n\n  \\retval CL_OK The API executed successfully.\n  \\retval CL_ERR_NULL_POINTER If pExpr is null.\n\n  \\par Description:\n  This function sets the RBE expression flags as specified by\n  the parameter flags.\n\n  \\sa clRuleExprFlagsGet()\n"]
    pub fn clRuleExprFlagsSet(pExpr: *mut ClRuleExprT, flags: ClRuleExprFlagsT) -> ClRcT;
}
extern "C" {
    #[doc = "  \\brief Sets offset of a RBE expression.\n\n  \\par Header File:\n  clRuleApi.h\n\n  \\par Library Name:\n\n  \\param pExpr RBE Expression for which flags to be set.\n  \\param offset Offset value (multiples of 4 bytes).\n\n  \\retval CL_OK The API executed successfully.\n  \\retval CL_ERR_NULL_POINTER If pExpr is null.\n\n  \\par Description:\n  This function sets the offset field of a RBE expression\n  as specified by the offset parameter.\n\n  \\sa clRuleExprOffsetGet()\n"]
    pub fn clRuleExprOffsetSet(pExpr: *mut ClRuleExprT, offset: ClUint16T) -> ClRcT;
}
extern "C" {
    #[doc = "  \\brief Set Mask of an RBE expression.\n\n  \\par Header File:\n  clRuleApi.h\n\n  \\par Library Name:\n\n  \\param pExpr RBE Expression for which flags to be set.\n  \\param offset Offset at which the mask to be set.\n  \\param mask Mask value to be set.\n\n  \\retval CL_OK The API executed successfully.\n  \\retval CL_ERR_NULL_POINTER If pExpr is null.\n\n  \\par Description:\n  This function sets the Mask field of an RBE expression\n  as specified by the parameter mask.\n\n  \\note\n  Offset is in multiple of 4 bytes. Offset here is overall offset,\n  i.e., mask set is expr->mask[offset - expr->offset].\n\n  \\sa clRuleExprMaskGet()\n"]
    pub fn clRuleExprMaskSet(pExpr: *mut ClRuleExprT, offset: ClUint16T, mask: ClUint32T) -> ClRcT;
}
extern "C" {
    #[doc = "  \\brief Set Value of a RBE expression.\n\n  \\par Header File:\n  clRuleApi.h\n\n  \\par Library Name:\n\n  \\param pExpr RBE Expression for which flags to be set.\n  \\param offset Offset at which the value is to be set.\n  \\param mask Mask value to be set.\n\n  \\retval CL_OK The API executed successfully.\n  \\retval CL_ERR_NULL_POINTER If pExpr is null.\n\n  \\par Description:\n  This function sets the value field of a RBE expression\n  to the value specified by the parameter value.\n\n  \\note\n  Offset is in multiple of 4 bytes. Offset here is overall offset,\n  i.e., mask set is expr->mask[offset - expr->offset].\n\n  \\sa clRuleExprValueGet()\n"]
    pub fn clRuleExprValueSet(
        pExpr: *mut ClRuleExprT,
        offset: ClUint16T,
        value: ClUint32T,
    ) -> ClRcT;
}
extern "C" {
    #[doc = "  \\brief Gets RBE expression flags.\n\n  \\par Header File:\n  clRuleApi.h\n\n  \\par Library Name:\n\n  \\param pExpr RBE Expression for which flags to be set.\n  \\param pFlags Flags to be returned.\n\n  \\retval CL_OK The API executed successfully.\n  \\retval CL_ERR_NULL_POINTER If pExpr is null.\n\n  \\par Description:\n  This function gets the flags of a RBE expression.\n\n  \\sa clRuleExprFlagsSet()\n"]
    pub fn clRuleExprFlagsGet(pExpr: *mut ClRuleExprT, pFlags: *mut ClRuleExprFlagsT) -> ClRcT;
}
extern "C" {
    #[doc = "  \\brief Get RBE expression Offset value.\n\n  \\par Header File:\n  clRuleApi.h\n\n  \\par Library Name:\n\n  \\param pExpr  RBE Expression for which flags to be set.\n  \\param pOffset Offset to be returned.\n\n  \\retval CL_OK The API executed successfully.\n  \\retval CL_ERR_NULL_POINTER If any one of the two input expressions is null.\n\n  \\par Description:\n  This function gets the offset value of a RBE expression\n  set using clRuleExprOffsetSet().\n\n  \\sa clRuleExprOffsetSet()\n"]
    pub fn clRuleExprOffsetGet(pExpr: *mut ClRuleExprT, pOffset: *mut ClUint16T) -> ClRcT;
}
extern "C" {
    #[doc = "  \\brief Get RBE expression Mask value.\n\n  \\par Header File:\n  clRuleApi.h\n\n  \\par Library Name:\n\n  \\param pExpr RBE Expression for which flags to be set.\n  \\param offset Get Mask from this Offset.\n  \\param pMask Mask to be returned.\n\n  \\retval CL_OK The API executed successfully.\n  \\retval CL_ERR_NULL_POINTER If any one of the two input expressions is null.\n\n  \\par Description:\n  This function gets the Mask of an RBE expression\n  set using clRuleExprMaskSet().\n\n  \\note\n  Offset is in multiple of 4 bytes. Offset here is overall offset,\n  i.e., mask returned is expr->mask[offset - expr->offset].\n\n  \\sa clRuleExprMaskSet()\n"]
    pub fn clRuleExprMaskGet(
        pExpr: *mut ClRuleExprT,
        offset: ClUint16T,
        pMask: *mut ClUint32T,
    ) -> ClRcT;
}
extern "C" {
    #[doc = "  \\brief Get RBE expression value.\n\n  \\par Header File:\n  clRuleApi.h\n\n  \\par Library Name:\n\n  \\param pExpr  RBE Expression for which flags to be set.\n  \\param offset Get Mask from this Offset.\n  \\param pValue value to be returned.\n\n  \\retval CL_OK The API executed successfully.\n  \\retval CL_ERR_NULL_POINTER If any one of the two input expressions is null.\n\n  \\par Description:\n  This function gets the value of a RBE expression\n  set using clRuleExprValueSet().\n\n  \\note\n  Offset is in multiple of 4 bytes. Offset here is overall offset,\n  i.e., mask returned is expr->mask[offset - expr->offset].\n\n  \\sa clRuleExprValueSet()\n"]
    pub fn clRuleExprValueGet(
        pExpr: *mut ClRuleExprT,
        offset: ClUint16T,
        pValue: *mut ClUint32T,
    ) -> ClRcT;
}
extern "C" {
    #[doc = "  \\brief Get the total memory used by the expression.\n\n  \\par Header File:\n  clRuleApi.h\n\n  \\par Library Name:\n\n  \\param pExpr  RBE Expression.\n\n  \\par Return Value:\n  Length in bytes needed to pack an expression.\n\n  \\par Description:\n  This function returns the memory needed to pack an\n  expression into contiguous memory location.\n\n  \\sa clRuleExprPack()\n"]
    pub fn clRuleExprMemLenGet(pExpr: *mut ClRuleExprT) -> ClUint32T;
}
extern "C" {
    #[doc = "  \\brief Pack an RBE Expression into the given memory area.\n\n  \\par Header File:\n  clRuleApi.h\n\n  \\par Library Name:\n\n  \\param pSrcExpr Source RBE Expression to pack.\n  \\param pBuf Pointer to the memory location where to pack.\n\n  \\retval CL_OK The API executed successfully.\n  \\retval CL_ERR_NULL_POINTER On failure.\n\n  \\par Description:\n  This function packs the given RBE Expression.\n  The expression is packed at the given memory pointed by pBuf.\n  It is assumed that the pBuf contains enough space to accomodate\n  srcExpr. Caller can call clRuleExprMemLenGet() to get\n  the memory needed to pack the srcExpr.\n\n  \\sa clRuleExprMemLenGet(), clRuleExprUnpack()\n"]
    pub fn clRuleExprPack(
        pSrcExpr: *mut ClRuleExprT,
        ppBuf: *mut *mut ClUint8T,
        pLen: *mut ClUint32T,
    ) -> ClRcT;
}
extern "C" {
    #[doc = "  \\brief UnPack a RBE Expression.\n\n  \\par Header File:\n  clRuleApi.h\n\n  \\par Library Name:\n\n  \\param pSrcExpr Source RBE Expression to unpack.\n  \\param pDstExpr Pointer to a new copy of the expression.\n\n  \\retval CL_OK The API executed successfully.\n  \\retval CL_ERR_NULL_POINTER On failure.\n\n  \\par Description:\n  This function makes unpack of the given RBE Expression.\n\n  \\sa clRuleExprPack()\n"]
    pub fn clRuleExprUnpack(
        pBuf: *mut ClUint8T,
        len: ClUint32T,
        ppDstExpr: *mut *mut ClRuleExprT,
    ) -> ClRcT;
}
extern "C" {
    #[doc = "  \\brief Prints a  complex RBE Expression.\n\n  \\par Header File:\n  clRuleApi.h\n\n  \\par Library Name:\n\n  \\param pExpr RBE Expression to be printed.\n\n  \\par Return Value:\n  None.\n\n  \\par Description:\n  This function prints the given RBE Expression\n  which could be a complex expression.\n\n  \\par Related APIs:\n  None.\n"]
    pub fn clRuleExprPrint(pExpr: *mut ClRuleExprT) -> ClRcT;
}
