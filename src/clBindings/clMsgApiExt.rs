pub use crate::clBindings::clCommon::*;
pub use crate::clBindings::saMsg::*;
/* automatically generated by rust-bindgen 0.66.1 */

extern "C" {
    pub fn clMsgDispatchQueueRegister(
        queueHandle: SaMsgQueueHandleT,
        callback: SaMsgMessageReceivedCallbackT,
    ) -> ClRcT;
}
extern "C" {
    pub fn clMsgDispatchQueueDeregister(queueHandle: SaMsgQueueHandleT) -> ClRcT;
}
extern "C" {
    pub fn clMsgQueuePersistRedundancy(queue: *const SaNameT, node: *const SaNameT) -> ClRcT;
}
extern "C" {
    #[doc = " Send a message to members of the queue group with a key for uniform distribution.\n It uses consistent hash to map a given key to a member of the queue group\n A key based message send with consistent hash ensures that given a set of servers,\n a set of keys would always map to the same server.\n Addition or deletion of servers or members from the queue group would result in\n only a few set of keys getting remapped for load distribution.\n This can be used as another load balancing option to existing\n SAF specific load balancing options for queue group message sends."]
    pub fn clMsgQueueGroupSendWithKeySynch(
        msgHandle: SaMsgHandleT,
        group: *const SaNameT,
        message: *mut SaMsgMessageT,
        key: *mut ClCharT,
        keylen: ClInt32T,
        timeout: SaTimeT,
    ) -> SaAisErrorT;
}
extern "C" {
    pub fn clMsgQueueGroupSendWithKeyAsync(
        msgHandle: SaMsgHandleT,
        invocation: SaInvocationT,
        group: *const SaNameT,
        message: *mut SaMsgMessageT,
        key: *mut ClCharT,
        keylen: ClInt32T,
        ackFlags: SaMsgAckFlagsT,
    ) -> SaAisErrorT;
}
#[doc = " Structure that includes a struct iovec which is used to send multiple data chunks."]
pub type iovec_t = iovec;
#[repr(C)]
pub struct ClMsgMessageIovec {
    pub type_: SaUint32T,
    pub version: SaVersionT,
    pub senderName: *mut SaNameT,
    pub priority: SaUint8T,
    pub pIovec: *mut iovec_t,
    pub numIovecs: ClUint32T,
}
#[test]
fn bindgen_test_layout_ClMsgMessageIovec() {
    const UNINIT: ::std::mem::MaybeUninit<ClMsgMessageIovec> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ClMsgMessageIovec>(),
        40usize,
        concat!("Size of: ", stringify!(ClMsgMessageIovec))
    );
    assert_eq!(
        ::std::mem::align_of::<ClMsgMessageIovec>(),
        8usize,
        concat!("Alignment of ", stringify!(ClMsgMessageIovec))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ClMsgMessageIovec),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ClMsgMessageIovec),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).senderName) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ClMsgMessageIovec),
            "::",
            stringify!(senderName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priority) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ClMsgMessageIovec),
            "::",
            stringify!(priority)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pIovec) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ClMsgMessageIovec),
            "::",
            stringify!(pIovec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numIovecs) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ClMsgMessageIovec),
            "::",
            stringify!(numIovecs)
        )
    );
}
pub type ClMsgMessageIovecT = ClMsgMessageIovec;
extern "C" {
    #[doc = " APIs take a struct iovec as an argument and send multiple data chunks;"]
    pub fn clMsgMessageSendIovec(
        msgHandle: SaMsgHandleT,
        destination: *const SaNameT,
        message: *const ClMsgMessageIovecT,
        timeout: SaTimeT,
    ) -> SaAisErrorT;
}
extern "C" {
    pub fn clMsgMessageSendAsyncIovec(
        msgHandle: SaMsgHandleT,
        invocation: SaInvocationT,
        destination: *const SaNameT,
        message: *const ClMsgMessageIovecT,
        ackFlags: SaMsgAckFlagsT,
    ) -> SaAisErrorT;
}
extern "C" {
    pub fn clMsgQueueGroupSendWithKeySynchIovec(
        msgHandle: SaMsgHandleT,
        group: *const SaNameT,
        message: *mut ClMsgMessageIovecT,
        key: *mut ClCharT,
        keylen: ClInt32T,
        timeout: SaTimeT,
    ) -> SaAisErrorT;
}
extern "C" {
    pub fn clMsgQueueGroupSendWithKeyAsyncIovec(
        msgHandle: SaMsgHandleT,
        invocation: SaInvocationT,
        group: *const SaNameT,
        message: *mut ClMsgMessageIovecT,
        key: *mut ClCharT,
        keylen: ClInt32T,
        ackFlags: SaMsgAckFlagsT,
    ) -> SaAisErrorT;
}
