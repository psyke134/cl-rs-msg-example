pub use crate::clBindings::clCommon::*;
pub use crate::clBindings::clTimerApi::*;
pub use crate::clBindings::clHeapApi::*;
pub use crate::clBindings::clArchHeaders::*;
/* automatically generated by rust-bindgen 0.66.1 */

#[repr(C)]
pub struct __BindgenUnionField<T>(::std::marker::PhantomData<T>);
impl<T> __BindgenUnionField<T> {
    #[inline]
    pub const fn new() -> Self {
        __BindgenUnionField(::std::marker::PhantomData)
    }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T {
        ::std::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T {
        ::std::mem::transmute(self)
    }
}
impl<T> ::std::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self {
        Self::new()
    }
}
impl<T> ::std::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self {
        Self::new()
    }
}
impl<T> ::std::marker::Copy for __BindgenUnionField<T> {}
impl<T> ::std::fmt::Debug for __BindgenUnionField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.write_str("__BindgenUnionField")
    }
}
impl<T> ::std::hash::Hash for __BindgenUnionField<T> {
    fn hash<H: ::std::hash::Hasher>(&self, _state: &mut H) {}
}
impl<T> ::std::cmp::PartialEq for __BindgenUnionField<T> {
    fn eq(&self, _other: &__BindgenUnionField<T>) -> bool {
        true
    }
}
impl<T> ::std::cmp::Eq for __BindgenUnionField<T> {}
pub const CL_OSAL_MIN_STACK_SIZE: u32 = 196608;
pub const CL_OSAL_NAME_MAX: u32 = 32;
pub const CL_OSAL_SHM_EXCEPTION_LENGTH: u32 = 2048;
pub const ClOsalSharedMutexFlags_CL_OSAL_SHARED_INVALID: ClOsalSharedMutexFlags = 0;
pub const ClOsalSharedMutexFlags_CL_OSAL_SHARED_NORMAL: ClOsalSharedMutexFlags = 1;
pub const ClOsalSharedMutexFlags_CL_OSAL_SHARED_SYSV_SEM: ClOsalSharedMutexFlags = 2;
pub const ClOsalSharedMutexFlags_CL_OSAL_SHARED_POSIX_SEM: ClOsalSharedMutexFlags = 4;
pub const ClOsalSharedMutexFlags_CL_OSAL_SHARED_RECURSIVE: ClOsalSharedMutexFlags = 8;
pub const ClOsalSharedMutexFlags_CL_OSAL_SHARED_PROCESS: ClOsalSharedMutexFlags = 16;
pub const ClOsalSharedMutexFlags_CL_OSAL_SHARED_ERROR_CHECK: ClOsalSharedMutexFlags = 32;
#[doc = "  The mutex type to be initialized"]
pub type ClOsalSharedMutexFlags = ::std::os::raw::c_uint;
#[doc = "  The mutex type to be initialized"]
pub use self::ClOsalSharedMutexFlags as ClOsalSharedMutexFlagsT;
#[repr(C)]
pub struct ClOsalMutex {
    pub flags: ClOsalSharedMutexFlagsT,
    pub shared_lock: ClOsalMutex_shared_lock,
}
#[repr(C)]
pub struct ClOsalMutex_shared_lock {
    pub mutex: __BindgenUnionField<pthread_mutex_t>,
    pub sem: __BindgenUnionField<ClOsalMutex_shared_lock_ClSem>,
    pub bindgen_union_field: [u64; 5usize],
}
#[repr(C)]
pub struct ClOsalMutex_shared_lock_ClSem {
    pub posSem: sem_t,
    pub semId: ::std::os::raw::c_int,
    pub numSems: ClInt32T,
}
#[test]
fn bindgen_test_layout_ClOsalMutex_shared_lock_ClSem() {
    const UNINIT: ::std::mem::MaybeUninit<ClOsalMutex_shared_lock_ClSem> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ClOsalMutex_shared_lock_ClSem>(),
        40usize,
        concat!("Size of: ", stringify!(ClOsalMutex_shared_lock_ClSem))
    );
    assert_eq!(
        ::std::mem::align_of::<ClOsalMutex_shared_lock_ClSem>(),
        8usize,
        concat!("Alignment of ", stringify!(ClOsalMutex_shared_lock_ClSem))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).posSem) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ClOsalMutex_shared_lock_ClSem),
            "::",
            stringify!(posSem)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).semId) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ClOsalMutex_shared_lock_ClSem),
            "::",
            stringify!(semId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numSems) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(ClOsalMutex_shared_lock_ClSem),
            "::",
            stringify!(numSems)
        )
    );
}
#[test]
fn bindgen_test_layout_ClOsalMutex_shared_lock() {
    const UNINIT: ::std::mem::MaybeUninit<ClOsalMutex_shared_lock> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ClOsalMutex_shared_lock>(),
        40usize,
        concat!("Size of: ", stringify!(ClOsalMutex_shared_lock))
    );
    assert_eq!(
        ::std::mem::align_of::<ClOsalMutex_shared_lock>(),
        8usize,
        concat!("Alignment of ", stringify!(ClOsalMutex_shared_lock))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mutex) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ClOsalMutex_shared_lock),
            "::",
            stringify!(mutex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sem) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ClOsalMutex_shared_lock),
            "::",
            stringify!(sem)
        )
    );
}
#[test]
fn bindgen_test_layout_ClOsalMutex() {
    const UNINIT: ::std::mem::MaybeUninit<ClOsalMutex> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ClOsalMutex>(),
        48usize,
        concat!("Size of: ", stringify!(ClOsalMutex))
    );
    assert_eq!(
        ::std::mem::align_of::<ClOsalMutex>(),
        8usize,
        concat!("Alignment of ", stringify!(ClOsalMutex))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ClOsalMutex),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).shared_lock) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ClOsalMutex),
            "::",
            stringify!(shared_lock)
        )
    );
}
pub type ClOsalMutexT = ClOsalMutex;
pub type ClOsalMutexAttrT = pthread_mutexattr_t;
pub type ClOsalCondAttrT = pthread_condattr_t;
pub const ClOsalSharedType_CL_OSAL_PROCESS_PRIVATE: ClOsalSharedType = 0;
pub const ClOsalSharedType_CL_OSAL_PROCESS_SHARED: ClOsalSharedType = 1;
pub type ClOsalSharedType = ::std::os::raw::c_uint;
pub use self::ClOsalSharedType as ClOsalSharedTypeT;
#[doc = "  The thread condition type wrapped"]
pub type ClOsalCondT = pthread_cond_t;
#[doc = " The type of an identifier to the OSAL Task ID."]
pub type ClOsalTaskIdT = ClUint64T;
pub type ClOsalMutexIdT = *mut ClOsalMutexT;
pub type ClOsalCondIdT = *mut ClOsalCondT;
pub type ClOsalSemIdT = ClHandleT;
#[doc = " The type of an identifier to the OSAL Shared Memory ID."]
pub type ClOsalShmIdT = ClUint32T;
#[doc = " The type of an identifier to the OSAL Process ID."]
pub type ClOsalPidT = ClUint32T;
#[doc = " The type of an identifier to the OSAL Task Data type."]
pub type ClOsalTaskDataT = ClPtrT;
pub type ClNanoTimeT = timespec;
#[doc = " CAllback\ntype of callback function invoked when a process is created."]
pub type ClOsalProcessFuncT =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>;
#[doc = " CAllback\ntype of callback function invoked when the task specific private key is destruyed."]
pub type ClOsalTaskKeyDeleteCallBackT =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>;
#[doc = " Default scheduling mechanism"]
pub const ClOsalSchedulePolicyT_CL_OSAL_SCHED_OTHER: ClOsalSchedulePolicyT = 0;
#[doc = " First-in-first-out"]
pub const ClOsalSchedulePolicyT_CL_OSAL_SCHED_FIFO: ClOsalSchedulePolicyT = 1;
#[doc = " Roundrobin"]
pub const ClOsalSchedulePolicyT_CL_OSAL_SCHED_RR: ClOsalSchedulePolicyT = 2;
#[doc = " The following enumeration type contains schedule policy of the tasks that will be created.\n The values of the ClOsalSchedulePolicyT enumeration type have the following interpretation:\n other is the default scheduling policy\n fifo & rr are used for real time threads (you must be running with superuser priviledges)."]
pub type ClOsalSchedulePolicyT = ::std::os::raw::c_uint;
#[doc = " When the scheduling is CL_OSAL_SCHED_OTHER, priority is not used"]
pub const ClOsalThreadPriorityT_CL_OSAL_THREAD_PRI_NOT_APPLICABLE: ClOsalThreadPriorityT = 0;
#[doc = " Highest thread priority."]
pub const ClOsalThreadPriorityT_CL_OSAL_THREAD_PRI_HIGH: ClOsalThreadPriorityT = 160;
#[doc = " Medium thread priority."]
pub const ClOsalThreadPriorityT_CL_OSAL_THREAD_PRI_MEDIUM: ClOsalThreadPriorityT = 80;
#[doc = " Lowest thread priority."]
pub const ClOsalThreadPriorityT_CL_OSAL_THREAD_PRI_LOW: ClOsalThreadPriorityT = 1;
#[doc = " The following enumeration type contains the various thread priorities.\n The values of the ClOsalProcessFlagT enumeration type have the following interpretation:"]
pub type ClOsalThreadPriorityT = ::std::os::raw::c_uint;
#[doc = " This will create a process with new session."]
pub const ClOsalProcessFlagT_CL_OSAL_PROCESS_WITH_NEW_SESSION: ClOsalProcessFlagT = 1;
#[doc = " This would create a new process group."]
pub const ClOsalProcessFlagT_CL_OSAL_PROCESS_WITH_NEW_GROUP: ClOsalProcessFlagT = 2;
#[doc = "  Process creation flags.\n  The values of the ClOsalProcessFlagT enumeration type have the following interpretation:\n"]
pub type ClOsalProcessFlagT = ::std::os::raw::c_uint;
#[doc = " read-only by this user"]
pub const ClOsalShmSecurityModeFlagT_CL_OSAL_SHM_MODE_READ_USER: ClOsalShmSecurityModeFlagT = 256;
#[doc = " read-only by the group"]
pub const ClOsalShmSecurityModeFlagT_CL_OSAL_SHM_MODE_READ_GROUP: ClOsalShmSecurityModeFlagT = 32;
#[doc = " read-only by everyone"]
pub const ClOsalShmSecurityModeFlagT_CL_OSAL_SHM_MODE_READ_OTHERS: ClOsalShmSecurityModeFlagT = 4;
#[doc = " read/write by this user"]
pub const ClOsalShmSecurityModeFlagT_CL_OSAL_SHM_MODE_WRITE_USER: ClOsalShmSecurityModeFlagT = 128;
#[doc = " read/write by the group"]
pub const ClOsalShmSecurityModeFlagT_CL_OSAL_SHM_MODE_WRITE_GROUP: ClOsalShmSecurityModeFlagT = 16;
#[doc = " read/write by everyone"]
pub const ClOsalShmSecurityModeFlagT_CL_OSAL_SHM_MODE_WRITE_OTHERS: ClOsalShmSecurityModeFlagT = 2;
#[doc = " Shared memory security options"]
pub type ClOsalShmSecurityModeFlagT = ::std::os::raw::c_uint;
#[repr(C)]
pub struct ClOsalShmAreaDefT {
    #[doc = " Place to store the component Exception information."]
    pub exceptionInfo: [ClCharT; 2048usize],
}
#[test]
fn bindgen_test_layout_ClOsalShmAreaDefT() {
    const UNINIT: ::std::mem::MaybeUninit<ClOsalShmAreaDefT> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ClOsalShmAreaDefT>(),
        2048usize,
        concat!("Size of: ", stringify!(ClOsalShmAreaDefT))
    );
    assert_eq!(
        ::std::mem::align_of::<ClOsalShmAreaDefT>(),
        1usize,
        concat!("Alignment of ", stringify!(ClOsalShmAreaDefT))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).exceptionInfo) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ClOsalShmAreaDefT),
            "::",
            stringify!(exceptionInfo)
        )
    );
}
extern "C" {
    #[doc = " Shared memory associated with the component."]
    pub static mut gpClShmArea: *mut ClOsalShmAreaDefT;
}
extern "C" {
    #[doc = " Shared memory ID associated with the component."]
    pub static mut gClCompUniqueShmId: ClOsalShmIdT;
}
extern "C" {
    #[doc = "  \\brief Initializes the Operating System Abstraction Layer (OSAL).\n\n  \\par Header File:\n  clOsalApi.h\n\n  \\par Library File:\n  libClOsal\n\n  \\retval CL_RC_OK This API executed successfully.\n  \\retval CL_ERR_NO_MEM On memory allocation failure.\n  \\retval CL_ERR_MUTEX_CREATE On failure in creating a mutex.\n\n  \\par Description:\n  This API is used to initialize the OSAL. This should be the first\n  API to be called before any of the other OSAL APIs are invoked.\n\n  \\sa clOsalFinalize()\n"]
    pub fn clOsalInitialize(pConfig: ClPtrT) -> ClRcT;
}
extern "C" {
    #[doc = " \\retval CL_RC_OK This API executed successfully.\n \\retval CL_ERR_CL_OSAL_CLEANUP On failure to clean up OSAL.\n \\retval CL_ERR_MUTEX_DELETE On failure in deleting mutex.\n\n \\par Description\n This API is used to clean-up OSAL. This is last OSAL API that is\n    invoked, typically this must be called during system shutdown.\n\n \\sa clOsalInitialize()"]
    pub fn clOsalFinalize() -> ClRcT;
}
extern "C" {
    #[doc = " \\brief Creates a task.\n\n \\param taskName Name of the task. This must be a valid string. NULL is regarded as\n    invalid but the task creation does not fail.\n \\param schedulePolicy Schedule policy can be set as one of the following:\n   \\arg CL_OSAL_SCHED_RR For this, you must be logged in as super-user. It supports\n    priority-based realtime round-robin scheduling.\n   \\arg CL_OSAL_SCHED_FIFO For this, you must be logged in as super-user. It supports priority\n    based pre-emptive scheduling. This parameter is ignored in case of\n    VxWorks.\n   \\arg CL_OSAL_SCHED_OTHER\n \\param priority Priority at which the tasks is executed. The priority must be between\n    1 and 160 (1 - lowest priority 160 - highest priority). Any other\n    value is regarded as wrong and task creation fails.\n \\param stackSize Size (in bytes) of the user stack that must be created when the task\n    is executed. The stack size must be a positive integer. If zero is\n    mentioned, then the default stack size of 4096 bytes would be\n    allocated. If the stack size mentioned is less than the default\n    stack size then the default stack size is assigned.\n \\param fpTaskFunction Entry point of the task. This function is executed when the task is\n    executed. This is a function pointer and NULL argument would result\n    in error.\n \\param pTaskFuncArgument The argument to be passed to \\e fpTaskFuncArgument when the function\n    is executed. This must be a valid pointer and if there are no\n    arguments to be passed then NULL can be passed. Any other value will\n    be invalid.\n\n \\retval CL_RC_OK This API executed successfully.\n \\retval CL_ERR_NULL_PTR On passing a NULL pointer.\n \\retval CL_ERR_INVLD_PARAM On passing invalid parameters.\n \\retval CL_ERR_TASK_ATTRIBUTE_INIT On failure in task attribute initialization.\n \\retval CL_ERR_TASK_CREATE On failure to create task.\n \\retval CL_ERR_TASK_ATTRIBUTE_SET On failure in setting task attributes.\n\n \\par Description\n This API is used to spawn a new task that runs concurrently with the\n    calling task. The new task invokes the user API \\e fpTaskFunction\n    with the argument \\e pTaskFuncArgument to the function. The new task\n    terminates explicitly by calling clOsalTaskDelete or implicitly, by\n    returning from the \\e fpTaskFunction.\n\n \\sa clOsalTaskDelete(), clOsalSelfTaskIdGet(), clOsalTaskNameGet(),\n    clOsalTaskPriorityGet(), clOsalTaskPrioritySet(), clOsalTaskDelay()"]
    pub fn clOsalTaskCreateDetached(
        taskName: *const ClCharT,
        schedulePolicy: ClOsalSchedulePolicyT,
        priority: ClUint32T,
        stackSize: ClUint32T,
        fpTaskFunction: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void,
        >,
        pTaskFuncArgument: *mut ::std::os::raw::c_void,
    ) -> ClRcT;
}
extern "C" {
    #[doc = " \\brief Creates a task.\n\n \\param taskName Name of the task. This must be a valid string. NULL is regarded as\n    invalid but the task creation does not fail.\n \\param schedulePolicy Schedule policy can be set as one of the following:\n   \\arg CL_OSAL_SCHED_RR For this, you must be logged in as super-user. It supports\n    priority-based realtime round-robin scheduling.\n   \\arg CL_OSAL_SCHED_FIFO For this, you must be logged in as super-user. It supports priority\n    based pre-emptive scheduling. This parameter is ignored in case of\n    VxWorks.\n   \\arg CL_OSAL_SCHED_OTHER\n \\param priority Priority at which the tasks is executed. The priority must be between\n    1 and 160 (1 - lowest priority 160 - highest priority). Any other\n    value is regarded as wrong and task creation fails.\n \\param stackSize Size (in bytes) of the user stack that must be created when the task\n    is executed. The stack size must be a positive integer. If zero is\n    mentioned, then the default stack size of 4096 bytes would be\n    allocated. If the stack size mentioned is less than the default\n    stack size then the default stack size is assigned.\n \\param fpTaskFunction Entry point of the task. This function is executed when the task is\n    executed. This is a function pointer and NULL argument would result\n    in error.\n \\param pTaskFuncArgument The argument to be passed to \\e fpTaskFuncArgument when the function\n    is executed. This must be a valid pointer and if there are no\n    arguments to be passed then NULL can be passed. Any other value will\n    be invalid.\n \\param pTaskId (out)The identifier of the task started is stored here. This shall be\n    any valid pointer, NULL will be invalid.\n\n \\retval CL_RC_OK This API executed successfully.\n \\retval CL_ERR_NULL_PTR On passing a NULL pointer.\n \\retval CL_ERR_INVLD_PARAM On passing invalid parameters.\n \\retval CL_ERR_TASK_ATTRIBUTE_INIT On failure in task attribute initialization.\n \\retval CL_ERR_TASK_CREATE On failure to create task.\n \\retval CL_ERR_TASK_ATTRIBUTE_SET On failure in setting task attributes.\n\n \\par Description\n This API is used to spawn a new task that runs concurrently with the\n    calling task. The new task invokes the user API \\e fpTaskFunction\n    with the argument \\e pTaskFuncArgument to the function. The new task\n    terminates explicitly by calling clOsalTaskDelete or implicitly, by\n    returning from the \\e fpTaskFunction.  Since the task it \"attached\",\n    it can be manipulated using the task handle returned in the \\e pTaskId.\n    parameter.\n\n \\sa clOsalTaskDelete(), clOsalSelfTaskIdGet(), clOsalTaskNameGet(),\n    clOsalTaskPriorityGet(), clOsalTaskPrioritySet(), clOsalTaskDelay()"]
    pub fn clOsalTaskCreateAttached(
        taskName: *const ClCharT,
        schedulePolicy: ClOsalSchedulePolicyT,
        priority: ClUint32T,
        stackSize: ClUint32T,
        fpTaskFunction: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void,
        >,
        pTaskFuncArgument: *mut ::std::os::raw::c_void,
        pTaskId: *mut ClOsalTaskIdT,
    ) -> ClRcT;
}
extern "C" {
    #[doc = " \\brief Joins a task\n \\param taskId Identifier of the task to be joined. The taskId must be same as what\n    was returned when the task was created. All other values will be\n    invalid.\n\n \\retval CL_RC_OK This API executed successfully. (Not applicable for deleting the\n    currently executing task)\n \\retval CL_ERR_NO_TASK_EXIST On deleting a task which does not exist.\n \\retval CL_ERR_TASK_DELETE On failure to delete a task.\n\n \\par Description\n This API is used to join a task.  Joining a task means that the calling task\n will wait until the specified task is completed.  Joining a task also cleans\n\n \\sa clOsalTaskCreate(), clOsalSelfTaskIdGet(), clOsalTaskNameGet(),\n    clOsalTaskPriorityGet(), clOsalTaskPrioritySet(), clOsalTaskDelay()"]
    pub fn clOsalTaskJoin(taskId: ClOsalTaskIdT) -> ClRcT;
}
extern "C" {
    #[doc = " \\brief Deletes a task.\n\n \\param taskId Identifier of the task to be deleted. The taskId must be same as what\n    was returned when the task was created. All other values will be\n    invalid.\n\n \\retval CL_RC_OK This API executed successfully. (Not applicable for deleting the\n    currently executing task)\n \\retval CL_ERR_NO_TASK_EXIST On deleting a task which does not exist.\n \\retval CL_ERR_TASK_DELETE On failure to delete a task.\n\n \\par Description\n This API is used to delete a task.\n\n \\sa clOsalTaskCreate(), clOsalSelfTaskIdGet(), clOsalTaskNameGet(),\n    clOsalTaskPriorityGet(), clOsalTaskPrioritySet(), clOsalTaskDelay()"]
    pub fn clOsalTaskDelete(taskId: ClOsalTaskIdT) -> ClRcT;
}
extern "C" {
    #[doc = " \\brief Kills a task  by sending a signal\n\n \\param taskId Identifier of the task to be killed. The taskId must be same as what\n    was returned when the task was created. All other values will be\n    invalid.\n \\param sig Signal to be sent to the task\n\n \\retval CL_RC_OK This API executed successfully. (Not applicable for killing the\n    currently executing task)\n \\retval CL_ERR_NO_TASK_EXIST On killing a task which does not exist.\n \\retval CL_ERR_TASK_DELETE On failure to killing a task.\n\n \\par Description\n This API is used to kill a task by sending a signal identified by\n the sig parameter.\n\n \\sa clOsalTaskCreate(), ClOsalTaskDelete(), clOsalSelfTaskIdGet(),"]
    pub fn clOsalTaskKill(taskId: ClOsalTaskIdT, sig: ClInt32T) -> ClRcT;
}
extern "C" {
    #[doc = " \\brief No longer interested in the task's alive/dead state\n\n \\param taskId Identifier of the task to be detached. The taskId must be same as\n    what was returned when the task was created. All other values will\n    be invalid.\n\n \\retval CL_RC_OK This API executed successfully. (Not applicable for deleting the\n    currently executing task)\n \\retval CL_ERR_NO_TASK_EXIST On deleting a task which does not exist.\n \\retval CL_ERR_TASK_DELETE On failure to delete a task.\n\n \\par Description\n This API is used to tell the platform that this task should run\n    independently of all other tasks. Its return code, or state will not\n    be accessible by the program.\n\n \\sa clOsalTaskCreate(), clOsalSelfTaskIdGet(), clOsalTaskNameGet(),\n    clOsalTaskPriorityGet(), clOsalTaskPrioritySet(), clOsalTaskDelay()"]
    pub fn clOsalTaskDetach(taskId: ClOsalTaskIdT) -> ClRcT;
}
extern "C" {
    #[doc = " \\brief Retrieves task id.\n\n \\param pTaskId (out) Task ID of the calling task is stored here. This must be a\n    valid pointer and cannot be NULL.\n\n \\retval CL_RC_OK This API executed successfully.\n \\retval CL_ERR_NULL_PTR On passing a NULL pointer.\n\n \\par Description\n This API is used to obtain the task Id of the calling task.\n\n \\sa clOsalTaskCreate(), clOsalTaskDelete(), clOsalTaskNameGet(),\n    clOsalTaskPriorityGet(), clOsalTaskPrioritySet(), clOsalTaskDelay()"]
    pub fn clOsalSelfTaskIdGet(pTaskId: *mut ClOsalTaskIdT) -> ClRcT;
}
extern "C" {
    #[doc = " \\brief Retrieves task name.\n\n \\param taskId Task ID of the task for the which the name is to be found. If the\n    task ID is zero then the name of the current task is found.\n \\param ppTaskName (out) Name of the task is stored here. This must be a valid pointer\n    and cannot be NULL.\n\n \\retval CL_RC_OK This API executed successfully.\n \\retval CL_ERR_NULL_PTR On passing a NULL pointer.\n \\retval CL_ERR_NO_TASK_EXIST On requesting for a task name which does not exist.\n\n \\par Description\n This API is used to obtain the name of the task.\n\n \\sa clOsalTaskCreate(), clOsalTaskDelete(), clOsalSelfTaskIdGet(),\n    clOsalTaskPriorityGet(), clOsalTaskPrioritySet(), clOsalTaskDelay()"]
    pub fn clOsalTaskNameGet(taskId: ClOsalTaskIdT, ppTaskName: *mut *mut ClCharT) -> ClRcT;
}
extern "C" {
    #[doc = " \\brief Retrieves the priority of the task.\n\n \\param taskId Task ID of the task for which the priority is to obtained. The task\n    ID must be same as the one that was returned when the task was\n    created. Any other value will be invalid.\n \\param pTaskPriority (out) Priority of the task is stored here. This must be a valid\n    pointer and cannot be NULL.\n\n \\retval CL_RC_OK This API executed successfully.\n \\retval CL_ERR_NULL_PTR On passing a NULL pointer.\n \\retval CL_ERR_TASK_ATTRIBUTE_GET On failure in retrieving the priority of the task.\n\n \\par Description\n This API is used to obtain the priority of a task.\n\n \\sa clOsalTaskCreate(), clOsalTaskDelete(), clOsalSelfTaskIdGet(),\n    clOsalTaskNameGet(), clOsalTaskPrioritySet(), clOsalTaskDelay()"]
    pub fn clOsalTaskPriorityGet(taskId: ClOsalTaskIdT, pTaskPriority: *mut ClUint32T) -> ClRcT;
}
extern "C" {
    #[doc = " \\brief Sets the priority of the task.\n\n \\param taskId Task ID of the task for which the priority is to be set. The task ID\n    must be same as the one that was returned when the task was created.\n    Any other value will be invalid.\n \\param pTaskPriority New priority of the task. This must be between 1 and 160. All other\n    values are invalid.\n\n \\retval CL_RC_OK This API executed successfully.\n \\retval CL_ERR_NULL_PTR On passing a NULL pointer.\n \\retval CL_ERR_TASK_ATTRIBUTE_SET On failure in setting the priority of the task.\n\n \\par Description\n This API is used to set the priority of a task.\n\n \\sa clOsalTaskCreate(), clOsalTaskDelete(), clOsalSelfTaskIdGet(),\n    clOsalTaskNameGet(), clOsalTaskPriorityGet(), clOsalTaskDelay()"]
    pub fn clOsalTaskPrioritySet(taskId: ClOsalTaskIdT, taskPriority: ClUint32T) -> ClRcT;
}
extern "C" {
    #[doc = " \\brief Delays a task.\n\n \\param time Time duration for which the task is delayed. This value is in\n    milliseconds. Any positive value will be valid.\n\n \\retval CL_RC_OK The API executed successfully.\n \\retval CL_ERR_TASK_DELAY On failure in delaying a task.\n\n \\par Description\n This API causes the calling task to relinquish the CPU for the\n    duration specified. For certain OSes like Linux the taks may not get\n    scheduled back after the timedelay mentioned. It may be scheduled at\n    a later time by the scheduler based on the scheduling time interval,\n    also it can be interrupted by signals received by the process and\n    could return before the delay time period.\n\n \\sa clOsalTaskCreate(), clOsalTaskDelete(), clOsalSelfTaskIdGet(),\n    clOsalTaskNameGet(), clOsalTaskPriorityGet(),\n    clOsalTaskPrioritySet()"]
    pub fn clOsalTaskDelay(timeOut: ClTimerTimeOutT) -> ClRcT;
}
extern "C" {
    #[doc = " \\brief Retrieves the current time.\n\n \\param pTime Pointer to variable of type ClTimerTimeOutT, in which the time is\n    returned.\n\n \\retval CL_RC_OK This API executed successfully.\n \\retval CL_ERR_NULL_PTR On passing a NULL pointer.\n \\retval CL_ERR_TIME_OF_DAY On failure in retrieving the time of day.\n\n \\par Description\n This API is used to return the current time (number of seconds and\n    milliseconds) since the Epoch."]
    pub fn clOsalTimeOfDayGet(pTime: *mut ClTimerTimeOutT) -> ClRcT;
}
extern "C" {
    #[doc = "  \\brief Returns the time since Epoch, with a best resolution of 1 nanosecond.  Actual resolution is hardware dependent.\n\n  \\param pTime Current time\n\n  \\retval CL_OK  This API executed successfully.\n  \\retval CL_OSAL_ERR_OS_ERROR The OS abstraction layer has not been\n  initialized. In other words, clOsalInitialize() has not been called.\n  \\retval CL_ERR_NULL_PTR 'pTime' is NULL\n  \\retval CL_ERR_UNSPECIFIED An unknown error has occured in fetching the\n  current time. This will not be returned under normal circumstances.\n\n  \\sa\n  clOsalTimeOfDayGet()\n"]
    pub fn clOsalNanoTimeGet(pTime: *mut ClNanoTimeT) -> ClRcT;
}
extern "C" {
    #[doc = " \\brief Retrieves the time since the machine is up.\n\n \\param pTime Pointer to variable of type ClTimerTimeOutT, in which the time is\n    returned.\n\n \\retval -1 if there is some system error.\n \\retval on success returns the time in microseconds.\n\n \\par Description\n This API is used to return the current time, since the machine is up, in microseconds."]
    pub fn clOsalStopWatchTimeGet() -> ClTimeT;
}
extern "C" {
    pub fn clOsalMutexInit(pMutex: *mut ClOsalMutexT) -> ClRcT;
}
extern "C" {
    pub fn clOsalMutexErrorCheckInit(pMutex: *mut ClOsalMutexT) -> ClRcT;
}
extern "C" {
    pub fn clOsalMutexValueSet(mutexId: ClOsalMutexIdT, value: ClInt32T) -> ClRcT;
}
extern "C" {
    pub fn clOsalMutexValueGet(mutexId: ClOsalMutexIdT, pValue: *mut ClInt32T) -> ClRcT;
}
extern "C" {
    pub fn clOsalProcessSharedMutexInit(
        pMutex: *mut ClOsalMutexT,
        flags: ClOsalSharedMutexFlagsT,
        pKey: *mut ClUint8T,
        keyLen: ClUint32T,
        value: ClInt32T,
    ) -> ClRcT;
}
extern "C" {
    pub fn clOsalSharedMutexCreate(
        pMutex: *mut ClOsalMutexIdT,
        flags: ClOsalSharedMutexFlagsT,
        pKey: *mut ClUint8T,
        keyLen: ClUint32T,
        value: ClInt32T,
    ) -> ClRcT;
}
extern "C" {
    pub fn clOsalRecursiveMutexInit(pMutex: *mut ClOsalMutexT) -> ClRcT;
}
extern "C" {
    pub fn clOsalMutexCreate(pMutexId: *mut ClOsalMutexIdT) -> ClRcT;
}
extern "C" {
    pub fn clOsalMutexErrorCheckCreate(pMutexId: *mut ClOsalMutexIdT) -> ClRcT;
}
extern "C" {
    pub fn clOsalMutexCreateAndLock(pMutexId: *mut ClOsalMutexIdT) -> ClRcT;
}
extern "C" {
    pub fn clOsalMutexLock(mutexId: ClOsalMutexIdT) -> ClRcT;
}
extern "C" {
    pub fn clOsalMutexLockSilent(mutexId: ClOsalMutexIdT) -> ClRcT;
}
extern "C" {
    pub fn clOsalMutexUnlockNonDebug(mutexId: ClOsalMutexIdT) -> ClRcT;
}
extern "C" {
    pub fn clOsalMutexTryLock(mutexId: ClOsalMutexIdT) -> ClRcT;
}
extern "C" {
    pub fn clOsalMutexUnlock(mutexId: ClOsalMutexIdT) -> ClRcT;
}
extern "C" {
    pub fn clOsalMutexUnlockSilent(mutexId: ClOsalMutexIdT) -> ClRcT;
}
extern "C" {
    pub fn clOsalMutexDelete(mutexId: ClOsalMutexIdT) -> ClRcT;
}
extern "C" {
    pub fn clOsalMutexDestroy(pMutex: *mut ClOsalMutexT) -> ClRcT;
}
extern "C" {
    #[doc = " \\brief Initializes a condition variable.\n\n \\param pCond (out) Identifier of the condition variable initialized is stored\n    here. This must be a valid pointer and cannot be NULL.\n\n \\retval CL_RC_OK This API executed successfully.\n \\retval CL_ERR_NULL_PTR On passing a NULL pointer.\n \\retval CL_ERR_CONDITION_INIT On failure in creating a condition variable.\n\n \\par Description\n This API is used to initialize a condition variable.\n Use clOsalCondDelete() to delete it, NOT clOsalCondDestroy()\n\n \\sa clOsalCondDelete(), clOsalCondWait(), clOsalCondBroadcast(), clOsalCondSignal()"]
    pub fn clOsalCondInit(pCond: *mut ClOsalCondT) -> ClRcT;
}
extern "C" {
    #[doc = " \\brief Initializes a condition variable that can be used in multiple processes.\n\n \\param pCond (out) Identifier of the condition variable initialized is stored\n    here. This must be a valid pointer to shared memory.\n\n \\retval CL_RC_OK This API executed successfully.\n \\retval CL_ERR_NULL_PTR On passing a NULL pointer.\n \\retval CL_ERR_CONDITION_INIT On failure in creating a condition variable.\n\n \\par Description\n This API is used to initialize a condition variable.\n Use clOsalCondDestroy() to delete it, NOT clOsalCondDelete()\n\n \\sa clOsalCondDestroy(), clOsalCondWait(), clOsalCondBroadcast(), clOsalCondSignal()"]
    pub fn clOsalProcessSharedCondInit(pCond: *mut ClOsalCondT) -> ClRcT;
}
extern "C" {
    #[doc = " \\brief Creates a condition variable.\n\n \\param pConditionId (out) Identifier of the condition variable created is stored here.\n    This must be a valid pointer and cannot be NULL.\n\n \\retval CL_RC_OK This API executed successfully.\n \\retval CL_ERR_NULL_PTR On passing a NULL pointer.\n \\retval CL_ERR_NO_MEM On memory allocation failure.\n \\retval CL_ERR_CONDITION_CREATE On failure in creating a condition variable.\n\n \\par Description\n This API is used to create a condition variable.  The condition variable is\n allocated on the heap.  Use clOsalCondDelete() to destroy it.\n\n \\sa clOsalCondDelete(), clOsalCondWait(), clOsalCondBroadcast(),\n    clOsalCondSignal()"]
    pub fn clOsalCondCreate(pConditionId: *mut ClOsalCondIdT) -> ClRcT;
}
extern "C" {
    #[doc = " \\brief Deletes a condition variable.\n\n \\param conditionId Identifier of the condition variable to be deleted. No task must be\n    waiting on this condition variable when delete is invoked. This must\n    be the same as one returned when the condition variable was created.\n    Any other value will be invalid.\n\n \\retval CL_RC_OK This API executed successfully.\n \\retval CL_ERR_CONDITION_TIMEDOUT On condition timedout\n \\retval CL_ERR_INVLD_PARAM On passing an invalid parameter.\n \\retval CL_ERR_CONDITION_DELETE On failure in deleting the condition variable.\n\n \\par Description\n This API is used to delete a condition variable, and free associated memory.\n It is paired with clOsalCondCreate()\n \\sa clOsalCondCreate(), clOsalCondWait(), clOsalCondBroadcast(),\n    clOsalCondSignal()"]
    pub fn clOsalCondDelete(conditionId: ClOsalCondIdT) -> ClRcT;
}
extern "C" {
    pub fn clOsalCondDestroy(pCond: *mut ClOsalCondT) -> ClRcT;
}
extern "C" {
    pub fn clOsalCondWait(
        conditionId: ClOsalCondIdT,
        mutexId: ClOsalMutexIdT,
        time: ClTimerTimeOutT,
    ) -> ClRcT;
}
extern "C" {
    #[doc = " \\brief Broadcasts a condition.\n\n \\param conditionId Identifier of the condition variable. This must be the same as one\n    returned when the condition variable was created. Any other value\n    will be invalid.\n\n \\retval CL_RC_OK This API executed successfully.\n \\retval CL_ERR_INVLD_PARAM On passing an invalid parameter.\n \\retval CL_ERR_CONDITION_BROADCAST On failure to broadcast the condition.\n\n \\par Description\n This API is used to resume all the tasks that are waiting on the\n    condition variable. If no tasks are waiting on that condition then\n    nothing happens.\n\n \\sa clOsalCondCreate(), clOsalCondDelete(), clOsalCondWait(),\n    clOsalCondSignal()"]
    pub fn clOsalCondBroadcast(conditionId: ClOsalCondIdT) -> ClRcT;
}
extern "C" {
    #[doc = " \\brief Signals a condition.\n\n \\param conditionId Identifier of the condition variable. This must be the same as one\n    returned when the condition variable was created. Any other value\n    will be invalid.\n\n \\retval CL_RC_OK This API executed successfully.\n \\retval CL_ERR_INVLD_PARAM On passing an invalid parameter.\n \\retval CL_ERR_CONDITION_SIGNAL On failure to signal a condition.\n\n \\par Description\n This API is used to resume one of the tasks that are waiting on the\n    condition variable. If no tasks are waiting on that condition then\n    nothing happens. If there are several threads waiting on the\n    condition then exactly one task is resumed.\n\n \\sa clOsalCondCreate(), clOsalCondDelete(), clOsalCondWait(),\n    clOsalCondBroadcast()"]
    pub fn clOsalCondSignal(conditionId: ClOsalCondIdT) -> ClRcT;
}
extern "C" {
    #[doc = " \\brief Creates a key for thread-specific data.\n\n \\param pKey (out) Pointer to ClUint32T, in which the created key is returned.\n \\param pCallbackFunc Callback function, which is called when the key is deleted using\n    clOsalTaskKeyDelete API.\n\n \\retval CL_RC_OK This API executed successfully.\n \\retval CL_ERR_NULL_PTR On passing a NULL pointer.\n \\retval CL_OS_ERROR On failure to create a key for thread-specific data.\n\n \\par Description\n This API is used to create a key for thread-specific data.\n\n \\sa clOsalTaskKeyDelete(), clOsalTaskDataSet(), clOsalTaskDataGet()"]
    pub fn clOsalTaskKeyCreate(
        pKey: *mut ClUint32T,
        pCallbackFunc: ClOsalTaskKeyDeleteCallBackT,
    ) -> ClRcT;
}
extern "C" {
    #[doc = " \\brief Deletes the key for thread-specific data.\n\n \\param key Key to be deleted.\n\n \\retval CL_RC_OK This API executed successfully.\n \\retval CL_OS_ERROR On failure in deleting the key for thread-specific data.\n\n \\par Description\n This API is used to delete the key for thread-specific data, which is\n    returned by clOsalTaskKeyCreate.\n\n \\sa clOsalTaskKeyCreate(), clOsalTaskDataSet(), clOsalTaskDataGet()"]
    pub fn clOsalTaskKeyDelete(key: ClUint32T) -> ClRcT;
}
extern "C" {
    #[doc = " \\brief Sets the thread-specific data.\n\n \\param key Key for the thread-specific data returned by clOsalTaskKeyCreate API.\n \\param threadData ThreadData to be assigned to the calling task.\n\n \\retval CL_RC_OK This API executed successfully.\n \\retval CL_OS_ERROR On failure to set thread-specific data.\n\n \\par Description\n This API is used to set the thread-specific data for the calling\n    task.\n\n \\sa clOsalTaskKeyCreate(), clOsalTaskKeyDelete(), clOsalTaskDataGet()"]
    pub fn clOsalTaskDataSet(key: ClUint32T, threadData: ClOsalTaskDataT) -> ClRcT;
}
extern "C" {
    #[doc = " \\brief Retrieves the thread-specific data.\n\n \\param key Key for the thread-specific data returned by clOsalTaskKeyCreate API.\n \\param pThreadData (out) Pointer to ClUint32T in which the thread-specific data is\n    returned on success.\n\n \\retval CL_RC_OK This API executed successfully.\n \\retval CL_ERR_NULL_PTR On passing a NULL pointer.\n \\retval CL_OS_ERROR On failure in retrieving the thread-specific data.\n\n \\par Description\n This API is used to return the thread-specific data of the calling\n    task.\n\n \\sa clOsalTaskKeyCreate(), clOsalTaskKeyDelete(), clOsalTaskDataSet()"]
    pub fn clOsalTaskDataGet(key: ClUint32T, pThreadData: *mut ClOsalTaskDataT) -> ClRcT;
}
extern "C" {
    pub fn clOsalPrintf(fmt: *const ClCharT, ...) -> ClRcT;
}
extern "C" {
    #[doc = " \\brief Creates a semaphore.\n\n \\param pName Name of the semaphore to be created. If the same name is specified\n    then the same semaphore ID is returned. Name must not be more than\n    20 characters and cannot be NULL.\n \\param value Value of the semaphore. This is required to set the semaphore before\n    it is used first time. This must be a positive integer and must be\n    less than \\c CL_SEM_MAX_VALUE. Zero will be invalid.\n \\param pSemId (out) Identifier of the semaphore created is stored in this location.\n    This must be a valid pointer and cannot be NULL.\n\n \\retval CL_RC_OK This API executed successfully.\n \\retval CL_ERR_INVLD_PARAM On passing an invalid parameter.\n \\retval CL_ERR_SEM_CREATE On failure in creating a semaphore.\n \\retval CL_ERR_NAME_TOO_LONG If semaphore name is too long.\n \\retval CL_ERR_NULL_PTR On passing a NULL pointer.\n\n \\par Description\n This API is used to create an counting semaphore. If the semaphore\n    with the same name exists then the exisiting semaphore is obtained\n    else a new semaphore is created.\n\n \\sa clOsalSemIdGet(), clOsalSemLock(), clOsalSemTryLock(),\n    clOsalSemUnlock(), clOsalSemValueGet(), clOsalSemDelete()"]
    pub fn clOsalSemCreate(
        pName: *mut ClUint8T,
        value: ClUint32T,
        pSemId: *mut ClOsalSemIdT,
    ) -> ClRcT;
}
extern "C" {
    #[doc = " \\brief Retrieves the semaphore id.\n\n \\param pName Name of the semaphore for the which the ID is required.NULL is not\n    valid.\n \\param pSemId (out) A memory location to store the ID.\n\n \\retval CL_RC_OK This API executed successfully.\n \\retval CL_ERR_INVLD_PARAM On passing an invalid parameter.\n \\retval CL_ERR_NULL_PTR On passing a NULL pointer.\n \\retval CL_ERR_SEM_ID_GET On failure in retrieving the semaphore ID.\n\n \\par Description\n This API is used to obtain the ID of the semaphore if the name is\n    specified.\n\n \\sa clOsalSemCreate(),clOsalSemLock(), clOsalSemTryLock(),\n    clOsalSemUnlock(), clOsalSemValueGet(), clOsalSemDelete()"]
    pub fn clOsalSemIdGet(pName: *mut ClUint8T, pSemId: *mut ClOsalSemIdT) -> ClRcT;
}
extern "C" {
    #[doc = " \\brief Locks a semaphore.\n\n \\param semId Identifier of the semaphore to be locked. This must be the same as\n    what was returned when the semaphore was created. Any other value\n    will be invalid.\n\n \\retval CL_RC_OK This API executed successfully.\n \\retval CL_ERR_INVLD_PARAM On passing an invalid parameter.\n \\retval CL_ERR_SEM_LOCK On failure in locking a semaphore.\n\n \\par Description\n This API is used to lock a semaphore. If the semaphore is already\n    locked (unavailable) then trying to lock the same semaphore suspends\n    the execution of the process until the semaphore is available. The\n    value of the semaphore is decremented.\n\n \\sa clOsalSemCreate(), clOsalSemIdGet(), clOsalSemTryLock(),\n    clOsalSemUnlock(), clOsalSemValueGet(), clOsalSemDelete()"]
    pub fn clOsalSemLock(semId: ClOsalSemIdT) -> ClRcT;
}
extern "C" {
    #[doc = " \\brief Locks a semaphore if it is available.\n\n \\param semId Identifier of the semaphore to be locked. This must be the same as\n    one returned when the semaphore was created. Any other value will be\n    invalid.\n\n \\retval CL_RC_OK This API executed successfully.\n \\retval CL_ERR_INVLD_PARAM On passing an invalid parameter.\n \\retval CL_ERR_SEM_LOCK On failure in try-locking a semaphore.\n\n \\par Description\n This API is used to lock a semaphore if the semaphore is available.\n    If the semaphore is unavailable then the call just returns without\n    blocking. The call returns immediately (non-blocking) on both the\n    cases. If the semaphore is available,then semaphore is locked and\n    will remain locked until it is unlocked explicitly. The value of the\n    semaphore is decremented.\n\n \\sa clOsalSemCreate(), clOsalSemIdGet(), clOsalSemLock(),\n    clOsalSemUnlock(), clOsalSemValueGet(), clOsalSemDelete()"]
    pub fn clOsalSemTryLock(semId: ClOsalSemIdT) -> ClRcT;
}
extern "C" {
    #[doc = " \\brief Unlocks a semaphore.\n\n \\param semId Identifier of the semaphore to be locked. This must be the same as\n    one returned when the semaphore was created. Any other value will be\n    invalid.\n\n \\retval CL_RC_OK This API executed successfully.\n \\retval CL_ERR_INVLD_PARAM On passing an invalid parameter.\n \\retval CL_ERR_SEM_UNLOCK On failure in unlocking a semaphore.\n\n \\par Description\n This API is used to unlock a semaphore.Any process that is blocked on\n    the semaphore resumes execution. If no process is blocked then the\n    semaphore is made available for the others. The value of the\n    semaphore is incremented.\n\n \\sa clOsalSemCreate(), clOsalSemIdGet(), clOsalSemLock(),\n    clOsalSemTryLock(), clOsalSemValueGet(), clOsalSemDelete()"]
    pub fn clOsalSemUnlock(semId: ClOsalSemIdT) -> ClRcT;
}
extern "C" {
    #[doc = " \\brief Retrieves the value of a semaphore.\n\n \\param semId Identifier of the semaphore to be locked. This must be the same as\n    one returned when the semaphore was created. Any other value will be\n    invalid.\n \\param pSemValue (out) Value of the semaphore is stored in the location specified.\n    This must be a valid pointer and cannot be NULL.\n\n \\retval CL_RC_OK This API executed successfully.\n \\retval CL_ERR_NULL_PTR On passing a NULL pointer.\n \\retval CL_ERR_INVLD_PARAM On passing an invalid parameter.\n \\retval CL_ERR_SEM_GET_VALUE On failure in retrieving the value of the semaphore.\n\n \\par Description\n This API is used to return the value of a semaphore.\n\n \\sa clOsalSemCreate(), clOsalSemIdGet(), clOsalSemLock(),\n    clOsalSemTryLock(), clOsalSemUnlock(), clOsalSemDelete()"]
    pub fn clOsalSemValueGet(semId: ClOsalSemIdT, pSemValue: *mut ClUint32T) -> ClRcT;
}
extern "C" {
    #[doc = " \\brief Deletes a semaphore.\n\n \\param semId Identifier of the semaphore to be locked. This must be the same as\n    one returned when the semaphore was created. Any other value will be\n    invalid.\n\n \\retval CL_RC_OK This API executed successfully.\n \\retval CL_ERR_INVLD_PARAM On passing an invalid parameter.\n \\retval CL_ERR_SEM_DELETE On failure in deleting a semaphore.\n\n \\par Description\n This API is used to destroy a semaphore. No process must be waiting\n    for the semaphore while the semaphore is being destroyed. If one or\n    more processes are waiting on the semaphore then the semaphore does\n    not get destroyed.\n\n \\sa clOsalSemCreate(), clOsalSemIdGet(), clOsalSemLock(),\n    clOsalSemTryLock(), clOsalSemUnlock(), clOsalSemValueGet(),"]
    pub fn clOsalSemDelete(semId: ClOsalSemIdT) -> ClRcT;
}
extern "C" {
    #[doc = " \\brief Creates a process.\n\n \\param fpFunction Function to be invoked when the process is created. This must be a\n    valid pointer and cannot be NULL.\n \\param functionArg Argument passed to the \\e fpFunction that is created along with the\n    cretionof the the process. This can be a valid pointer or NULL.\n \\param creationFlags Flags that control certain properties including creation of new\n    session, process group and creating the process in a suspended\n    state.\n \\param pProcessId (out) Id of the process created is stored in this location. This must\n    be a valid pointer cand cannot be NULL.\n\n \\retval CL_RC_OK This API executed successfully.\n \\retval CL_ERR_NULL_PTR On passing a NULL pointer.\n \\retval CL_ERR_PROCESS_CREATE On failure to create a process.\n\n \\par Description\n This API is used to create a process.\n\n \\sa clOsalProcessDelete(), clOsalProcessWait(), clOsalProcessSelfIdGet()"]
    pub fn clOsalProcessCreate(
        fpFunction: ClOsalProcessFuncT,
        functionArg: *mut ::std::os::raw::c_void,
        creationFlags: ClOsalProcessFlagT,
        pProcessId: *mut ClOsalPidT,
    ) -> ClRcT;
}
extern "C" {
    #[doc = " \\brief Deletes a process.\n\n \\param processId Id of the process to be deleted. This must be the same as one\n    returned when the process was created.\n\n \\retval CL_RC_OK This API executed successfully.\n \\retval CL_ERR_PROCESS_DELETE On failure in deleting a process.\n\n \\par Description\n This API is used to delete a process.\n\n \\sa clOsalProcessCreate(), clOsalProcessWait(), clOsalProcessSelfIdGet()"]
    pub fn clOsalProcessDelete(processId: ClOsalPidT) -> ClRcT;
}
extern "C" {
    #[doc = " \\brief Waits for a process to exit.\n\n \\param processId Id of the process for which the calling process needs to wait. This\n    must be the same as one returned when the process was created. If\n    zero is passed then the calling process waits for all the processes,\n    that it created, to exit.\n\n \\retval CL_RC_OK This API executed successfully.\n \\retval CL_ERR_PROCESS_WAIT On failure to wait for a process to exit.\n\n \\par Description\n This API is used to suspend the execution of a process until the the\n    processes created from with in the process has exited.\n\n \\sa clOsalProcessCreate(), clOsalProcessDelete(),\n    clOsalProcessSelfIdGet()"]
    pub fn clOsalProcessWait(processId: ClOsalPidT) -> ClRcT;
}
extern "C" {
    #[doc = " \\brief Retrieves the processId.\n\n \\param pProcessId (out) ProcessId of the caller is stored in this location.\n\n \\retval CL_RC_OK This API executed successfully.\n \\retval CL_ERR_NULL_PTR On passing a NULL pointer.\n\n \\par Description\n This API is used to obtain the processId of the caller.\n\n \\sa clOsalProcessCreate(), clOsalProcessDelete(), clOsalProcessWait(),"]
    pub fn clOsalProcessSelfIdGet(pProcessId: *mut ClOsalPidT) -> ClRcT;
}
extern "C" {
    #[doc = " \\brief Creates a shared memory.\n\n \\param pName Name for the shared memory region to be created. The same name must\n    be specified if the same shared memory is to be used from some other\n    process. This must be a valid pointer and cannot be NULL. Name must\n    not be more than 20 characters.\n \\param size Size of the shared memory to be created. This must be a positive\n    integer.\n \\param pShmId Identifier of the shared memory created is stored in this location.\n    This must be a valid pointer and cannot be NULL.\n\n \\retval CL_RC_OK This API executed successfully.\n \\retval CL_ERR_INVLD_PARAM On passing an invalid parameter.\n \\retval CL_ERR_NULL_PTR On passing a NULL pointer.\n \\retval CL_ERR_NAME_TOO_LONG If the name specified is too long.\n \\retval CL_ERR_SHM_ID_GET On failure to retrieve the ID of the shared memory.\n \\retval CL_ERR_SHM_CREATE On failure to create a shared memory.\n\n \\par Description\n This API is used to create a shared memory region. If the shared\n    memory region with the same name exists then the existing shared\n    memory is obtained, else a new shared memory region is created.\n\n \\sa clOsalShmIdGet(), clOsalShmDelete(), clOsalShmAttach(),\n    clOsalShmDetach(), clOsalShmSecurityModeSet(),\n    clOsalShmSecurityModeGet(), clOsalShmSizeGet()"]
    pub fn clOsalShmCreate(
        pName: *mut ClUint8T,
        size: ClUint32T,
        pShmId: *mut ClOsalShmIdT,
    ) -> ClRcT;
}
extern "C" {
    #[doc = " \\brief Retrieves a shared memory Id.\n\n \\param pName Name of the shared memory region for which the Id is to be obtained.\n    This must be a valid pointer and cannot be NULL.\n \\param pShmId Id of the shared memory is copied into this location. NULL will be\n    invalid.\n\n \\retval CL_RC_OK The API executed successfully.\n \\retval CL_ERR_INVLD_PARAM On passing an invalid parameter.\n \\retval CL_ERR_NULL_PTR On passing a NULL pointer.\n \\retval CL_ERR_SHM_ID_GET On failure in obtaining the shared memory ID.\n\n \\par Description\n This API is used to obtain the shared memory Id.\n\n \\sa clOsalShmCreate(), clOsalShmDelete(), clOsalShmAttach(),\n    clOsalShmDetach(), clOsalShmSecurityModeSet(),\n    clOsalShmSecurityModeGet(), clOsalShmSizeGet()"]
    pub fn clOsalShmIdGet(pName: *mut ClUint8T, pShmId: *mut ClOsalShmIdT) -> ClRcT;
}
extern "C" {
    #[doc = " \\brief Deletes a shared memory.\n\n \\param shmId Id of the shared memory to be deleted. This must be the same as the\n    one that was passed when the shared memory was created. Any other\n    value will be invalid.\n\n \\retval CL_RC_OK This API executed successfully.\n \\retval CL_ERR_INVLD_PARAM On passing an invalid parameter.\n \\retval CL_ERR_SHM_DELETE On failure in deleting the shared memory.\n\n \\par Description\n This API is used to delete a shared memory region. If more than one\n    process has attached this shared memory then the destroy would just\n    mark it for destroy. The shared memory is actually destroyed only\n    after the last detach.\n\n \\sa clOsalShmCreate(), clOsalShmIdGet(), clOsalShmAttach(),\n    clOsalShmDetach(), clOsalShmSecurityModeSet(),\n    clOsalShmSecurityModeGet(), clOsalShmSizeGet()"]
    pub fn clOsalShmDelete(shmId: ClOsalShmIdT) -> ClRcT;
}
extern "C" {
    #[doc = " \\brief Attaches a shared memory.\n\n \\param shmId Identifier of the shared memory region to be attached. This must be\n    same as one returned the shared memory was created. All other values\n    will be invalid.\n \\param pInMem Pointer to the shared memory region to be attached.\n   \\arg NULL\n   \\arg address\n \\param ppOutMem (out) Attached shared memory region is copied to this location. This\n    must be a valid pointer and cannot be NULL.\n\n \\retval CL_RC_OK This API executed successfully.\n \\retval CL_ERR_INVLD_PARAM On passing an invalid parameter.\n \\retval CL_ERR_NULL_PTR On passing a NULL pointer.\n \\retval CL_ERR_SHM_ATTACH On failure in attaching the shared memory.\n\n \\par Description\n This API is used to attach a shared memory region. The attach occurs\n    at the address equal to the address specified by you rounded to the\n    nearest multiple of the page size.\n\n \\sa clOsalShmCreate(), clOsalShmIdGet(),\n    clOsalShmDelete(),clOsalShmDetach(), clOsalShmSecurityModeSet(),\n    clOsalShmSecurityModeGet(), clOsalShmSizeGet()"]
    pub fn clOsalShmAttach(
        shmId: ClOsalShmIdT,
        pInMem: *mut ::std::os::raw::c_void,
        ppOutMem: *mut *mut ::std::os::raw::c_void,
    ) -> ClRcT;
}
extern "C" {
    #[doc = " \\brief Detaches a shared memory.\n\n \\param pMem Pointer to the shared memory region to be detached. The memory must\n    have been attached to the process already. NULL will be invalid.\n\n \\retval CL_RC_OK This API executed successfully.\n \\retval CL_ERR_NULL_PTR On passing a NULL pointer.\n \\retval CL_ERR_SHM_DETACH On failure in detaching shared memory.\n\n \\par Description\n This API is used to detach a shared memory region from the address\n    space of the calling process. The memory segment to be detached must\n    have been attached to the process.\n\n \\sa clOsalShmCreate(), clOsalShmIdGet(), clOsalShmDelete(),\n    clOsalShmAttach(), clOsalShmSecurityModeSet(),\n    clOsalShmSecurityModeGet(), clOsalShmSizeGet()"]
    pub fn clOsalShmDetach(pMem: *mut ::std::os::raw::c_void) -> ClRcT;
}
extern "C" {
    #[doc = " \\brief Sets permissions to shared memory.\n\n \\param shmId Identifier of the shared memory region. This must be same as one\n    returned when the shared memory was created. All other values will\n    be invalid.\n \\param mode Permission to be set. This can be any of the flags specified in \\e\n    ClOsalShmSecurityModeFlagT.\n\n \\retval CL_RC_OK This API executed successfully.\n \\retval CL_ERR_INVLD_PARAM On passing an invalid parameter.\n \\retval CL_ERR_SHM_MODE_SET On failure in setting permissions to shared memory.\n\n \\par Description\n This API is used to set permissions for a shared memory region.This\n    allows only the access modes to be changed.\n\n \\sa clOsalShmCreate(), clOsalShmIdGet(), clOsalShmDelete(),\n    clOsalShmAttach(), clOsalShmDetach(), clOsalShmSecurityModeGet(),\n    clOsalShmSizeGet()"]
    pub fn clOsalShmSecurityModeSet(shmId: ClOsalShmIdT, mode: ClUint32T) -> ClRcT;
}
extern "C" {
    #[doc = " \\brief Retrieves permissions of shared memory.\n\n \\param shmId Identifier of the shared memory region. This must be same as one\n    returned when the shared memory was created. All other values will\n    be invalid.\n \\param pMode (out) Permission of the shared memory will be copied to this\n    location. NULL will be invalid.\n\n \\retval CL_RC_OK This API executed successfully.\n \\retval CL_ERR_INVLD_PARAM On passing an invalid parameter.\n \\retval CL_ERR_NULL_PTR On passing a NULL pointer.\n \\retval CL_ERR_SHM_MODE_GET On failure in retrieving permissions of the shared memory.\n\n \\sa clOsalShmCreate(), clOsalShmIdGet(), clOsalShmDelete(),\n    clOsalShmAttach(), clOsalShmDetach(), clOsalShmSecurityModeSet(),\n    clOsalShmSizeGet()"]
    pub fn clOsalShmSecurityModeGet(shmId: ClOsalShmIdT, pMode: *mut ClUint32T) -> ClRcT;
}
extern "C" {
    #[doc = " \\brief Retrieves the size of shared memory.\n\n \\param shmId Identifier of the shared memory region. This must be same as one\n    returned when the shared memory was created. All other values will\n    be invalid.\n \\param pSize Size of the shared memory is copied into the specified location.\n\n \\retval CL_RC_OK This API executed successfully.:\n \\retval CL_ERR_INVLD_PARAM On passing an invalid parameter.\n \\retval CL_ERR_NULL_PTR On passing a NULL pointer.\n \\retval CL_ERR_SHM_SIZE On failure in retrieving size of the shared memory.\n\n \\par Description\n This API is used to obtain the size of the shared memory that was\n    allocated.\n\n \\sa clOsalShmCreate(), clOsalShmIdGet(), clOsalShmDelete(),\n    clOsalShmAttach(), clOsalShmDetach(), clOsalShmSecurityModeSet(),\n    clOsalShmSecurityModeGet(),"]
    pub fn clOsalShmSizeGet(shmId: ClOsalShmIdT, pSize: *mut ClUint32T) -> ClRcT;
}
extern "C" {
    pub fn clOsalMmap(
        start: ClPtrT,
        length: ClUint32T,
        prot: ClInt32T,
        flags: ClInt32T,
        fd: ClHandleT,
        offset: ClHandleT,
        mmapped: *mut ClPtrT,
    ) -> ClRcT;
}
extern "C" {
    pub fn clOsalMunmap(start: ClPtrT, length: ClUint32T) -> ClRcT;
}
extern "C" {
    pub fn clOsalMsync(start: ClPtrT, length: ClUint32T, flags: ClInt32T) -> ClRcT;
}
extern "C" {
    pub fn clOsalFtruncate(fd: ClFdT, length: off_t) -> ClRcT;
}
extern "C" {
    pub fn clOsalShmOpen(
        name: *const ClCharT,
        oflag: ClInt32T,
        mode: ClUint32T,
        fd: *mut ClFdT,
    ) -> ClRcT;
}
extern "C" {
    pub fn clOsalShmClose(fd: *mut ClFdT) -> ClRcT;
}
extern "C" {
    pub fn clOsalShmUnlink(name: *const ClCharT) -> ClRcT;
}
extern "C" {
    #[doc = " \\brief Installs and initializes the signal handler.\n initialized. In other words, clOsalInitialize() has not been called.\n \\retval CL_ERR_NULL_POINTER 'name' is NULL\n \\retval CL_ERR_OP_NOT_PERMITTED Permission denied to unlink the POSIX shared\n memory object.\n \\retval CL_ERR_DOESNT_EXIST  A POSIX shared memory object by name 'name'\n does not exist\n \\retval CL_ERR_UNSPECIFIED: An unknown error was returned by pathconf()"]
    pub fn clOsalSigHandlerInitialize();
}
extern "C" {
    pub fn clOsalMaxPathGet(path: *const ClCharT, pLength: *mut ClInt32T) -> ClRcT;
}
extern "C" {
    #[doc = "  \\par Synopsis:\n  Returns the size of a page in bytes\n\n  \\par Header File:\n  clOsalApi.h\n  clOsalErrors.h\n\n  \\par Library File:\n  libClOsal.a\n  libClOsal.so\n\n  \\param pSize The returned length\n\n  \\retval CL_OK  This API executed successfully.\n  \\retval CL_OSAL_ERR_OS_ERROR The OS abstraction layer has not been\n  initialized. In other words, clOsalInitialize() has not been called.\n  \\retval CL_ERR_NULL_PTR 'pSize' is NULL\n  \\retval CL_ERR_NOT_SUPPORTED This limit cannot be queried at run-time.\n  \\retval CL_ERR_UNSPECIFIED An unknown error was returned by sysconf()\n\n  \\par Description:\n  None\n\n  \\par Related APIs:\n  None\n"]
    pub fn clOsalPageSizeGet(pSize: *mut ClInt32T) -> ClRcT;
}
extern "C" {
    pub fn clOsalErrorReportHandler(info: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn clOsalMalloc(size: ClUint32T) -> ClPtrT;
}
extern "C" {
    pub fn clOsalCalloc(size: ClUint32T) -> ClPtrT;
}
extern "C" {
    pub fn clOsalFree(pAddress: ClPtrT);
}
extern "C" {
    pub fn clOsalMutexAttrInit(pAttr: *mut ClOsalMutexAttrT) -> ClRcT;
}
extern "C" {
    pub fn clOsalMutexAttrDestroy(pAttr: *mut ClOsalMutexAttrT) -> ClRcT;
}
extern "C" {
    pub fn clOsalMutexAttrPSharedSet(
        pAttr: *mut ClOsalMutexAttrT,
        type_: ClOsalSharedTypeT,
    ) -> ClRcT;
}
extern "C" {
    pub fn clOsalMutexInitEx(pMutex: *mut ClOsalMutexT, pAttr: *mut ClOsalMutexAttrT) -> ClRcT;
}
extern "C" {
    pub fn clOsalCondInitEx(pCond: *mut ClOsalCondT, pAttr: *mut ClOsalCondAttrT) -> ClRcT;
}
extern "C" {
    pub fn clOsalCondAttrInit(pAttr: *mut ClOsalCondAttrT) -> ClRcT;
}
extern "C" {
    pub fn clOsalCondAttrDestroy(pAttr: *mut ClOsalCondAttrT) -> ClRcT;
}
extern "C" {
    pub fn clOsalCondAttrPSharedSet(pAttr: *mut ClOsalCondAttrT, type_: ClOsalSharedTypeT)
        -> ClRcT;
}
