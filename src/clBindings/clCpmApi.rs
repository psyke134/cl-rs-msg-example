pub use crate::clBindings::clCommon::*;
pub use crate::clBindings::clCommonErrors::*;
pub use crate::clBindings::clCntApi::*;
pub use crate::clBindings::clOsalApi::*;
pub use crate::clBindings::clEoApi::*;
pub use crate::clBindings::clTimerApi::*;
pub use crate::clBindings::clCksmApi::*;
pub use crate::clBindings::clIocApi::*;
pub use crate::clBindings::clRmdApi::*;
pub use crate::clBindings::clIocApiExt::*;
pub use crate::clBindings::clCpmConfigApi::*;
pub use crate::clBindings::clCpmErrors::*;
pub use crate::clBindings::clAmsTypes::*;
/* automatically generated by rust-bindgen 0.66.1 */

pub const CL_CPM_RELEASE_CODE: u8 = 66u8;
pub const CL_CPM_MAJOR_VERSION: u32 = 1;
pub const CL_CPM_MINOR_VERSION: u32 = 1;
pub const CL_CPM_EVENT_CHANNEL_NAME: &[u8; 18] = b"CPM_EVENT_CHANNEL\0";
pub const CL_CPM_NODE_EVENT_CHANNEL_NAME: &[u8; 23] = b"CPM_NODE_EVENT_CHANNEL\0";
pub const CL_CPM_IOC_SLOT_BITS: u32 = 16;
pub const CL_CPM_IOC_SLOT_BITS_HEX: u32 = 65535;
pub const CL_CPM_COMP_ARRIVAL_PATTERN: u32 = 1;
pub const CL_CPM_COMP_DEPART_PATTERN: u32 = 2;
pub const CL_CPM_COMP_DEATH_PATTERN: u32 = 4;
pub const CL_CPM_NODE_ARRIVAL_PATTERN: u32 = 8;
pub const CL_CPM_NODE_DEPART_PATTERN: u32 = 16;
pub const CL_CPM_NODE_DEATH_PATTERN: u32 = 32;
#[doc = " The type of the handle supplied by the CPM to the process which\n calls the clCpmClientInitialize() API. This indicates the\n association of the process with the CPM(AMF) client library."]
pub type ClCpmHandleT = ClHandleT;
#[doc = " Indicates a node's arrival."]
pub const ClCpmNodeEventT_CL_CPM_NODE_ARRIVAL: ClCpmNodeEventT = 0;
#[doc = " Indicates a node's graceful departure."]
pub const ClCpmNodeEventT_CL_CPM_NODE_DEPARTURE: ClCpmNodeEventT = 1;
#[doc = " Indicates a node's sudden/ungraceful departure."]
pub const ClCpmNodeEventT_CL_CPM_NODE_DEATH: ClCpmNodeEventT = 2;
#[doc = " Flags that can be used by subscriber to distinguish diffrent\n events related to node."]
pub type ClCpmNodeEventT = ::std::os::raw::c_uint;
#[doc = " Indicates that component is ready to provide service."]
pub const ClCpmCompEventT_CL_CPM_COMP_ARRIVAL: ClCpmCompEventT = 0;
#[doc = " Indicates that component was terminated gracefully."]
pub const ClCpmCompEventT_CL_CPM_COMP_DEPARTURE: ClCpmCompEventT = 1;
#[doc = " Indicates that component was terminated ungracefully,\n i.e. failure event."]
pub const ClCpmCompEventT_CL_CPM_COMP_DEATH: ClCpmCompEventT = 2;
#[doc = " Flags that can be used by subscriber to distinguish diffrent\n component events."]
pub type ClCpmCompEventT = ::std::os::raw::c_uint;
#[doc = " Payload data for the component death event published by the CPM."]
#[repr(C)]
pub struct ClCpmEventPayLoadT {
    #[doc = " Component which failed/lost heartbeat to the CPM."]
    pub compName: ClNameT,
    #[doc = " Node name containing the component."]
    pub nodeName: ClNameT,
    #[doc = " Component ID."]
    pub compId: ClUint32T,
    #[doc = " EO ID."]
    pub eoId: ClEoIdT,
    #[doc = " IOC address of the node containing the component.\n component is located."]
    pub nodeIocAddress: ClIocNodeAddressT,
    #[doc = "  IOC port of the node containing the component."]
    pub eoIocPort: ClIocPortT,
    #[doc = " Indication of whether component is:\n - Coming up\n - Going down gracefully (i.e. termination)\n - Gone down ungracefully (i.e. abnormal exit, crash etc)"]
    pub operation: ClCpmCompEventT,
}
#[test]
fn bindgen_test_layout_ClCpmEventPayLoadT() {
    const UNINIT: ::std::mem::MaybeUninit<ClCpmEventPayLoadT> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ClCpmEventPayLoadT>(),
        544usize,
        concat!("Size of: ", stringify!(ClCpmEventPayLoadT))
    );
    assert_eq!(
        ::std::mem::align_of::<ClCpmEventPayLoadT>(),
        8usize,
        concat!("Alignment of ", stringify!(ClCpmEventPayLoadT))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).compName) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ClCpmEventPayLoadT),
            "::",
            stringify!(compName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nodeName) as usize - ptr as usize },
        258usize,
        concat!(
            "Offset of field: ",
            stringify!(ClCpmEventPayLoadT),
            "::",
            stringify!(nodeName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).compId) as usize - ptr as usize },
        516usize,
        concat!(
            "Offset of field: ",
            stringify!(ClCpmEventPayLoadT),
            "::",
            stringify!(compId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).eoId) as usize - ptr as usize },
        520usize,
        concat!(
            "Offset of field: ",
            stringify!(ClCpmEventPayLoadT),
            "::",
            stringify!(eoId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nodeIocAddress) as usize - ptr as usize },
        528usize,
        concat!(
            "Offset of field: ",
            stringify!(ClCpmEventPayLoadT),
            "::",
            stringify!(nodeIocAddress)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).eoIocPort) as usize - ptr as usize },
        532usize,
        concat!(
            "Offset of field: ",
            stringify!(ClCpmEventPayLoadT),
            "::",
            stringify!(eoIocPort)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).operation) as usize - ptr as usize },
        536usize,
        concat!(
            "Offset of field: ",
            stringify!(ClCpmEventPayLoadT),
            "::",
            stringify!(operation)
        )
    );
}
#[doc = " Payload data for the node arrival/departure event published by the\n CPM."]
#[repr(C)]
pub struct ClCpmEventNodePayLoadT {
    #[doc = " Name of the node for which this event is published."]
    pub nodeName: ClNameT,
    #[doc = " Node IOC Address, where this component is located."]
    pub nodeIocAddress: ClIocNodeAddressT,
    #[doc = " Indication for whether the node is starting up, i.e., \\c CL_CPM_NODE_ARRIVAL\n or shutting down gracefully, i.e., \\c CL_CPM_NODE_DEPARTURE or shutting down\n ungracefully, i.e., \\c CL_CPM_NODE_DEATH."]
    pub operation: ClCpmNodeEventT,
}
#[test]
fn bindgen_test_layout_ClCpmEventNodePayLoadT() {
    const UNINIT: ::std::mem::MaybeUninit<ClCpmEventNodePayLoadT> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ClCpmEventNodePayLoadT>(),
        268usize,
        concat!("Size of: ", stringify!(ClCpmEventNodePayLoadT))
    );
    assert_eq!(
        ::std::mem::align_of::<ClCpmEventNodePayLoadT>(),
        4usize,
        concat!("Alignment of ", stringify!(ClCpmEventNodePayLoadT))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nodeName) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ClCpmEventNodePayLoadT),
            "::",
            stringify!(nodeName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nodeIocAddress) as usize - ptr as usize },
        260usize,
        concat!(
            "Offset of field: ",
            stringify!(ClCpmEventNodePayLoadT),
            "::",
            stringify!(nodeIocAddress)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).operation) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(ClCpmEventNodePayLoadT),
            "::",
            stringify!(operation)
        )
    );
}
#[repr(C)]
pub struct ClCpmCompCSI {
    pub haState: ClAmsHAStateT,
    pub csiDescriptor: ClAmsCSIDescriptorT,
}
#[test]
fn bindgen_test_layout_ClCpmCompCSI() {
    const UNINIT: ::std::mem::MaybeUninit<ClCpmCompCSI> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ClCpmCompCSI>(),
        552usize,
        concat!("Size of: ", stringify!(ClCpmCompCSI))
    );
    assert_eq!(
        ::std::mem::align_of::<ClCpmCompCSI>(),
        8usize,
        concat!("Alignment of ", stringify!(ClCpmCompCSI))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).haState) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ClCpmCompCSI),
            "::",
            stringify!(haState)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).csiDescriptor) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ClCpmCompCSI),
            "::",
            stringify!(csiDescriptor)
        )
    );
}
pub type ClCpmCompCSIT = ClCpmCompCSI;
#[repr(C)]
pub struct ClCpmCompCSIRef {
    pub numCSIs: ClUint32T,
    pub pCSIList: *mut ClCpmCompCSIT,
}
#[test]
fn bindgen_test_layout_ClCpmCompCSIRef() {
    const UNINIT: ::std::mem::MaybeUninit<ClCpmCompCSIRef> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ClCpmCompCSIRef>(),
        16usize,
        concat!("Size of: ", stringify!(ClCpmCompCSIRef))
    );
    assert_eq!(
        ::std::mem::align_of::<ClCpmCompCSIRef>(),
        8usize,
        concat!("Alignment of ", stringify!(ClCpmCompCSIRef))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numCSIs) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ClCpmCompCSIRef),
            "::",
            stringify!(numCSIs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pCSIList) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ClCpmCompCSIRef),
            "::",
            stringify!(pCSIList)
        )
    );
}
pub type ClCpmCompCSIRefT = ClCpmCompCSIRef;
#[doc = " Component specific data which is maintained by CPM."]
#[repr(C)]
pub struct ClCpmCompSpecInfo {
    #[doc = " Arguments of a component."]
    pub numArgs: ClUint32T,
    pub args: *mut *mut ClCharT,
    #[doc = " Healthcheck related information"]
    pub period: ClUint32T,
    pub maxDuration: ClUint32T,
    pub recovery: ClAmsLocalRecoveryT,
}
#[test]
fn bindgen_test_layout_ClCpmCompSpecInfo() {
    const UNINIT: ::std::mem::MaybeUninit<ClCpmCompSpecInfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ClCpmCompSpecInfo>(),
        32usize,
        concat!("Size of: ", stringify!(ClCpmCompSpecInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<ClCpmCompSpecInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(ClCpmCompSpecInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numArgs) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ClCpmCompSpecInfo),
            "::",
            stringify!(numArgs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).args) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ClCpmCompSpecInfo),
            "::",
            stringify!(args)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).period) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ClCpmCompSpecInfo),
            "::",
            stringify!(period)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxDuration) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ClCpmCompSpecInfo),
            "::",
            stringify!(maxDuration)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).recovery) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ClCpmCompSpecInfo),
            "::",
            stringify!(recovery)
        )
    );
}
#[doc = " Component specific data which is maintained by CPM."]
pub type ClCpmCompSpecInfoT = ClCpmCompSpecInfo;
#[doc = " \\brief Component Manager requests the component, identified by \\e\n compName, to execute healthcheck using \\e healthcheckkey\n [Asynchronous Call].\n\n \\param invocation Particular invocation of this callback function.\n\n \\param pCompName Pointer to the name of the component that must\n undergo healthcheck.\n\n \\param pHealthCheckKey Key to fetch the healthcheck related\n attributes.\n"]
pub type ClCpmHealthCheckCallbackT = ::std::option::Option<
    unsafe extern "C" fn(
        invocation: ClInvocationT,
        pCompName: *const ClNameT,
        pHealthCheckKey: *mut ClAmsCompHealthcheckKeyT,
    ) -> ClRcT,
>;
#[doc = " \\brief Component Manager requests the component, identified by \\e\n compName, to gracefully shutdown [Asynchronous Call with reply].\n\n \\param invocation Particular invocation of this callback function.\n\n \\param pCompName Pointer to the name of the component that must\n gracefully terminate.\n"]
pub type ClCpmTerminateCallbackT = ::std::option::Option<
    unsafe extern "C" fn(invocation: ClInvocationT, pCompName: *const ClNameT) -> ClRcT,
>;
#[doc = " \\brief Component Manager requests the component, identified by \\e\n compName, to assume a particular HA state, specified by \\e haState,\n for one or all the CSIs [Asynchronous Call].\n\n \\param invocation Particular invocation of this callback function.\n\n \\param pCompName Pointer to the name of the component to which a\n CSI needs to be assigned.\n\n \\param haState HA-state to be assigned for CSI identified by \\e\n csiDescriptor, or for all CSIs, already supported by component [if\n \\c CSI_TARGET_ALL is set in \\e csiFlags of \\e csiDescriptor].\n\n \\param csiDescriptor Information about the CSI.\n\n \\sa ClCpmCSIRmvCallbackT"]
pub type ClCpmCSISetCallbackT = ::std::option::Option<
    unsafe extern "C" fn(
        invocation: ClInvocationT,
        pCompName: *const ClNameT,
        haState: ClAmsHAStateT,
        csiDescriptor: ClAmsCSIDescriptorT,
    ) -> ClRcT,
>;
#[doc = " \\brief Removes one or all the assigned CSIs.  Component Manager\n requests the component, identified by \\e compName, to remove a\n particular CSI or all the CSIs [Asynchronous Call].\n\n \\param invocation Particular invocation of this callback function.\n\n \\param pCompName Pointer to the name of the component to which a\n CSI needs to be assigned.\n\n \\param pCsiName Pointer to the \\e csiName that must be removed from\n component identified by \\e compName.\n\n \\param csiFlags Flags, which specify whether one or more CSI are\n affected.\n\n \\sa ClCpmCSISetCallbackT"]
pub type ClCpmCSIRmvCallbackT = ::std::option::Option<
    unsafe extern "C" fn(
        invocation: ClInvocationT,
        pCompName: *const ClNameT,
        pCsiName: *const ClNameT,
        csiFlags: ClAmsCSIFlagsT,
    ) -> ClRcT,
>;
#[doc = " \\brief Requested information gets delivered to \\e\n notificationBuffer. Type of information returned in this buffer\n depends on the \\e trackFlag parameter of the \\e\n clAMSProtectionGroupTrack function [Asynchronous Call]\n\n \\param pCsiName Pointer to the \\e csiName that must be removed from\n component identified by \\e compName.\n\n \\param pNotificationBuffer Pointer to a notification buffer, which\n contains the requested information.\n\n \\param numberOfMembers Number of components that belongs to\n protection group associated with the CSI, designated by \\e csiName.\n\n \\param error Indication whether Component Manager was able to\n perform the operation.\n"]
pub type ClCpmProtectionGroupTrackCallbackT = ::std::option::Option<
    unsafe extern "C" fn(
        pCsiName: *const ClNameT,
        pNotificationBuffer: *mut ClAmsPGNotificationBufferT,
        numberOfMembers: ClUint32T,
        error: ClUint32T,
    ),
>;
#[doc = " \\brief Component Manager requests the proxy component to\n instantiate the component, identified by \\e proxiedCompName\n [Asynchronous Call].\n\n \\param invocation Particular invocation of this callback function.\n\n \\param pProxiedCompName Pointer to the name of the component which\n needs to be instantiated.\n\n \\sa ClCpmProxiedComponentCleanupCallbackT"]
pub type ClCpmProxiedComponentInstantiateCallbackT = ::std::option::Option<
    unsafe extern "C" fn(invocation: ClInvocationT, pProxiedCompName: *const ClNameT) -> ClRcT,
>;
#[doc = " \\brief Component Manager requests the proxy component to cleanup\n the component, identified by \\e proxiedCompName [Asynchronous\n call].\n\n \\param invocation Particular invocation of this callback function.\n\n \\param pProxiedCompName Pointer to the name of the component to\n which needs to be cleaned up.\n\n \\sa ClCpmProxiedComponentInstantiateCallbackT"]
pub type ClCpmProxiedComponentCleanupCallbackT = ::std::option::Option<
    unsafe extern "C" fn(invocation: ClInvocationT, pProxiedCompName: *const ClNameT) -> ClRcT,
>;
#[doc = " \\brief This is the type of the callback fuction, which will be\n called when an node/component arrival/departure event occurs.\n\n \\param event Type of the event indicating whether it is node arrival/departure\n or component arrival/departure.\n\n \\param pArg Argument to the callback fuction.\n\n \\param pAddress Address of the node/component where the \\e event occurred.\n"]
pub type ClCpmNotificationFuncT = ::std::option::Option<
    unsafe extern "C" fn(event: ClIocNotificationIdT, pArg: ClPtrT, pAddress: *mut ClIocAddressT),
>;
#[doc = " The structure ClCpmCallbacksT contains the various callback\n functions that the Component Manager can invoke on a component."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ClCpmCallbacksT {
    #[doc = " Callback for checking the health of the component."]
    pub appHealthCheck: ClCpmHealthCheckCallbackT,
    #[doc = " Callback for gracefully shutting down the component."]
    pub appTerminate: ClCpmTerminateCallbackT,
    #[doc = " Callback for assigning the component service instance to the\n component."]
    pub appCSISet: ClCpmCSISetCallbackT,
    #[doc = " Callback for removing the component service instance assigned\n to the component."]
    pub appCSIRmv: ClCpmCSIRmvCallbackT,
    #[doc = " Callback invoked when the component registers for tracking\n changes in protection group and protection group configuration\n changes."]
    pub appProtectionGroupTrack: ClCpmProtectionGroupTrackCallbackT,
    #[doc = " Callback for instantiating a proxied component."]
    pub appProxiedComponentInstantiate: ClCpmProxiedComponentInstantiateCallbackT,
    #[doc = " Callback for cleaning up a proxied component."]
    pub appProxiedComponentCleanup: ClCpmProxiedComponentCleanupCallbackT,
}
#[test]
fn bindgen_test_layout_ClCpmCallbacksT() {
    const UNINIT: ::std::mem::MaybeUninit<ClCpmCallbacksT> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ClCpmCallbacksT>(),
        56usize,
        concat!("Size of: ", stringify!(ClCpmCallbacksT))
    );
    assert_eq!(
        ::std::mem::align_of::<ClCpmCallbacksT>(),
        8usize,
        concat!("Alignment of ", stringify!(ClCpmCallbacksT))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).appHealthCheck) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ClCpmCallbacksT),
            "::",
            stringify!(appHealthCheck)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).appTerminate) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ClCpmCallbacksT),
            "::",
            stringify!(appTerminate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).appCSISet) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ClCpmCallbacksT),
            "::",
            stringify!(appCSISet)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).appCSIRmv) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ClCpmCallbacksT),
            "::",
            stringify!(appCSIRmv)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).appProtectionGroupTrack) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ClCpmCallbacksT),
            "::",
            stringify!(appProtectionGroupTrack)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).appProxiedComponentInstantiate) as usize - ptr as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ClCpmCallbacksT),
            "::",
            stringify!(appProxiedComponentInstantiate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).appProxiedComponentCleanup) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ClCpmCallbacksT),
            "::",
            stringify!(appProxiedComponentCleanup)
        )
    );
}
extern "C" {
    #[doc = "  \\brief Initializes the client Component Manager library.\n\n  \\par Header File:\n  clCpmApi.h\n\n  \\param pCpmHandle Handle of the component.\n  \\param pCallback Callbacks provided by the application to the Component\n  Manager.\n  \\param pVersion Required version number.\n\n  \\retval CL_OK The API executed successfully.\n  \\retval CL_ERR_NULL_POINTER On passing a NULL pointer.\n\n  \\par Description:\n  Before invoking this API, the EO must be created. This API is used to\n  update the EO client table internally based on \\e ClCpmCallbacksT.\n  It also ensures that the Component Manager client and Server Libraries are\n  compatible in version.\n\n  \\note\n  This API is equivalent to \\e saAmfInitialize, which makes a synchronous call.\n\n  \\par Library Files:\n  ClAmfClient\n\n  \\sa clCpmClientFinalize()\n"]
    pub fn clCpmClientInitialize(
        pCpmHandle: *mut ClCpmHandleT,
        pCallback: *const ClCpmCallbacksT,
        pVersion: *mut ClVersionT,
    ) -> ClRcT;
}
extern "C" {
    #[doc = "  \\brief Cleans up the client Component Manager library.\n\n  \\par Header File:\n  clCpmApi.h\n\n  \\param cpmHandle Handle returned by \\e clCpmClientInitialize API.\n\n  \\retval CL_OK The API executed successfully.\n\n  \\par Description:\n  This API is used to clean up the client Component Manager library.\n  It releases all the resources acquired when clCpmClientInitialize()\n  was called. The \\e cpmHandle will become invalid after calling\n  this API.\n\n  \\note\n  This API is equivalent to \\e saAmfFinalize, which makes an asynchronous call.\n\n  \\par Library Files:\n  ClAmfClient\n\n  \\sa clCpmClientInitialize()\n"]
    pub fn clCpmClientFinalize(cpmHandle: ClCpmHandleT) -> ClRcT;
}
extern "C" {
    #[doc = "  \\brief Returns an operating system handle for detecting\n  pending callbacks.\n\n  \\par Header File:\n  clCpmApi.h\n\n  \\param cpmHandle Handle returned by \\e clCpmClientInitialize API.\n  \\param pSelectionObject A pointer to the operating system handle that the\n  process can use to detect pending callbacks\n\n  \\retval CL_OK The API executed successfully.\n\n  \\par Description:\n  This API returns the operating system handle \\e pSelectionObject,\n  associated with the handle \\e cpmHandle. The process can use this operating\n  system handle to detect pending callbacks, instead of repeatedly invoking\n  clCpmDispatch() for this purpose.\n  \\par\n  The operating system handle returned by this API is a file descriptor\n  that is used with poll() or select() systems call detect incoming\n  callbacks.\n  \\par\n  The \\e pSelectionObject returned by this API is valid until\n  clCpmClientFinalize() is invoked on the same handle \\e cpmHandle.\n\n  \\par Library Files:\n  ClAmfClient\n\n  \\sa clCpmClientInitialize(), clCpmDispatch()\n"]
    pub fn clCpmSelectionObjectGet(
        cpmHandle: ClCpmHandleT,
        pSelectionObject: *mut ClSelectionObjectT,
    ) -> ClRcT;
}
extern "C" {
    #[doc = "  \\brief Invoke pending callbacks.\n\n  \\par Header File:\n  clCpmApi.h\n\n  \\param cpmHandle Handle returned by \\e clCpmClientInitialize API.\n  \\param dispatchFlags Flags that specify the callback execution behaviour\n  of this function\n\n  \\retval CL_OK The API executed successfully.\n\n  \\par Description:\n  This API invokes, in the context of the calling EO, pending callbacks for\n  handle \\e cpmHandle in a way that is specified by the \\e dispatchFlags\n  parameter.\n\n  \\par Library Files:\n  ClAmfClient\n\n  \\sa clCpmClientInitialize(), clCpmSelectionObjectGet()\n"]
    pub fn clCpmDispatch(cpmHandle: ClCpmHandleT, dispatchFlags: ClDispatchFlagsT) -> ClRcT;
}
extern "C" {
    #[doc = "  \\brief Registers a component with CPM.\n\n  \\par Header File:\n  clCpmApi.h\n\n  \\param cpmHandle Handle returned by \\e clCpmClientInitialize API.\n  \\param pCompName Name of the component.\n  \\param pProxyCompName Name of the component, proxy for \\e pCompName.\n\n  \\retval CL_OK The API executed successfully.\n  \\retval CL_ERR_NULL_POINTER On passing Null Pointer\n  \\retval CL_CPM_ERR_INIT If callbacks are provided during the\n  initialization is improper.\n  \\retval CL_CPM_ERR_EXIST If the component has already been registered.\n\n  \\par Description:\n  This API is used to register a component with CPM. It can also be used\n  by a proxy component to register a proxied component. By calling this\n  API, the component is indicating that it is up and running and is ready\n  to provide service.\n\n  \\note\n  This API is equivalent to \\e saAmfComponentRegister, which makes a\n  synchronous call.\n\n  \\par Library Files:\n  ClAmfClient\n\n  \\sa clCpmComponentUnregister()\n"]
    pub fn clCpmComponentRegister(
        cpmHandle: ClCpmHandleT,
        pCompName: *const ClNameT,
        pProxyCompName: *const ClNameT,
    ) -> ClRcT;
}
extern "C" {
    #[doc = "  \\brief Un-registers a component.\n\n  \\par Header File:\n  clCpmApi.h\n\n  \\param cpmHandle Handle returned by \\e clCpmClientInitialize API.\n  \\param pCompName Name of the component.\n  \\param pProxyCompName Name of the component proxied by \\e pCompName\n  component.\n\n  \\retval CL_OK The API executed successfully.\n  \\retval CL_ERR_NULL_POINTER On passing a NULL pointer.\n  \\retval CL_CPM_ERR_BAD_OPERATION If the component identified by\n  \\e pCompName has not unregistered all the proxied components OR\n  \\e proxyComp is not the proxy for \\e pCompName.\n\n  \\par Description:\n  This API is used for two purposes:\n  Either a proxy component can unregister one of its proxied components or\n  a component can unregister itself. The \\e cpmHandle in this\n  API must be same as that used in the corresponding\n  clCpmComponentRegister() call.\n\n  \\note\n  This API is equivalent to \\e saAmfComponentUnregister, which makes an\n  asynchronous call.\n\n  \\par Library Files:\n  ClAmfClient\n\n  \\sa clCpmClientInitialize(), clCpmComponentRegister()\n"]
    pub fn clCpmComponentUnregister(
        cpmHandle: ClCpmHandleT,
        pCompName: *const ClNameT,
        pProxyCompName: *const ClNameT,
    ) -> ClRcT;
}
extern "C" {
    #[doc = "  \\brief Returns the component name.\n\n  \\par Header File:\n  clCpmApi.h\n\n  \\param cpmHandle Handle returned by \\e clCpmClientInitialize API.\n  \\param pCompName Name of the component.\n\n  \\retval CL_OK The API executed successfully.\n  \\retval CL_ERR_NULL_POINTER On passing a NULL pointer.\n\n  \\par Description:\n  This API returns the name of the component the calling process belongs to.\n  This API can be invoked by the process before its component has been\n  registered with the CPM. The component name provided by this API should be\n  used by a process when it registers its local component.\n\n  \\note\n  This API is equivalent to \\e saAmfComponentNameGet.\n\n  \\par Library Files:\n  ClAmfClient\n\n  \\sa clCpmClientInitialize(), clCpmComponentRegister()\n"]
    pub fn clCpmComponentNameGet(cpmHandle: ClCpmHandleT, pCompName: *mut ClNameT) -> ClRcT;
}
extern "C" {
    pub fn clCpmComponentDNNameGet(
        cpmHandle: ClCpmHandleT,
        pCompName: *mut ClNameT,
        pDNName: *mut ClNameT,
    ) -> ClRcT;
}
extern "C" {
    #[doc = "  \\brief Respond to AMF with the result of components execution of a\n         particular request by AMF.\n\n  \\par Header File:\n  clCpmApi.h\n\n  \\param cpmHandle Handle returned by \\e clCpmClientInitialize API.\n  \\param invocation associates an invocation of this response function\n  with a particular invocation of a callback function by the cpm.\n  \\param rc Status of executing a particular callback of AMF.\n\n  \\retval CL_OK The API executed successfully.\n\n  \\par Description:\n  This API is used to respond the success and failure of the callback\n  invoked by CPM. Through this API the component responds to the CPM\n  with the result of its execution of a particular request of the\n  CPM designated by the \\e invocation.\n\n  \\note\n  This API is equivalent to \\e saAmfResponse.\n\n  \\par Library Files:\n  ClAmfClient\n\n  \\sa clCpmClientInitialize(), clCpmComponentRegister()\n"]
    pub fn clCpmResponse(cpmHandle: ClCpmHandleT, invocation: ClInvocationT, rc: ClRcT) -> ClRcT;
}
extern "C" {
    #[doc = "  \\brief Returns the HA state of the component.\n\n  \\par Header File:\n  clCpmApi.h\n\n  \\param cpmHandle Handle returned by \\e clCpmClientInitialize API.\n  \\param compName A pointer to the name of the component for which the\n  information is requested\n  \\param csiName A pointer to the name of the component service instance\n  for which the information is requested\n  \\param haState Pointer to the HA state that the AMS is assigning to the\n  component, identified by \\e compName, on behalf of the component service\n  instance, identified by \\e csiName.\n\n  \\retval CL_OK The API executed successfully.\n  \\retval CL_ERR_NULL_POINTER on passing the unallocated node Name\n  \\retval CL_ERR_DOESNT_EXIST CPM library is not able to retrieve the\n  nodeName.\n\n  \\par Description:\n  This API returns the HA state of a component, identified by \\e compName,\n  on behalf of the component service instance, identified by \\e csiName.\n  The HA state of the component indicates whether it is currently responsible\n  to provide service characterized by the component service instance assigned\n  to it, whether it is a standby or whether it is in the quiesced state.\n\n  \\par Library Files:\n  libClAmfClient\n\n  \\sa clCpmClientInitialize()\n"]
    pub fn clCpmHAStateGet(
        cpmHandle: ClCpmHandleT,
        compName: *mut ClNameT,
        csiName: *mut ClNameT,
        haState: *mut ClAmsHAStateT,
    ) -> ClRcT;
}
extern "C" {
    #[doc = "  \\brief Respond to AMF whether it was able to successfully service\n         all pending requests for a particular component service\n         instance, following the earlier request by AMF to the component\n         to enter the \\e CL_AMS_HA_STATE_QUIESCING HA state via the\n         components ::ClCpmCSISetCallbackT callback.\n\n  \\par Header File:\n  clCpmApi.h\n\n  \\param cpmHandle Handle returned by \\e clCpmClientInitialize API.\n  \\param invocation Associates an invocation of this response function\n                    with a particular invocation of a callback function\n                    by the CPM.\n  \\param retCode Indicates the status of the quiescing operation.\n\n  \\retval CL_OK The API executed successfully.\n\n  \\par Description:\n  This API is used to respond the success and failure of the\n  callback invoked by CPM for the quiescing the HA state of a given\n  CSI. Using this call a component can notify the CPM that it has\n  successfully stopped its activity related to a particular\n  component service instance or to all component service instances\n  assigned to it, following a previous request by the AMS to enter\n  the \\c CL_AMS_HA_STATE_QUIESCING HA state for that particular\n  component service instance or to all component service instances.\n\n  \\note\n  This API is equivalent to \\e saAmfCSIQuiescingComplete.\n\n  \\par Library Files:\n  ClAmfClient\n\n  \\sa clCpmClientInitialize(), clCpmComponentRegister(), clCpmResponse()\n"]
    pub fn clCpmCSIQuiescingComplete(
        cpmHandle: ClCpmHandleT,
        invocation: ClInvocationT,
        retCode: ClRcT,
    ) -> ClRcT;
}
extern "C" {
    #[doc = "  \\brief Notifies about the failed component.\n\n  \\par Header File:\n  clCpmApi.h\n\n  \\param cpmHandle Handle returned by \\e clCpmClientInitialize API.\n  \\param pCompName Pointer to the component name for which the failure is\n  notified.\n  \\param errorDetectionTime Time when the error is detected.\n  \\param recommendedRecovery Recommonded recovery to be performed using AMF.\n  \\param alarmHandle This is the key returned by the \\e clAlarmRaise function.\n\n  \\retval CL_OK The API executed successfully.\n  \\retval CL_ERR_NULL_POINTER On passing a NULL pointer.\n\n  \\par Description:\n  This API is used to notify the Component Manager about the failure\n  of a component. It reports an error and provides a recovery\n  recommendation to the AMF. The AMF will react on the error report\n  and carry out a recovery operation to retain the availability of\n  component service instances supported by the erroneous\n  component. The AMF will not carry out weaker recovery action than\n  that recommended by the above API, but it may decide to escalate\n  to higher recovery level.\n\n  \\note\n  This API is equivalent to \\e saAmfComponentFailureReport, which makes a\n  synchronous call.\n\n  \\par Library Files:\n  ClAmfClient\n\n  \\sa clCpmClientInitialize(), clCpmComponentFailureClear()\n"]
    pub fn clCpmComponentFailureReport(
        cpmHandle: ClCpmHandleT,
        pCompName: *const ClNameT,
        errorDetectionTime: ClTimeT,
        recommendedRecovery: ClAmsLocalRecoveryT,
        alarmHandle: ClUint32T,
    ) -> ClRcT;
}
extern "C" {
    #[doc = "  \\brief Notifies about the restoration of the failed component.\n\n  \\par Header File:\n  clCpmApi.h\n\n  \\param cpmHandle Handle returned by \\e clCpmClientInitialize API.\n  \\param pCompName Pointer to the component name for which the failure is\n  notified.\n\n  \\retval CL_OK The API executed successfully.\n  \\retval CL_ERR_NULL_POINTER On passing a NULL pointer.\n\n  \\par Description:\n  This API is used to notify the Component Manager that the failed component\n  is restored. It cancels the failure notification made by\n  clCpmComponentFailureReport().\n\n  \\note\n  This API is equivalent to \\e saAmfComponentFailureClear, which makes a\n  synchronous call.\n\n  \\par Library Files:\n  ClAmfClient\n\n  \\sa clCpmClientInitialize(), clCpmComponentFailureReport()\n"]
    pub fn clCpmComponentFailureClear(cpmHandle: ClCpmHandleT, pCompName: *mut ClNameT) -> ClRcT;
}
extern "C" {
    #[doc = "  \\brief Starts the component healthcheck.\n\n  \\par Header File:\n  clCpmApi.h\n\n  \\param cpmHandle Handle returned by \\e clCpmClientInitialize API.\n  \\param pCompName Name of the component.\n  \\param pCompHealthCheck Key used to fetch healthcheck parameters\n  for this component. Not used.\n  \\param invocationType Indicates whether the AMF should initiate\n  the healthcheck or the component itself performs the healthcheck.\n  \\param recommondedRecovery Recommended recovery to be performed by\n  the AMF if the component fails a healthcheck.\n\n  \\retval CL_OK The API executed successfully.\n  \\retval CL_ERR_NULL_POINTER On passing a NULL pointer.\n  \\retval CL_ERR_INVALID_PARAMETER One of the parameters are invalid.\n  \\retval CL_ERR_INVALID_HANDLE The passed CPM handle is invalid.\n\n  \\par Description:\n  This API starts health check of the component \\e pCompName. The \\e\n  invocationType specifies whether this is an AMF invoked\n  healthcheck or a component invoked healthcheck. If the \\e\n  invocationType is CL_AMS_COMP_HEALTHCHECK_AMF_INVOKED, the\n  appHealthCheck() callback function must be supplied when calling\n  clCpmClientInitialize().\n\n  \\note\n  This API is equivalent to \\e saAmfHealthCheckStart.\n\n  \\par Library Files:\n  ClAmfClient\n\n  \\sa clCpmClientInitialize(), clCpmHealthcheckConfirm(),\n      clCpmHealthcheckStop()\n"]
    pub fn clCpmHealthcheckStart(
        cpmHandle: ClCpmHandleT,
        pCompName: *const ClNameT,
        pCompHealthCheck: *const ClAmsCompHealthcheckKeyT,
        invocationType: ClAmsCompHealthcheckInvocationT,
        recommondedRecovery: ClAmsRecoveryT,
    ) -> ClRcT;
}
extern "C" {
    #[doc = "  \\brief Inform AMF the status of component invoked healthcheck.\n\n  \\par Header File:\n  clCpmApi.h\n\n  \\param cpmHandle Handle returned by \\e clCpmClientInitialize API.\n  \\param pCompName Name of the component.\n  \\param pCompHealthCheck Key used to fetch healthcheck parameters\n  for this component. Not used.\n  \\param healthCheckResult Result of the component invoked healthcheck.\n\n  \\retval CL_OK The API executed successfully.\n  \\retval CL_ERR_NULL_POINTER On passing a NULL pointer.\n  \\retval CL_ERR_INVALID_HANDLE The passed CPM handle is invalid.\n\n  \\par Description:\n  This API is used by the component to inform AMF that, it has\n  performed a healthcheck on component \\e pCompName and whether the\n  healthcheck was successful or not using \\e healthCheckResult,\n  which is the exit status of the healthcheck performed on the\n  component.\n\n  \\note\n  This API is equivalent to \\e saAmfHealthCheckConfirm.\n\n  \\par Library Files:\n  ClAmfClient\n\n  \\sa clCpmClientInitialize(), clCpmHealthcheckStart(),\n      clCpmHealthcheckStop()\n"]
    pub fn clCpmHealthcheckConfirm(
        cpmHandle: ClCpmHandleT,
        pCompName: *const ClNameT,
        pCompHealthCheck: *const ClAmsCompHealthcheckKeyT,
        healthCheckResult: ClRcT,
    ) -> ClRcT;
}
extern "C" {
    #[doc = "  \\brief Stops the component healthcheck.\n\n  \\par Header File:\n  clCpmApi.h\n\n  \\param cpmHandle handle returned by \\e clCpmClientInitialize API.\n  \\param pCompName Name of the component for which health-check needs to be\n  stopped.\n  \\param pCompHealthCheck Key used to fetch healthcheck parameters\n  for this component. Not used.\n\n  \\retval CL_OK The API executed successfully.\n  \\retval CL_ERR_NULL_POINTER On passing a NULL pointer.\n  \\retval CL_ERR_INVALID_HANDLE The passed CPM handle is invalid.\n\n  \\par Description:\n  This API is used to stop the healthcheck of the component \\e compName.\n\n  \\note\n  This API is equivalent to \\e saAmfComponentHealthCheckStop.\n\n  \\par Library Files:\n  ClAmfClient\n\n  \\sa clCpmClientInitialize(), clCpmComponentHealthCheckStart()\n"]
    pub fn clCpmHealthcheckStop(
        cpmHandle: ClCpmHandleT,
        pCompName: *const ClNameT,
        pCompHealthCheck: *const ClAmsCompHealthcheckKeyT,
    ) -> ClRcT;
}
extern "C" {
    #[doc = "  \\brief Track the protection group for the given CSI.\n\n  \\par Header File:\n  clCpmApi.h\n\n  \\param cpmHandle Handle returned by \\e clCpmClientInitialize API.\n  \\param pCsiName Pointer to the CSI for which protection group needs to\n  be tracked.\n  \\param trackFlags The kind of tracking that is requested, which is the\n  bitwise OR of one or more of the flags \\c CL_AMS_PG_TRACK_CURRENT,\n  \\c CL_AMS_PG_TRACK_CHANGES or \\c CL_AMS_PG_TRACK_CHANGES_ONLY.\n  \\param pNotificationBuffer pointer to a buffer of type\n  ClAmsPGNotificationT. This parameter is ignored if \\c\n  CL_AMS_PG_TRACK_CURRENT is not set in \\e trackFlags; otherwise, if\n  \\e notificationBuffer is not NULL, the buffer will contain\n  information about all components in the protection group when\n  clCpmProtectionGroupTrack() returns.\n\n  \\retval CL_OK The API executed successfully.\n  \\retval CL_ERR_NULL_POINTER On passing a NULL pointer.\n\n  \\par Description:\n  This API is used to request the framework to start tracking changes in the\n  protection group associated with the component service instance, identified\n  by \\e csiName, or changes of attributes of any component in the protection\n  group. These changes are notified via the invocation of the\n  \\e ClCpmProtectionGroupTrackCallbackT() callback function, which must have\n  been supplied when the process invoked the \\e clCpmClientInitialize call.\n\n  \\note\n  This API is equivalent to \\e saAmfProtectionGroupTrack, which makes a\n  synchronous call.\n\n  \\par Library Files:\n  ClAmfClient\n\n  \\sa clCpmClientInitialize(), clCpmProtectionGroupTrackStop()\n"]
    pub fn clCpmProtectionGroupTrack(
        cpmHandle: ClCpmHandleT,
        pCsiName: *mut ClNameT,
        trackFlags: ClUint8T,
        pNotificationBuffer: *mut ClAmsPGNotificationBufferT,
    ) -> ClRcT;
}
extern "C" {
    #[doc = "  \\brief Stop tracking the protection group for the given CSI.\n\n  \\par Header File:\n  clCpmApi.h\n\n  \\param cpmHandle Handle returned by \\e clCpmClientInitialize API.\n  \\param pCsiName Pointer to the CSI for which protection group needs to\n  be tracked.\n\n  \\retval CL_OK The API executed successfully.\n  \\retval CL_ERR_NULL_POINTER On passing a NULL pointer.\n\n  \\par Description:\n  The invoking process requests the Availability Management Framework to\n  stop tracking protection group changes for the component service instance\n  designated by \\e pCsiName.\n\n  \\note\n  This API is equivalent to \\e saAmfProtectionGroupTrackStop, which makes a\n  synchronous call.\n\n  \\par Library Files:\n  ClAmfClient\n\n  \\sa clCpmClientInitialize(), clCpmProtectionGroupTrack()\n"]
    pub fn clCpmProtectionGroupTrackStop(cpmHandle: ClCpmHandleT, pCsiName: *mut ClNameT) -> ClRcT;
}
extern "C" {
    #[doc = "  \\brief Returns the component ID of a component.\n\n  \\par Header File:\n  clCpmApi.h\n\n  \\param cpmHandle Handle returned by \\e clCpmClientInitialize API.\n  \\param pCompName Name of the component.\n  \\param pCompId (out) Unique Id of the component.\n\n  \\retval CL_OK The API executed successfully.\n  \\retval CL_ERR_NULL_POINTER On passing a NULL pointer.\n\n  \\par Description:\n  This API is used to return the component ID for a component identified\n  by \\e pCompName. This unique component ID is node internal and is not known\n  to outside entities. Each time a component is instantiated, a new component\n  ID is assigned to it.\n\n  \\note This is a synchronous API.\n\n  \\par Library Files:\n  ClAmfClient\n"]
    pub fn clCpmComponentIdGet(
        cpmHandle: ClCpmHandleT,
        pCompName: *mut ClNameT,
        pCompId: *mut ClUint32T,
    ) -> ClRcT;
}
extern "C" {
    #[doc = "  \\brief Returns the IOC address of a component.\n\n  \\par Header File:\n  clCpmApi.h\n\n  \\param nodeAddress Node IOC Address.\n  \\param pCompName Name of the component.\n  \\param pCompAddress IOC address of the component including port\n  information.\n\n  \\retval CL_OK The API executed successfully.\n  \\retval CL_ERR_NULL_POINTER On passing a NULL pointer.\n\n  \\par Description:\n  This API is used to return the IOC address of a component identified by\n  \\e pCompName. This represents the physical address of the node where the\n  CPM is running.\n\n  \\note This is a synchronous API.\n\n  \\par Library Files:\n  ClAmfClient\n\n  \\sa clCpmComponentStatusGet()\n"]
    pub fn clCpmComponentAddressGet(
        nodeAddress: ClIocNodeAddressT,
        pCompName: *mut ClNameT,
        pCompAddress: *mut ClIocAddressT,
    ) -> ClRcT;
}
extern "C" {
    #[doc = "  \\brief Returns the IOC address of a component.\n\n  \\par Header File:\n  clCpmApi.h\n\n  \\param nodeAddress Node IOC Address.\n  \\param pCompName Name of the component.\n  \\param pCompAddress IOC address of the component including port\n  information.\n\n  \\retval CL_OK The API executed successfully.\n  \\retval CL_ERR_NULL_POINTER On passing a NULL pointer.\n\n  \\par Description:\n  This API is used to return the IOC address of a component identified by\n  \\e pCompName. This represents the physical address of the node where the\n  CPM is running.\n\n  \\note This is a synchronous API.\n\n  \\par Library Files:\n  ClAmfClient\n\n  \\sa clCpmComponentStatusGet()\n"]
    pub fn clCpmComponentAddressGetFast(
        nodeAddress: ClIocNodeAddressT,
        pCompName: *mut ClNameT,
        pCompAddress: *mut ClIocAddressT,
    ) -> ClRcT;
}
extern "C" {
    #[doc = "  \\brief Returns the component presence and operational state.\n\n  \\par Header File:\n  clCpmApi.h\n\n  \\param pCompName Name of the component.\n  \\param pNodeName IOC address of the component.\n  \\param pPresenceState Presence state of the component.\n  \\param pOperationalState Operational state of the component.\n\n  \\retval CL_OK The API executed successfully.\n  \\retval CL_ERR_NULL_POINTER On passing a NULL pointer.\n\n  \\par Description:\n  This API is used to return the presence and operational state of a component\n  identified by \\e pCompName. The presence state of the component reflects the\n  component life cycle and the operational state of the component is used by\n  the AMF to determine whether a component is capable of taking component\n  service instance assignments.\n\n  \\note This is a synchronous API.\n\n  \\par Library Files:\n  ClAmfClient\n\n  \\sa clCpmComponentAddressGet()\n"]
    pub fn clCpmComponentStatusGet(
        pCompName: *mut ClNameT,
        pNodeName: *mut ClNameT,
        pPresenceState: *mut ClAmsPresenceStateT,
        pOperationalState: *mut ClAmsOperStateT,
    ) -> ClRcT;
}
extern "C" {
    #[doc = "  \\brief Returns the IOC address of the master.\n\n  \\par Header File:\n  clCpmApi.h\n\n  \\param pIocAddress (out) IOC address of the master.\n\n  \\retval CL_OK The API executed successfully.\n  \\retval CL_ERR_NULL_POINTER On passing a NULL pointer.\n\n  \\par Description:\n  This API is used to retrieve the IOC address of the master. The\n  address returned by this API represents the physical address of\n  the node where the CPM/G is running.\n\n  \\par Library Files:\n  ClAmfClient\n\n  \\sa clCpmIsMaster()\n"]
    pub fn clCpmMasterAddressGet(pIocAddress: *mut ClIocNodeAddressT) -> ClRcT;
}
extern "C" {
    pub fn clCpmMasterAddressGetExtended(
        pIocAddress: *mut ClIocNodeAddressT,
        numRetries: ClInt32T,
        pDelay: *mut ClTimerTimeOutT,
    ) -> ClRcT;
}
extern "C" {
    #[doc = "  \\brief Informs if the node is master of the cluster.\n\n  \\par Header File:\n  clCpmApi.h\n\n  \\par Parameters:\n  None\n\n  \\retval CL_TRUE The node is the master.\n  \\retval CL_FALSE The node is not the master.\n\n  \\par Description:\n  This API indicates if the node is master of the cluster. This API\n  can be used by the component to determine whether it is running on\n  the CPM master (CPM/G (global) or CPM/L (local)).\n\n  \\par Library Files:\n  ClAmfClient\n\n  \\sa clCpmMasterAddressGet()\n"]
    pub fn clCpmIsMaster() -> ClUint32T;
}
extern "C" {
    #[doc = "  \\brief Shuts down the node.\n\n  \\par Header File:\n  clCpmApi.h\n\n  \\param iocNodeAddress IOC address of the node.\n\n  \\retval CL_OK The API executed successfully.\n\n  \\par Description:\n  This API is used to shut down the node, which corresponds to the given IOC\n  Address. Shutting down the node terminates all the services  running\n  on that node.\n\n  \\note This is an asynchronous API.\n\n  \\par Library Files:\n  ClAmfClient\n"]
    pub fn clCpmNodeShutDown(iocNodeAddress: ClIocNodeAddressT) -> ClRcT;
}
extern "C" {
    #[doc = "  \\brief Restarts the node\n\n  \\par Header File:\n  clCpmApi.h\n\n  \\param iocNodeAddress IOC address of the node.\n  \\param graceful Specifies whether to restart the node gracefully\n\n  \\retval CL_OK The API executed successfully.\n\n  \\par Description:\n  This API is used to restart the node, which corresponds to the\n  given IOC Address. If graceful is non zero, then all the\n  application components are terminated gracefully running on the\n  node. If graceful is zero, applications are abruptly terminated,\n  either by killing the applications on the node or rebooting the\n  node. The node may or may not be restarted depending on the\n  environment variables ASP_NODE_RESTART, ASP_NODE_REBOOT_DISABLE\n  and ASP_RESTART_ASP.\n\n  This APIs behavior depends on the environment variables\n  ASP_NODE_RESTART, ASP_NODE_REBOOT_DISABLE and ASP_RESTART_ASP,\n  documented in the command line and environment variable reference\n  section of the SDK guide.\n\n  \\note This is an asynchronous API.\n\n  \\par Library Files:\n  ClAmfClient\n"]
    pub fn clCpmNodeRestart(iocNodeAddress: ClIocNodeAddressT, graceful: ClBoolT) -> ClRcT;
}
extern "C" {
    #[doc = "  \\brief Switch over the node.\n\n  \\par Header File:\n  clCpmApi.h\n\n  \\param iocNodeAddress IOC address of the node.\n\n  \\retval CL_OK The API executed successfully.\n\n  \\par Description:\n\n  This API is used to switch over the node, which corresponds to the\n  given IOC Address. All the application components running on the\n  node are switched over and terminated gracefully and the node is\n  shutdown. The node may or may not be restarted depending on the\n  environment variables ASP_NODE_RESTART, ASP_NODE_REBOOT_DISABLE\n  and ASP_RESTART_ASP.\n\n  This APIs behavior depends on the environment variables\n  ASP_NODE_RESTART, ASP_NODE_REBOOT_DISABLE and ASP_RESTART_ASP,\n  documented in the command line and environment variable reference\n  section of the SDK guide.\n\n  \\note This is an asynchronous API.\n\n  \\par Library Files:\n  ClAmfClient\n"]
    pub fn clCpmNodeSwitchover(iocNodeAddress: ClIocNodeAddressT) -> ClRcT;
}
extern "C" {
    pub fn clCpmMiddlewareRestart(
        iocNodeAddress: ClIocNodeAddressT,
        graceful: ClBoolT,
        nodeReset: ClBoolT,
    ) -> ClRcT;
}
extern "C" {
    #[doc = "  \\brief Returns the name of the local node.\n\n  \\par Header File:\n  clCpmApi.h\n\n  \\param nodeName Local node name.\n\n  \\retval CL_OK The API executed successfully.\n  \\retval CL_ERR_NULL_POINTER On passing the unallocated node Name.\n  \\retval CL_ERR_DOESNT_EXIST CPM library is not able to retrieve the\n  \\e nodeName.\n\n  \\par Description:\n  This API provides the local node Name, in the buffer provided by the user.\n  This API can be used by a component to determine the name of the node\n  on which it is running.\n\n  \\par Library Files:\n  ClAmfClient\n"]
    pub fn clCpmLocalNodeNameGet(nodeName: *mut ClNameT) -> ClRcT;
}
extern "C" {
    #[doc = "  \\brief Returns the status of any component in a system.\n\n  \\par Header File:\n  clCpmApi.h\n\n  \\param compAddr The physical address of a component, whose status is to be know.\n  \\param pStatus  The pointer to a variable to hold the status of the component.\n\n  \\retval CL_OK The API executed successfully.\n  \\retval CL_ERR_INVALID_PARAMETER If an invalid address is passed.\n  \\e nodeName.\n\n  \\par Description:\n  This API should be used to get the status of a component present on any\n  ASP-node in a system. The *pStatus will contain CL_STATUS_UP or\n  CL_STATUS_DOWN if the component is up or down respectively.\n\n  \\par Library Files:\n  ClAmfClient\n"]
    pub fn clCpmCompStatusGet(compAddr: ClIocAddressT, pStatus: *mut ClStatusT) -> ClRcT;
}
extern "C" {
    #[doc = "  \\brief Returns the status of any ASP node in a system.\n\n  \\par Header File:\n  clCpmApi.h\n\n  \\param compAddr The ASP node address, whose status is to be know.\n  \\param pStatus  The pointer to a variable to hold the status of the component.\n\n  \\retval CL_OK The API executed successfully.\n\n  \\par Description:\n  This API should be used to get the status of an ASP node\n  in a system. The *pStatus will contain CL_STATUS_UP if that particular ASP\n  node is up and CL_STATUS_DOWN if the node is down.\n\n  \\par Library Files:\n  ClAmfClient\n"]
    pub fn clCpmNodeStatusGet(nodeAddr: ClIocNodeAddressT, pStatus: *mut ClStatusT) -> ClRcT;
}
extern "C" {
    #[doc = "  \\brief This API installs the callback function when the node/component\n  arrival/departure events are to be intemated asynchronously.\n\n  \\par Header File:\n  clCpmApi.h\n\n  \\param compAddr The ASP component address, whose arrival/departure is of\n  importance. If the callback is for a node's arrival/departure then the\n  \\e compAddr.portId should be 0.\n  \\param pFunc The callback function pointer, which will get called on\n  arrival/departure event.\n  \\param pArg The argument which will be passed back in the callback.\n  \\param pHandle The pointer to a varible in which a handle will be\n  returned, which should used to unistall a function installed.\n\n  \\retval CL_OK The API executed successfully.\n  \\retval CL_ERR_NO_MEMORY If there is no memory to register the callback.\n\n  \\par Description:\n  This API should be used, when a node's or a component's arrival/departure event\n  is of importance and some action needs to be taken depending on the event\n  occured. This API will register the callback function and the callback\n  will be invoked when node/component arrival/departure event occurs.\n\n  \\par Library Files:\n  ClAmfClient\n"]
    pub fn clCpmNotificationCallbackInstall(
        compAddr: ClIocPhysicalAddressT,
        pFunc: ClCpmNotificationFuncT,
        pArg: ClPtrT,
        pHandle: *mut ClHandleT,
    ) -> ClRcT;
}
extern "C" {
    #[doc = "  \\brief The API uninstalls the callback, which would have been installed\n  through the \\e clCpmNotificationCallbackInstall API.\n\n  \\par Header File:\n  clCpmApi.h\n\n  \\param pHandle The handle for unistalling the callback, returned by\n  \\e clCpmNotificationCallbackInstall API.\n\n  \\retval CL_OK The API executed successfully.\n\n  \\par Description:\n  This API should be used, when the callback installed through\n  \\e clCpmNotificationCallbackInstall API, is to be uninstalled. The handle\n  passed to this API should be the correct one as this API doent do any\n  kind of verification on the handle.\n\n  \\par Library Files:\n  ClAmfClient\n"]
    pub fn clCpmNotificationCallbackUninstall(pHandle: *mut ClHandleT) -> ClRcT;
}
extern "C" {
    #[doc = "  \\brief The API gets the comp CSI List from the component CSI cache\n  maintained per-process.\n\n  \\par Header File:\n  clCpmApi.h\n\n  \\param pCompName Name of the component to query to obtain the CSI list\n  \\param pCSIRef   List of CSI references cached for the component\n  is returned through this variable\n\n  \\retval CL_OK The API executed successfully.\n  \\retval CL_ERR_INVALID_PARAMETER The API was invoked with invalid arguments\n\n  \\par Description:\n  This API should be used to obtain the cached CSI list for a component\n  The csi list is returned through the pCSIRef argument. The API returns\n  the cached haState and the csiDescriptor for the component for each CSI.\n\n  \\par Library Files:\n  ClAmfClient\n"]
    pub fn clCpmCompCSIList(pCompName: *const ClNameT, pCSIRef: *mut ClCpmCompCSIRefT) -> ClRcT;
}
extern "C" {
    #[doc = "  \\brief The API returns whether this node is system controller or not.\n\n  \\par Header File:\n  clCpmApi.h\n\n  \\retval CL_YES If the current node is system controller.\n  \\retval CL_NO If the current node is not system controller\n  (i.e. it is a payload node) or the application calling this API is\n  running out side of AMF for e.g. using safplus_run script.\n\n  \\par Description:\n  This API should be used by the application to check if the node on\n  which it is running is system controller.\n\n  \\par Library Files:\n  ClAmfClient\n"]
    pub fn clCpmIsSC() -> ClBoolT;
}
extern "C" {
    #[doc = "  \\brief The API returns component specific information.\n\n  \\par Header File:\n  clCpmApi.h\n\n  \\retval CL_OK The API executed successfully.\n  \\retval CL_ERR_INVALID_PARAMETER The API was invoked with invalid arguments.\n  \\retval CL_ERR_NO_MEMORY Not enough memory to complete the request.\n\n  \\par Description:\n  This API should be used by the application to fetch any component specific\n  information maintained by CPM.\n\n  \\note This API allocates a array of pointers as well as memory for\n  each of the components argument for \\arg args. It is the\n  responsibility of the user to free the memory allocated by this\n  API.\n\n  \\par Library Files:\n  ClAmfClient\n"]
    pub fn clCpmCompInfoGet(
        compName: *const ClNameT,
        nodeAddress: ClIocNodeAddressT,
        compInfo: *mut ClCpmCompSpecInfoT,
    ) -> ClRcT;
}
extern "C" {
    #[doc = " This component's handle"]
    pub static mut clCpmHandle: ClCpmHandleT;
}
