pub use crate::clBindings::clCommon::*;
pub use crate::clBindings::clCommonErrors::*;
pub use crate::clBindings::clOsalApi::*;
pub use crate::clBindings::clHeapApi::*;
pub use crate::clBindings::clQueueApi::*;
pub use crate::clBindings::clIocApi::*;
pub use crate::clBindings::clIocManagementApi::*;
pub use crate::clBindings::clRmdApi::*;
pub use crate::clBindings::clCntApi::*;
pub use crate::clBindings::clVersion::*;
pub use crate::clBindings::clEoConfigApi::*;
pub use crate::clBindings::clEoErrors::*;
pub use crate::clBindings::clRadixTree::*;
/* automatically generated by rust-bindgen 0.66.1 */

pub const CL_EO_MAX_NO_FUNC: u32 = 64;
pub const CL_EO_CLIENT_BIT_SHIFT: u32 = 6;
pub const CL_EO_FN_MASK: u32 = 63;
pub const CL_EO_SERVER_COOKIE_BIT_SIZE: u32 = 8;
pub const CL_EO_EVENT_CHANNEL_NAME: &[u8; 25] = b"CL_EO_EVENT_CHANNEL_NAME\0";
pub const _TASK_SND_MASK: u32 = 1;
pub const _TASK_RCV_MASK: u32 = 2;
extern "C" {
    #[doc = " Name of the node.  Loaded from the same-named environment variable."]
    pub static mut ASP_NODENAME: [ClCharT; 256usize];
}
extern "C" {
    #[doc = " Name of the component.  Loaded from the same-named environment variable."]
    pub static mut ASP_COMPNAME: [ClCharT; 256usize];
}
extern "C" {
    #[doc = " Address of the node.  Loaded from the same-named environment variable."]
    pub static mut ASP_NODEADDR: ClUint32T;
}
extern "C" {
    #[doc = " Working dir where programs are run. Loaded from the same-named environment variable."]
    pub static mut ASP_RUNDIR: [ClCharT; 256usize];
}
extern "C" {
    #[doc = " Dir where logs are stored. Loaded from the same-named environment variable."]
    pub static mut ASP_LOGDIR: [ClCharT; 256usize];
}
extern "C" {
    #[doc = " Dir where ASP binaries are located. Loaded from the same-named environment variable."]
    pub static mut ASP_BINDIR: [ClCharT; 256usize];
}
extern "C" {
    #[doc = " Dir where application binaries are located. Derived from ASP_BINDIR and argv[0].  Deprecated."]
    pub static mut CL_APP_BINDIR: [ClCharT; 256usize];
}
extern "C" {
    #[doc = " Dir where application binaries are located. Derived from ASP_BINDIR and argv[0]."]
    pub static mut ASP_APP_BINDIR: [ClCharT; 256usize];
}
extern "C" {
    #[doc = " Dir where xml config are located. Loaded from the same-named environment variable."]
    pub static mut ASP_CONFIG: [ClCharT; 256usize];
}
extern "C" {
    #[doc = " Dir where persistent db files are to be stored. Loaded from the same-named environment variable."]
    pub static mut ASP_DBDIR: [ClCharT; 256usize];
}
extern "C" {
    #[doc = " Variable to check if the current node is a system controller node.  Loaded from the same-named environment variable."]
    pub static mut SYSTEM_CONTROLLER: ClBoolT;
}
extern "C" {
    #[doc = " Variable to check if the current node is a SC capable node.  Loaded from the same-named environment variable."]
    pub static mut ASP_SC_PROMOTE: ClBoolT;
}
extern "C" {
    #[doc = " The IOC port assigned to this component."]
    pub static mut gEOIocPort: ClIocPortT;
}
#[doc = " Adds to the front of the list."]
pub const ClEOServiceInstallOrderT_CL_EO_ADD_TO_FRONT: ClEOServiceInstallOrderT = 0;
#[doc = " Adds to back of the list. It is used with \\e clEoServiceValidate."]
pub const ClEOServiceInstallOrderT_CL_EO_ADD_TO_BACK: ClEOServiceInstallOrderT = 1;
pub type ClEOServiceInstallOrderT = ::std::os::raw::c_uint;
#[doc = " The type of the EO data."]
pub type ClEoDataT = ClOsalTaskDataT;
#[doc = " EO argument type, this argument will always passed."]
pub type ClEoArgT = ClUint32T;
#[doc = " This is the service provided by Host EO."]
pub const ClEoClientIdT_CL_EO_NATIVE_COMPONENT_TABLE_ID: ClEoClientIdT = 0;
#[doc = " This value is native EO specific."]
pub const ClEoClientIdT_CL_EO_DEFAULT_SERVICE_TABLE_ID: ClEoClientIdT = 1;
#[doc = " This value is EO Manager specific."]
pub const ClEoClientIdT_CL_EO_EO_MGR_CLIENT_TABLE_ID: ClEoClientIdT = 2;
#[doc = " This value is COR specific."]
pub const ClEoClientIdT_CL_EO_COR_CLIENT_TABLE_ID: ClEoClientIdT = 3;
#[doc = " This value is Event Manager specific."]
pub const ClEoClientIdT_CL_EO_EVT_CLIENT_TABLE_ID: ClEoClientIdT = 4;
#[doc = " This value is CPM specific."]
pub const ClEoClientIdT_CL_CPM_MGR_CLIENT_TABLE_ID: ClEoClientIdT = 5;
#[doc = " This value is Alarm Manager specific."]
pub const ClEoClientIdT_CL_ALARM_CLIENT_TABLE_ID: ClEoClientIdT = 6;
#[doc = " This value is Alarm Manager specific."]
pub const ClEoClientIdT_CL_DEBUG_CLIENT_TABLE_ID: ClEoClientIdT = 7;
#[doc = " This value is Alarm Manager specific."]
pub const ClEoClientIdT_CL_TXN_CLIENT_TABLE_ID: ClEoClientIdT = 8;
#[doc = " This value is GMS specific."]
pub const ClEoClientIdT_CL_GMS_CLIENT_TABLE_ID: ClEoClientIdT = 9;
#[doc = " This value AMS Mgmt Server-specific"]
pub const ClEoClientIdT_CL_AMS_MGMT_SERVER_TABLE_ID: ClEoClientIdT = 10;
#[doc = " This value AMS Mgmt Client-specific"]
pub const ClEoClientIdT_CL_AMS_MGMT_CLIENT_TABLE_ID: ClEoClientIdT = 11;
#[doc = " This value is specific to Log Client"]
pub const ClEoClientIdT_CL_LOG_CLIENT_TABLE_ID: ClEoClientIdT = 12;
#[doc = " This value is specific to Ckpt Client"]
pub const ClEoClientIdT_CL_EO_CKPT_CLIENT_TABLE_ID: ClEoClientIdT = 13;
#[doc = " This value is specific to RMD Client"]
pub const ClEoClientIdT_CL_EO_RMD_CLIENT_TABLE_ID: ClEoClientIdT = 14;
#[doc = " This value is specific to AMS metric trigger client."]
pub const ClEoClientIdT_CL_AMS_ENTITY_TRIGGER_TABLE_ID: ClEoClientIdT = 15;
#[doc = " This value is specific to CPM mgmt. clients."]
pub const ClEoClientIdT_CL_CPM_MGMT_CLIENT_TABLE_ID: ClEoClientIdT = 16;
#[doc = " This value is specific to MSG clients."]
pub const ClEoClientIdT_CL_MSG_CLIENT_TABLE_ID: ClEoClientIdT = 17;
#[doc = " This value is specific to MSG clients & servers."]
pub const ClEoClientIdT_CL_MSG_CLIENT_SERVER_TABLE_ID: ClEoClientIdT = 18;
#[doc = " This value is specific to MSG clients & servers."]
pub const ClEoClientIdT_CL_AMS_MGMT_SERVER_TABLE2_ID: ClEoClientIdT = 19;
#[doc = " CLIENT IDs till this value are reserved by Clovis."]
pub const ClEoClientIdT_CL_EO_CLOVIS_RESERVED_CLIENTID_END: ClEoClientIdT = 20;
pub type ClEoClientIdT = ::std::os::raw::c_uint;
pub const ClEoServerIdT_CL_EO_NATIVE_COMPONENT_COOKIE_BASE: ClEoServerIdT = 0;
pub const ClEoServerIdT_CL_EO_EO_MGR_SERVER_COOKIE_ID: ClEoServerIdT = 512;
pub const ClEoServerIdT_CL_EO_COR_SERVER_COOKIE_ID: ClEoServerIdT = 768;
pub const ClEoServerIdT_CL_EO_EVT_EVENT_DELIVERY_COOKIE_ID: ClEoServerIdT = 1024;
pub const ClEoServerIdT_CL_EO_DEBUG_OBJECT_COOKIE_ID: ClEoServerIdT = 1792;
pub const ClEoServerIdT_CL_EO_RMD_CLIENT_COOKIE_ID: ClEoServerIdT = 3584;
pub type ClEoServerIdT = ::std::os::raw::c_uint;
#[doc = " \\brief RMD with PAYLOAD with REPLY function pointer.\n\n\n \\param data Given while invoking \\e clEoClientInstall.\n\n \\param inMsgHandle Received message over RMD.\n\n \\param outMsgHandle Reply message if any.\n\n \\par Description:\n This is the generic function prototype definition of all the RMD functions\n which get installed on the EO client object.  In other words, this callback\n implements the server-side of the RMD call...\n"]
pub type ClEoPayloadWithReplyCallbackT = ::std::option::Option<
    unsafe extern "C" fn(
        data: ClEoDataT,
        inMsgHandle: ClBufferHandleT,
        outMsgHandle: ClBufferHandleT,
    ) -> ClRcT,
>;
#[repr(C)]
pub struct ClEoPayloadWithReplyCallbackServer {
    pub fun: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ClEoDataT,
            arg2: ClBufferHandleT,
            arg3: ClBufferHandleT,
        ) -> ClRcT,
    >,
    pub funId: ClUint32T,
    pub version: ClUint32T,
}
#[test]
fn bindgen_test_layout_ClEoPayloadWithReplyCallbackServer() {
    const UNINIT: ::std::mem::MaybeUninit<ClEoPayloadWithReplyCallbackServer> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ClEoPayloadWithReplyCallbackServer>(),
        16usize,
        concat!("Size of: ", stringify!(ClEoPayloadWithReplyCallbackServer))
    );
    assert_eq!(
        ::std::mem::align_of::<ClEoPayloadWithReplyCallbackServer>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(ClEoPayloadWithReplyCallbackServer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fun) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ClEoPayloadWithReplyCallbackServer),
            "::",
            stringify!(fun)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).funId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ClEoPayloadWithReplyCallbackServer),
            "::",
            stringify!(funId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ClEoPayloadWithReplyCallbackServer),
            "::",
            stringify!(version)
        )
    );
}
pub type ClEoPayloadWithReplyCallbackServerT = ClEoPayloadWithReplyCallbackServer;
#[repr(C)]
pub struct ClEoPayloadWithReplyCallbackClient {
    pub funId: ClUint32T,
    pub version: ClUint32T,
}
#[test]
fn bindgen_test_layout_ClEoPayloadWithReplyCallbackClient() {
    const UNINIT: ::std::mem::MaybeUninit<ClEoPayloadWithReplyCallbackClient> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ClEoPayloadWithReplyCallbackClient>(),
        8usize,
        concat!("Size of: ", stringify!(ClEoPayloadWithReplyCallbackClient))
    );
    assert_eq!(
        ::std::mem::align_of::<ClEoPayloadWithReplyCallbackClient>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(ClEoPayloadWithReplyCallbackClient)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).funId) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ClEoPayloadWithReplyCallbackClient),
            "::",
            stringify!(funId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ClEoPayloadWithReplyCallbackClient),
            "::",
            stringify!(version)
        )
    );
}
pub type ClEoPayloadWithReplyCallbackClientT = ClEoPayloadWithReplyCallbackClient;
#[repr(C)]
pub struct ClEoPayloadWithReplyCallbackTableClient {
    pub clientID: ClUint32T,
    pub funTable: *mut ClEoPayloadWithReplyCallbackClientT,
    pub funTableSize: ClUint32T,
}
#[test]
fn bindgen_test_layout_ClEoPayloadWithReplyCallbackTableClient() {
    const UNINIT: ::std::mem::MaybeUninit<ClEoPayloadWithReplyCallbackTableClient> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ClEoPayloadWithReplyCallbackTableClient>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(ClEoPayloadWithReplyCallbackTableClient)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<ClEoPayloadWithReplyCallbackTableClient>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(ClEoPayloadWithReplyCallbackTableClient)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).clientID) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ClEoPayloadWithReplyCallbackTableClient),
            "::",
            stringify!(clientID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).funTable) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ClEoPayloadWithReplyCallbackTableClient),
            "::",
            stringify!(funTable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).funTableSize) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ClEoPayloadWithReplyCallbackTableClient),
            "::",
            stringify!(funTableSize)
        )
    );
}
pub type ClEoPayloadWithReplyCallbackTableClientT = ClEoPayloadWithReplyCallbackTableClient;
#[repr(C)]
pub struct ClEoPayloadWithReplyCallbackTableServer {
    pub clientID: ClUint32T,
    pub funTable: *mut ClEoPayloadWithReplyCallbackServerT,
    pub funTableSize: ClUint32T,
}
#[test]
fn bindgen_test_layout_ClEoPayloadWithReplyCallbackTableServer() {
    const UNINIT: ::std::mem::MaybeUninit<ClEoPayloadWithReplyCallbackTableServer> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ClEoPayloadWithReplyCallbackTableServer>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(ClEoPayloadWithReplyCallbackTableServer)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<ClEoPayloadWithReplyCallbackTableServer>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(ClEoPayloadWithReplyCallbackTableServer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).clientID) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ClEoPayloadWithReplyCallbackTableServer),
            "::",
            stringify!(clientID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).funTable) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ClEoPayloadWithReplyCallbackTableServer),
            "::",
            stringify!(funTable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).funTableSize) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ClEoPayloadWithReplyCallbackTableServer),
            "::",
            stringify!(funTableSize)
        )
    );
}
pub type ClEoPayloadWithReplyCallbackTableServerT = ClEoPayloadWithReplyCallbackTableServer;
#[doc = "  This structure is EO Service Object."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ClEoServiceObj {
    #[doc = " This is the client service function pointer."]
    pub func: ::std::option::Option<unsafe extern "C" fn()>,
    #[doc = " This is the pointer to the next service on the same serviceID."]
    pub pNextServObj: *mut ClEoServiceObj,
}
#[test]
fn bindgen_test_layout_ClEoServiceObj() {
    const UNINIT: ::std::mem::MaybeUninit<ClEoServiceObj> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ClEoServiceObj>(),
        16usize,
        concat!("Size of: ", stringify!(ClEoServiceObj))
    );
    assert_eq!(
        ::std::mem::align_of::<ClEoServiceObj>(),
        8usize,
        concat!("Alignment of ", stringify!(ClEoServiceObj))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).func) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ClEoServiceObj),
            "::",
            stringify!(func)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pNextServObj) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ClEoServiceObj),
            "::",
            stringify!(pNextServObj)
        )
    );
}
#[doc = "  This structure is EO Service Object."]
pub type ClEoServiceObjT = ClEoServiceObj;
#[doc = " This structure contains the pointer to the callback functions to be\n registered with the EO and the client specific data."]
#[repr(C)]
pub struct ClEoClientObjT {
    #[doc = " This is the pointer to EO APIs."]
    pub funcs: [ClEoServiceObjT; 64usize],
    #[doc = " This is the client-specific data."]
    pub data: ClEoDataT,
}
#[test]
fn bindgen_test_layout_ClEoClientObjT() {
    const UNINIT: ::std::mem::MaybeUninit<ClEoClientObjT> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ClEoClientObjT>(),
        1032usize,
        concat!("Size of: ", stringify!(ClEoClientObjT))
    );
    assert_eq!(
        ::std::mem::align_of::<ClEoClientObjT>(),
        8usize,
        concat!("Alignment of ", stringify!(ClEoClientObjT))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).funcs) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ClEoClientObjT),
            "::",
            stringify!(funcs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        1024usize,
        concat!(
            "Offset of field: ",
            stringify!(ClEoClientObjT),
            "::",
            stringify!(data)
        )
    );
}
#[repr(C)]
pub struct ClEoClientTableT {
    pub maxClients: ClUint32T,
    pub funTable: ClRadixTreeHandleT,
}
#[test]
fn bindgen_test_layout_ClEoClientTableT() {
    const UNINIT: ::std::mem::MaybeUninit<ClEoClientTableT> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ClEoClientTableT>(),
        16usize,
        concat!("Size of: ", stringify!(ClEoClientTableT))
    );
    assert_eq!(
        ::std::mem::align_of::<ClEoClientTableT>(),
        8usize,
        concat!("Alignment of ", stringify!(ClEoClientTableT))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxClients) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ClEoClientTableT),
            "::",
            stringify!(maxClients)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).funTable) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ClEoClientTableT),
            "::",
            stringify!(funTable)
        )
    );
}
#[repr(C)]
pub struct ClEoServerTableT {
    pub maxClients: ClUint32T,
    pub funTable: ClRadixTreeHandleT,
    pub data: ClEoDataT,
}
#[test]
fn bindgen_test_layout_ClEoServerTableT() {
    const UNINIT: ::std::mem::MaybeUninit<ClEoServerTableT> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ClEoServerTableT>(),
        24usize,
        concat!("Size of: ", stringify!(ClEoServerTableT))
    );
    assert_eq!(
        ::std::mem::align_of::<ClEoServerTableT>(),
        8usize,
        concat!("Alignment of ", stringify!(ClEoServerTableT))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxClients) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ClEoServerTableT),
            "::",
            stringify!(maxClients)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).funTable) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ClEoServerTableT),
            "::",
            stringify!(funTable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ClEoServerTableT),
            "::",
            stringify!(data)
        )
    );
}
#[doc = " The Execution Object abstracts the properties of a running OS thread or process."]
#[repr(C)]
pub struct ClEoExecutionObj {
    #[doc = " Execution object name."]
    pub name: [ClCharT; 32usize],
    #[doc = " The eoID must be unique on a blade."]
    pub eoID: ClEoIdT,
    #[doc = " This indicates the priority of the EO threads where RMD is executed."]
    pub pri: ClOsalThreadPriorityT,
    #[doc = " This indicates the EO State."]
    pub state: ClEoStateT,
    #[doc = " This is the receive loop thread State."]
    pub threadRunning: ClUint32T,
    #[doc = " This is the pointer to EO client APIs."]
    pub pClient: *mut ClEoClientObjT,
    #[doc = " This is the pointer to EO client tables."]
    pub pClientTable: *mut ClEoClientTableT,
    #[doc = " This is the pointer to EO server tables."]
    pub pServerTable: *mut ClEoServerTableT,
    #[doc = " This indicates the number of RMD threads spawned."]
    pub noOfThreads: ClUint32T,
    #[doc = " This is the handle of the container of EO specific data."]
    pub pEOPrivDataHdl: ClCntHandleT,
    #[doc = " This indicates the EO communication object."]
    pub commObj: ClIocCommPortHandleT,
    #[doc = " This is the RMD object associated with the EO."]
    pub rmdObj: ClRmdObjHandleT,
    #[doc = " This indicates whether \\e EOInit() has been called or not."]
    pub eoInitDone: ClUint32T,
    #[doc = " This is used to set State related flag and counter."]
    pub eoSetDoneCnt: ClUint32T,
    #[doc = " This is the TaskID information of receive loop. It is used to delete the EO."]
    pub eoTaskIdInfo: ClCntHandleT,
    pub refCnt: ClUint32T,
    #[doc = " This mutex is used to protect the Execution Object."]
    pub eoMutex: ClOsalMutexT,
    pub eoCond: ClOsalCondT,
    #[doc = " This indicates the requested IOC Communication Port."]
    pub eoPort: ClIocPortT,
    #[doc = " This indicates the whether application needs main thread or not."]
    pub appType: ClUint32T,
    #[doc = " This is the maximum number of EO clients."]
    pub maxNoClients: ClUint32T,
    #[doc = " This application function is called from Main during the initialization process."]
    pub clEoCreateCallout: ClEoAppCreateCallbackT,
    #[doc = " This application function is called when the EO gets terminated."]
    pub clEoDeleteCallout: ClEoAppDeleteCallbackT,
    #[doc = " This is application function is called when the EO is moved into suspended state."]
    pub clEoStateChgCallout: ClEoAppStateChgCallbackT,
    #[doc = " This is the application function that is called when EO healthcheck is\n performed by CPM"]
    pub clEoHealthCheckCallout: ClEoAppHealthCheckCallbackT,
}
#[test]
fn bindgen_test_layout_ClEoExecutionObj() {
    const UNINIT: ::std::mem::MaybeUninit<ClEoExecutionObj> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ClEoExecutionObj>(),
        280usize,
        concat!("Size of: ", stringify!(ClEoExecutionObj))
    );
    assert_eq!(
        ::std::mem::align_of::<ClEoExecutionObj>(),
        8usize,
        concat!("Alignment of ", stringify!(ClEoExecutionObj))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ClEoExecutionObj),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).eoID) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ClEoExecutionObj),
            "::",
            stringify!(eoID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pri) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ClEoExecutionObj),
            "::",
            stringify!(pri)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(ClEoExecutionObj),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).threadRunning) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ClEoExecutionObj),
            "::",
            stringify!(threadRunning)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pClient) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(ClEoExecutionObj),
            "::",
            stringify!(pClient)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pClientTable) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(ClEoExecutionObj),
            "::",
            stringify!(pClientTable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pServerTable) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(ClEoExecutionObj),
            "::",
            stringify!(pServerTable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).noOfThreads) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(ClEoExecutionObj),
            "::",
            stringify!(noOfThreads)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pEOPrivDataHdl) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(ClEoExecutionObj),
            "::",
            stringify!(pEOPrivDataHdl)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).commObj) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(ClEoExecutionObj),
            "::",
            stringify!(commObj)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rmdObj) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(ClEoExecutionObj),
            "::",
            stringify!(rmdObj)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).eoInitDone) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(ClEoExecutionObj),
            "::",
            stringify!(eoInitDone)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).eoSetDoneCnt) as usize - ptr as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(ClEoExecutionObj),
            "::",
            stringify!(eoSetDoneCnt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).eoTaskIdInfo) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(ClEoExecutionObj),
            "::",
            stringify!(eoTaskIdInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).refCnt) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(ClEoExecutionObj),
            "::",
            stringify!(refCnt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).eoMutex) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(ClEoExecutionObj),
            "::",
            stringify!(eoMutex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).eoCond) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(ClEoExecutionObj),
            "::",
            stringify!(eoCond)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).eoPort) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(ClEoExecutionObj),
            "::",
            stringify!(eoPort)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).appType) as usize - ptr as usize },
        236usize,
        concat!(
            "Offset of field: ",
            stringify!(ClEoExecutionObj),
            "::",
            stringify!(appType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxNoClients) as usize - ptr as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(ClEoExecutionObj),
            "::",
            stringify!(maxNoClients)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).clEoCreateCallout) as usize - ptr as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(ClEoExecutionObj),
            "::",
            stringify!(clEoCreateCallout)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).clEoDeleteCallout) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(ClEoExecutionObj),
            "::",
            stringify!(clEoDeleteCallout)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).clEoStateChgCallout) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(ClEoExecutionObj),
            "::",
            stringify!(clEoStateChgCallout)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).clEoHealthCheckCallout) as usize - ptr as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(ClEoExecutionObj),
            "::",
            stringify!(clEoHealthCheckCallout)
        )
    );
}
#[doc = " The Execution Object abstracts the properties of a running OS thread or process."]
pub type ClEoExecutionObjT = ClEoExecutionObj;
#[doc = " \\brief Function Callback definition for the \\e clEoWalk function.\n\n \\param func Function that implements the RMD.\n\n \\param eoArg Arguments that need to be passed.\n\n \\param inMsgHdl Request packet received including the protocol header.\n\n \\param outMsgHdl Data part of response of a protocol [PDU].\n\n \\par Description:\n As clEoWalk iterates through all RMD functions, it calls\n this callback for each one."]
pub type ClEoCallFuncCallbackT = ::std::option::Option<
    unsafe extern "C" fn(
        func: ClEoPayloadWithReplyCallbackT,
        eoArg: ClEoDataT,
        inMsgHdl: ClBufferHandleT,
        outMsgHdl: ClBufferHandleT,
    ) -> ClRcT,
>;
#[doc = " \\brief Callback to handle incoming messages marked with a particular protocol\n\n \\param pThis Handle of the EO object.\n\n \\param eoRecvMsg Handle of the received message.\n\n \\param priority  IOC message priority.\n\n \\param protoType Protocol type.  This is supplied so that 1 implementation can be used\n  to handle related protocols.\n\n \\param length Length in bytes of the message (\\e eoRecvMsg).\n\n \\param srcAddr IOC address of the sender.\n\n \\par Description:\n The EO contains a \"standard\" IOC server that listens on a well known port\n for messages.  The EO demultiplexes these messages by a protocol ID byte\n contained in the message and calls the appropriate registered handler for\n each message.  The handler function definitions must match this prototype.\n\n \\sa clEoProtoInstall\n"]
pub type ClEoProtoCallbackT = ::std::option::Option<
    unsafe extern "C" fn(
        pThis: *mut ClEoExecutionObjT,
        eoRecvMsg: ClBufferHandleT,
        priority: ClUint8T,
        protoType: ClUint8T,
        length: ClUint32T,
        srcAddr: ClIocPhysicalAddressT,
    ) -> ClRcT,
>;
#[doc = " This structure contains a list of the protocols registered with the EO."]
#[repr(C)]
pub struct ClEoProtoDefT {
    #[doc = " ID of the protocol being registered."]
    pub protoID: ClUint8T,
    #[doc = " Name of the protocol being registered."]
    pub name: [ClCharT; 256usize],
    #[doc = " Blocking receive function of the protocol."]
    pub func: ClEoProtoCallbackT,
    #[doc = " Non-blocking receive function of the protocol."]
    pub nonblockingHandler: ClEoProtoCallbackT,
    #[doc = " Flags controlling how this protocol is handled"]
    pub flags: ClUint32T,
}
#[test]
fn bindgen_test_layout_ClEoProtoDefT() {
    const UNINIT: ::std::mem::MaybeUninit<ClEoProtoDefT> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ClEoProtoDefT>(),
        288usize,
        concat!("Size of: ", stringify!(ClEoProtoDefT))
    );
    assert_eq!(
        ::std::mem::align_of::<ClEoProtoDefT>(),
        8usize,
        concat!("Alignment of ", stringify!(ClEoProtoDefT))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).protoID) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ClEoProtoDefT),
            "::",
            stringify!(protoID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(ClEoProtoDefT),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).func) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(ClEoProtoDefT),
            "::",
            stringify!(func)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nonblockingHandler) as usize - ptr as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(ClEoProtoDefT),
            "::",
            stringify!(nonblockingHandler)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(ClEoProtoDefT),
            "::",
            stringify!(flags)
        )
    );
}
extern "C" {
    pub static mut gAspFuncTableClient: [ClEoPayloadWithReplyCallbackTableClientT; 0usize];
}
extern "C" {
    pub fn clEoClientInstallTables(
        pThis: *mut ClEoExecutionObjT,
        table: *mut ClEoPayloadWithReplyCallbackTableServerT,
    ) -> ClRcT;
}
extern "C" {
    pub fn clEoClientInstallTablesWithCookie(
        pThis: *mut ClEoExecutionObjT,
        table: *mut ClEoPayloadWithReplyCallbackTableServerT,
        data: ClEoDataT,
    ) -> ClRcT;
}
extern "C" {
    pub fn clEoClientUninstallTables(
        pThis: *mut ClEoExecutionObjT,
        table: *mut ClEoPayloadWithReplyCallbackTableServerT,
    ) -> ClRcT;
}
extern "C" {
    pub fn clEoClientTableFilter(eoPort: ClIocPortT, clientID: ClUint32T) -> ClBoolT;
}
extern "C" {
    #[doc = "  NAME: clEoRefInc\n  This function increments the reference count of the execution object.\n  @param    remoteEoObj  execution object\n  @returns  CL_OK in all the cases."]
    pub fn clEoRefInc(eo: *mut ClEoExecutionObjT);
}
extern "C" {
    #[doc = "  NAME: clEoRefInc\n  This function increments the reference count of the execution object.\n  @param    remoteEoObj  execution object\n  @returns  CL_OK in all the cases."]
    pub fn clEoRefDec(eo: *mut ClEoExecutionObjT);
}
extern "C" {
    pub fn clEoClientTableRegister(
        clientTable: *mut ClEoPayloadWithReplyCallbackTableClientT,
        clientPort: ClIocPortT,
    ) -> ClRcT;
}
extern "C" {
    #[doc = " \\brief Install a protocol handler\n \\par Description\n Installing 2 different handlers on the same protocol will cause a debugging\n pause when in debug mode, and overwrite the older handler.\n Passing an invalid protocol id will cause a debugging pause, and then be\n installed.\n\n \\param def The protocol definiton -- this structure is copied so you may pass a temporary (stack) variable\n"]
    pub fn clEoProtoInstall(def: *mut ClEoProtoDefT);
}
extern "C" {
    #[doc = " \\brief Remove a protocol handler\n \\par Description\n It is not necessary to remove handlers before quitting so this function is\n actually unnecessary.\n\n \\param id The protocol id (the first byte in the message is the protocol identifier)."]
    pub fn clEoProtoUninstall(id: ClUint8T);
}
extern "C" {
    #[doc = " \\brief Switch from one handler to another\n \\par Description\n This function atomically switches handlers so you can be sure that no\n packets are lost.\n\n \\param def The protocol definiton -- this structure is copied so you may pass a temporary (stack) variable"]
    pub fn clEoProtoSwitch(def: *mut ClEoProtoDefT);
}
extern "C" {
    #[doc = "  \\brief Performs a walk.\n\n  \\par Header File:\n  clEoApi.h\n\n  \\par Library Files:\n  ClEo\n\n  \\param pThis Handle of the EO.\n  \\param func Function number to be executed.\n  \\param pFuncCallout Function that will perform the actual execution.\n  \\param inMsgHdl Request message received including protocol header.\n  \\param outMsgHdl (out) Data part of response of a protocol (PDU).\n\n  \\retval CL_OK The API executed successfully.\n  \\retval CL_ERR_NULL_POINTER On passing a NULL pointer.\n  \\retval CL_EO_ERR_FUNC_NOT_REGISTERED If function is not registered.\n  \\retval CL_EO_ERR_EO_SUSPENDED If EO is in suspended state.\n\n  \\par Description:\n  This API is used to perform a walk through the EO for a given RMD function number.\n  It calls \\e rmdInvoke for each of the callback functions registered with an EO for\n  that RMD function number.\n\n  \\sa clEoServiceValidate()\n"]
    pub fn clEoWalk(
        pThis: *mut ClEoExecutionObjT,
        func: ClUint32T,
        pFuncCallout: ClEoCallFuncCallbackT,
        inMsgHdl: ClBufferHandleT,
        outMsgHdl: ClBufferHandleT,
    ) -> ClRcT;
}
extern "C" {
    pub fn clEoWalkWithVersion(
        pThis: *mut ClEoExecutionObjT,
        func: ClUint32T,
        version: *mut ClVersionT,
        pFuncCallout: ClEoCallFuncCallbackT,
        inMsgHdl: ClBufferHandleT,
        outMsgHdl: ClBufferHandleT,
    ) -> ClRcT;
}
extern "C" {
    #[doc = "  \\brief Validates the function registration.\n\n  \\par Header File:\n  clEoApi.h\n\n  \\par Library Files:\n  ClEo\n\n  \\param pThis Handle of the EO.\n  \\param func Function to be invoked.\n\n  \\retval CL_OK The API executed successfully.\n  \\retval CL_EO_ERR_FUNC_NOT_REGISTERED If function is not registered.\n  \\retval CL_EO_ERR_EO_SUSPENDED If EO is in a suspended state.\n  \\retval CL_ERR_NULL_POINTER On passing a NULL pointer.\n\n  \\par Description:\n  This API is used to validate whether the function for which the request is\n  made is registered or not. This API can be used to check whether the service\n  provided by a particular EO is available or not before invoking \\e clEoWalk().\n\n  \\sa clEoWalk(), clEoServiceIndexGet()\n"]
    pub fn clEoServiceValidate(pThis: *mut ClEoExecutionObjT, func: ClUint32T) -> ClRcT;
}
extern "C" {
    #[doc = "  \\brief Installs the function table for a client.\n\n  \\par Header File:\n  clEoApi.h\n\n  \\par Library Files:\n  ClEo\n\n  \\param pThis Handle of the EO.\n  \\param clientId Id of the Client.\n  \\param pFuncs Pointer to the function table.\n  \\param data Client specific data.\n  \\param nFuncs Number of functions passed that are being installed.\n\n  \\retval CL_OK The API executed successfully.\n  \\retval CL_ERR_NULL_POINTER On passing a NULL pointer.\n  \\retval CL_EO_NO_MEMORY On memory allocation failure.\n  \\retval CL_EO_CL_INVALID_CLIENTID On passing invalid clientId.\n  \\retval CL_EO_CL_INVALID_SERVICEID On passing invalid serviceId.\n\n  \\par Description:\n  This API is called by the client to install its function table\n  with the EO. By calling this API the client is exporting all the\n  APIs which it provides to the users, which the users can invoke\n  through RMD calls.\n\n  \\sa clEoClientUninstall()\n"]
    pub fn clEoClientInstall(
        pThis: *mut ClEoExecutionObjT,
        clientId: ClUint32T,
        pFuncs: *mut ClEoPayloadWithReplyCallbackT,
        data: ClEoDataT,
        nFuncs: ClUint32T,
    ) -> ClRcT;
}
extern "C" {
    pub fn clEoClientInstallTable(
        pThis: *mut ClEoExecutionObjT,
        clientId: ClUint32T,
        data: ClEoDataT,
        pFuncs: *mut ClEoPayloadWithReplyCallbackServerT,
        nFuncs: ClUint32T,
    ) -> ClRcT;
}
extern "C" {
    #[doc = "  \\brief Uninstalls the function table for client.\n\n  \\par Header File:\n  clEoApi.h\n\n  \\par Library Files:\n  ClEo\n\n  \\param pThis Handle of the EO.\n  \\param clientId Id of the client.\n\n  \\retval CL_OK The API executed successfully.\n  \\retval CL_ERR_NULL_POINTER On passing a NULL pointer.\n  \\retval CL_EO_ERR_INVALID_CLIENTID On passing invalid clientId.\n\n  \\par Description:\n  This API is called by the client to uninstall its function table\n  with the EO. After calling this API the functions which were previously\n  exported by this client using \\e clEoClientInstall() can no longer be\n  invoked as the RMD calls.\n\n  \\sa clEoClientInstall()\n"]
    pub fn clEoClientUninstall(pThis: *mut ClEoExecutionObjT, clientId: ClUint32T) -> ClRcT;
}
extern "C" {
    pub fn clEoClientUninstallTable(
        pThis: *mut ClEoExecutionObjT,
        clientID: ClUint32T,
        pfunTable: *mut ClEoPayloadWithReplyCallbackServerT,
        nentries: ClUint32T,
    ) -> ClRcT;
}
extern "C" {
    #[doc = "  \\brief Stores the client specific data.\n\n  \\par Header File:\n  clEoApi.h\n\n  \\par Library Files:\n  ClEo\n\n  \\param pThis Handle of the EO.\n  \\param clientId Id of the client.\n  \\param data Client specific data.\n\n  \\retval CL_OK The API executed successfully.\n  \\retval CL_ERR_NULL_POINTER On passing a NULL pointer.\n  \\retval CL_EO_ERR_INVALID_CLIENTID On passing invalid clientId.\n\n  \\par Description:\n  This API is used to store the client-specific data.\n\n  \\sa clEoClientDataGet()\n"]
    pub fn clEoClientDataSet(
        pThis: *mut ClEoExecutionObjT,
        clientId: ClUint32T,
        data: ClEoDataT,
    ) -> ClRcT;
}
extern "C" {
    #[doc = "  \\brief Returns the client specific data.\n\n  \\par Header File:\n  clEoApi.h\n\n  \\par Library Files:\n  ClEo\n\n  \\param pThis Handle of the EO.\n  \\param clientId Id of the client.\n  \\param pData (out) Client specific data.\n\n  \\retval CL_OK The API executed successfully.\n  \\retval CL_ERR_NULL_POINTER On passing a NULL pointer.\n  \\retval CL_EO_ERR_INVALID_CLIENTID On passing invalid clientId.\n\n  \\par Description:\n  This API is used to retrieve the client specific data.\n\n  \\sa clEoClientDataSet()\n"]
    pub fn clEoClientDataGet(
        pThis: *mut ClEoExecutionObjT,
        clientId: ClUint32T,
        pData: *mut ClEoDataT,
    ) -> ClRcT;
}
extern "C" {
    #[doc = "  \\brief Installs a particular client function.\n\n  \\par Header File:\n  clEoApi.h\n\n  \\par Library Files:\n  ClEo\n\n  \\param pThis Handle of the EO.\n  \\param pFunction Function pointer to be installed.\n  \\param iFuncNum Function number.\n  \\param order Order as whether to add to the front or the back of the table.\n\n  \\retval CL_OK The API executed successfully.\n  \\retval CL_ERR_NULL_POINTER On passing a NULL pointer.\n  \\retval CL_ERR_NO_MEMORY On memory allocation failure.\n  \\retval CL_EO_CL_INVALID_SERVICEID On passing invalid serviceId.\n  \\retval CL_ERR_INVALID_PARAMETER On passing invalid parameters.\n\n  \\par Description:\n  This API is used to install a particular client function, identified by\n  iFuncNum in the EO function table. By calling this API, the application is\n  registering a service which it wishes to provide to other components.\n  It can install the new service either to the front or back of the table by\n  specifying the \\e order.\n\n  \\sa clEoServiceUninstall()\n"]
    pub fn clEoServiceInstall(
        pThis: *mut ClEoExecutionObjT,
        pFunction: ClEoPayloadWithReplyCallbackT,
        iFuncNum: ClUint32T,
        order: ClEOServiceInstallOrderT,
    ) -> ClRcT;
}
extern "C" {
    #[doc = "  \\brief Uninstalls a particular client function.\n\n  \\par Header File:\n  clEoApi.h\n\n  \\par Library Files:\n  ClEo\n\n  \\param pThis Handle of the EO.\n  \\param pFunction Function pointer to be uninstalled.\n  \\param iFuncNum Function number.\n\n  \\retval CL_OK The API executed successfully.\n  \\retval CL_ERR_NULL_POINTER On passing a NULL pointer.\n  \\retval CL_EO_FUNC_NOT_REGISTERED On unregistering a function which is not registered.\n  \\retval CL_EO_CL_INVALID_SERVICEID On passing invalid servide ID.\n  \\retval CL_ERR_INVALID_PARAMETER On passing invalid parameter.\n\n  \\par Description:\n  This API is used to uninstall a particular client function from the EO\n  function table. After calling this API, the service \\e pFunction is no longer\n  available for invoking as an RMD call.\n\n  \\sa clEoServiceInstall()\n"]
    pub fn clEoServiceUninstall(
        pThis: *mut ClEoExecutionObjT,
        pFunction: ClEoPayloadWithReplyCallbackT,
        iFuncNum: ClUint32T,
    ) -> ClRcT;
}
extern "C" {
    #[doc = "  \\brief Stores data in EO specific data area.\n\n  \\par Header File:\n  clEoApi.h\n\n  \\par Library Files:\n  ClEo\n\n  \\param pThis Handle of the EO.\n  \\param type User specified key.\n  \\param pData EO specific data.\n\n  \\par Return values:\n  \\e CL_ERR_NULL_POINTER: On passing a NULL pointer.\\n\n  Also returns the result of \\e clCntNodeAdd.\n\n  \\par Description:\n  This API is used to store data in EO specific data area.\n  For a unique key, there can be only one node.\n\n  \\sa clEoPrivateDataGet()\n"]
    pub fn clEoPrivateDataSet(
        pThis: *mut ClEoExecutionObjT,
        type_: ClUint32T,
        pData: *mut ::std::os::raw::c_void,
    ) -> ClRcT;
}
extern "C" {
    #[doc = "  \\brief Returns data from EO specific data area.\n\n  \\par Header File:\n  clEoApi.h\n\n  \\par Library Files:\n  ClEo\n\n  \\param pThis Handle of the EO.\n  \\param type User specified key.\n  \\param data (out) EO specific data.\n\n  \\par Return values:\n  \\e CL_ERR_NULL_POINTER: On passing a NULL pointer.\\n\n  Also returns the result of \\e clCntNodeUserDataGet.\n\n  \\par Description:\n  This API is used to retrieve data stored in EO specific data area.\n\n  \\sa clEoMyEoIocPortSet()\n"]
    pub fn clEoPrivateDataGet(
        pThis: *mut ClEoExecutionObjT,
        type_: ClUint32T,
        data: *mut *mut ::std::os::raw::c_void,
    ) -> ClRcT;
}
extern "C" {
    #[doc = "  \\brief Sets the EO thread \\e iocPort.\n\n  \\par Header File:\n  clEoApi.h\n\n  \\par Library Files:\n  ClEo\n\n  \\param iocPort Carries the value to be set.\n\n  \\retval CL_OK The API executed successfully.\n\n  \\par Description:\n  This API is used to set the eoId.\n\n  \\sa clEoMyEoIocPortGet()\n"]
    pub fn clEoMyEoIocPortSet(iocPort: ClIocPortT) -> ClRcT;
}
extern "C" {
    #[doc = "  \\brief Returns EO IocPort from task specific area.\n\n  \\par Header File:\n  clEoApi.h\n\n  \\par Library Files:\n  ClEo\n\n  \\param pIocPort (out) Carries the value to be retrieved.\n\n  \\retval CL_OK The API executed successfully.\n  \\retval CL_ERR_INVALID_STATE If state is invalid.\n  \\retval CL_ERR_NULL_POINTER On passing a NULL pointer.\n\n  \\par Description:\n  This API is used to retrieve the EO IocPort stored in the task specific area.\n\n  \\sa clEoMyEoIocPortSet()\n"]
    pub fn clEoMyEoIocPortGet(pIocPort: *mut ClIocPortT) -> ClRcT;
}
extern "C" {
    #[doc = "  \\brief Stores EO Object in task specific area.\n\n  \\par Header File:\n  clEoApi.h\n\n  \\par Library Files:\n  ClEo\n\n  \\param pEoObj Contains \\e ClEoExecutionObjT* to be stored.\n\n  \\retval CL_OK The API executed successfully.\n\n  \\par Description:\n  This API is used to store the EO Object in task specific area.\n\n  \\sa clEoMyEoObjectGet()\n"]
    pub fn clEoMyEoObjectSet(eoObj: *mut ClEoExecutionObjT) -> ClRcT;
}
extern "C" {
    #[doc = "  \\brief Returns EO Object from task specific area.\n\n  \\par Header File:\n  clEoApi.h\n\n  \\par Library Files:\n  ClEo\n\n  \\param pEOObj (out) Carries the value to be retrieved.\n\n  \\retval CL_OK The API executed successfully.\n  \\retval CL_ERR_INVALID_STATE If state is invalid.\n\n  \\par Description:\n  This API is used to retrieve the EO Object stored in the task specific area.\n\n  \\sa clEoMyEoObjectSet()\n"]
    pub fn clEoMyEoObjectGet(pEOObj: *mut *mut ClEoExecutionObjT) -> ClRcT;
}
extern "C" {
    #[doc = "  \\brief Starts receiving messages for a thread.\n\n  \\par Header File:\n  clEoApi.h\n\n  \\par Library Files:\n  ClEo\n\n  \\param pThis Handle of the EO.\n\n  \\par Return values:\n  None\n\n  \\par Description:\n  This API is used to start receiving the message for this thread.\n  After calling this API the EO starts dequeuing the IOC messages\n  whenever they are received and handle them to RMD for processing.\n"]
    pub fn clEoReceiveStart(pThis: *mut ClEoExecutionObjT) -> ClRcT;
}
pub const ClEoCrashReasonT_CL_EO_CRASH_DEADLOCK: ClEoCrashReasonT = 0;
pub const ClEoCrashReasonT_CL_EO_CRASH_HUNG_SYSCALL: ClEoCrashReasonT = 1;
pub type ClEoCrashReasonT = ::std::os::raw::c_uint;
#[repr(C)]
pub struct ClEoCrashNotificationT {
    pub reason: ClEoCrashReasonT,
    pub pid: pid_t,
    pub tid: ClOsalTaskIdT,
    pub interval: ClTimeT,
    pub compName: *const ClCharT,
}
#[test]
fn bindgen_test_layout_ClEoCrashNotificationT() {
    const UNINIT: ::std::mem::MaybeUninit<ClEoCrashNotificationT> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ClEoCrashNotificationT>(),
        32usize,
        concat!("Size of: ", stringify!(ClEoCrashNotificationT))
    );
    assert_eq!(
        ::std::mem::align_of::<ClEoCrashNotificationT>(),
        8usize,
        concat!("Alignment of ", stringify!(ClEoCrashNotificationT))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reason) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ClEoCrashNotificationT),
            "::",
            stringify!(reason)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pid) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ClEoCrashNotificationT),
            "::",
            stringify!(pid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tid) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ClEoCrashNotificationT),
            "::",
            stringify!(tid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).interval) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ClEoCrashNotificationT),
            "::",
            stringify!(interval)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).compName) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ClEoCrashNotificationT),
            "::",
            stringify!(compName)
        )
    );
}
pub type ClEoCrashDeadlockT = ClEoCrashNotificationT;
#[repr(C)]
pub struct ClEoCrashHungSyscall {
    pub crash: ClEoCrashNotificationT,
    pub mask: ClUint32T,
}
#[test]
fn bindgen_test_layout_ClEoCrashHungSyscall() {
    const UNINIT: ::std::mem::MaybeUninit<ClEoCrashHungSyscall> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ClEoCrashHungSyscall>(),
        40usize,
        concat!("Size of: ", stringify!(ClEoCrashHungSyscall))
    );
    assert_eq!(
        ::std::mem::align_of::<ClEoCrashHungSyscall>(),
        8usize,
        concat!("Alignment of ", stringify!(ClEoCrashHungSyscall))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).crash) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ClEoCrashHungSyscall),
            "::",
            stringify!(crash)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mask) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ClEoCrashHungSyscall),
            "::",
            stringify!(mask)
        )
    );
}
pub type ClEoCrashHungSyscallT = ClEoCrashHungSyscall;
pub type ClEoCrashNotificationCallbackT =
    ::std::option::Option<unsafe extern "C" fn(crash: *const ClEoCrashNotificationT)>;
extern "C" {
    pub fn clEoCrashNotificationRegister(callback: ClEoCrashNotificationCallbackT) -> ClRcT;
}
