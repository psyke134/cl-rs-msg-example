pub use crate::clBindings::clBufferApi::*;
pub use crate::clBindings::clIocApi::*;
pub use crate::clBindings::clRmdErrors::*;
/* automatically generated by rust-bindgen 0.66.1 */

pub const CL_RMD_CALL_ASYNC: u32 = 1;
pub const CL_RMD_CALL_NEED_REPLY: u32 = 2;
pub const CL_RMD_CALL_ATMOST_ONCE: u32 = 4;
pub const CL_RMD_CALL_DO_NOT_OPTIMIZE: u32 = 8;
pub const CL_RMD_CALL_NON_PERSISTENT: u32 = 16;
pub const CL_RMD_CALL_IN_SESSION: u32 = 32;
pub const CL_RMD_HEADER_VERSION: u32 = 1;
pub const CL_RMD_DEFAULT_TIMEOUT: u32 = 10000;
pub const CL_RMD_DEFAULT_RETRIES: u32 = 5;
pub const CL_RMD_DEFAULT_TRANSPORT_HANDLE: u32 = 0;
pub const CL_RMD_TIMEOUT_FOREVER: i32 = -1;
#[doc = " \\brief Callback function pointer for the async RMD call.\n\n \\param retCode The return code of the remote function or RMD return code.\n \\param pCookie The value that you passed when you made the RMD call.\n \\param inMsgHdl Input passed when making the call.\n \\param outMsgHdl This is the output from the remote server.  You must \"free\" this pointer and ONLY this pointer.\n\n \\par Description:\n Callback function pointer for the asynchronous call. You need to free the output message only.\n\n \\sa clRmdWithMsg()"]
pub type ClRmdAsyncCallbackT = ::std::option::Option<
    unsafe extern "C" fn(
        retCode: ClRcT,
        pCookie: ClPtrT,
        inMsgHdl: ClBufferHandleT,
        outMsgHdl: ClBufferHandleT,
    ),
>;
pub type ClRmdObjHandleT = ClPtrT;
#[doc = " This is a structure to pass optional parameters."]
#[repr(C)]
pub struct ClRmdOptions {
    #[doc = " Timeout value per try in miliseconds. Also timeout must be the\n expected time of execution of the remote function. It should be in order\n of the minimum resolution timerlib provides. The values -1 or 0 means timeout forever.\n"]
    pub timeout: ClUint32T,
    #[doc = " Number of times you can retry after the first call in case of\n timeout. You can set the maximum number of retries."]
    pub retries: ClUint32T,
    #[doc = " Priority value for the call. It will be passed on to the IOC without modification."]
    pub priority: ClUint8T,
    #[doc = " The Transport Handle obtained via clIocBind() to make the RMD call via\n the specified transport."]
    pub transportHandle: ClIocToBindHandleT,
}
#[test]
fn bindgen_test_layout_ClRmdOptions() {
    const UNINIT: ::std::mem::MaybeUninit<ClRmdOptions> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ClRmdOptions>(),
        24usize,
        concat!("Size of: ", stringify!(ClRmdOptions))
    );
    assert_eq!(
        ::std::mem::align_of::<ClRmdOptions>(),
        8usize,
        concat!("Alignment of ", stringify!(ClRmdOptions))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timeout) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ClRmdOptions),
            "::",
            stringify!(timeout)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).retries) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ClRmdOptions),
            "::",
            stringify!(retries)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priority) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ClRmdOptions),
            "::",
            stringify!(priority)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).transportHandle) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ClRmdOptions),
            "::",
            stringify!(transportHandle)
        )
    );
}
#[doc = " This is a structure to pass optional parameters."]
pub type ClRmdOptionsT = ClRmdOptions;
#[doc = " This structure ClRmdAsyncOptionsT contains additional asynchronous call parameters. It is used to pass these parameters."]
#[repr(C)]
pub struct ClRmdAsyncOptions {
    #[doc = " User's cookie."]
    pub pCookie: ClPtrT,
    #[doc = " User's callback."]
    pub fpCallback: ClRmdAsyncCallbackT,
}
#[test]
fn bindgen_test_layout_ClRmdAsyncOptions() {
    const UNINIT: ::std::mem::MaybeUninit<ClRmdAsyncOptions> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ClRmdAsyncOptions>(),
        16usize,
        concat!("Size of: ", stringify!(ClRmdAsyncOptions))
    );
    assert_eq!(
        ::std::mem::align_of::<ClRmdAsyncOptions>(),
        8usize,
        concat!("Alignment of ", stringify!(ClRmdAsyncOptions))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pCookie) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ClRmdAsyncOptions),
            "::",
            stringify!(pCookie)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fpCallback) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ClRmdAsyncOptions),
            "::",
            stringify!(fpCallback)
        )
    );
}
#[doc = " This structure ClRmdAsyncOptionsT contains additional asynchronous call parameters. It is used to pass these parameters."]
pub type ClRmdAsyncOptionsT = ClRmdAsyncOptions;
extern "C" {
    #[doc = "  \\brief Invokes a Remote Function Call when the parameters are passed as messages.\n\n  \\par Header File:\n  clRmdApi.h\n\n  \\param remoteObjAddr Address of the destination Object.\n  \\param funcId Function Id to be executed.\n  \\param inMsgHdl Created and freed by the caller except when CL_RMD_CALL_NON_PERSISTENT\n  is set. In this case, RMD frees the message. NULL indicates no value is passed\n  to the remote end by you.\n  \\param outMsgHdl [out] Created and freed by the caller. If it is NULL and\n  \\e CL_RMD_CALL_NEED_REPLY flag is set, CL_RMD_RC(CL_ERR_INVALID_PARAM) will be returned.\n  \\param flags It informs RMD to decide the type of call. You must specify the flag to indicate\n  whether the call is Synchronous or Asynchronous, or whether Reply and Atmost Once semantics\n  are required or not.\n  \\param options Optional parameter that can be passed like- priority, timeout,\n  cookie, retries, and callback function. \\n\n  If it is NULL, default values be assumed.\n  \\param pAsyncOptions This is to be passed only if the call made is asynchronous. In this\n  parameter, optional parameters, like cookies and callback functions can be passed.\n\n  \\retval CL_OK The API executed successfully\n  \\par\n\n  \\retval CL_ERR_NO_MEMORY If system memory is no longer available\n  \\retval CL_ERR_TIMEOUT If reply is not received in specified time or an invalid IOC port id is passed\n  \\retval CL_ERR_NULL_PTR On passing a NULL pointer\n  \\retval CL_INVALID_PARAMETER On passing invalid parameters.\n  \\retval CL_ERR_NOT_INITIALIZED If RMD Library is not initialized.\n  \\retval CL_ERR_NOT_IMPLEMENTED If call type is not supported.\n  It also returns some OS defined error codes.\n  \\par\n  Error Codes listed above are generated by RMD, therefore the  return\n  value contains the RMD Component Identifier.\n\n  \\retval CL_EO_ERR_FUNC_NOT_REGISTERED If the requested function is not registered.\n  \\retval CL_EO_ERR_EO_SUSPENDED If the remote EO is in suspended state.\n  \\par\n  Error codes listed above are generated by EO, therefore the  return\n  value contains the EO Component Identifier.\n\n  \\retval CL_IOC_ERR_RECV_UNBLOCKED If the receiver is unblocked.\n  \\retval CL_IOC_ERR_HOST_UNREACHABLE If an invalid node address is passed.\n  \\retval CL_IOC_ERR_COMP_UNREACHABLE If an invalid commport address is passed.\n  \\retval CL_ERR_NOT_EXIST If an invalid logical address is passed.\n  \\par\n  Error codes listed above are generated by IOC, therefore the  return\n  value contains the IOC Component Identifier.\n\n  \\par Description:\n  This API is used to invoke a Remote Function Call. You must pass the the the following parameters.\n  \\arg destination address, that is, the remote ObjectId where the function is exposed,\n  \\arg the \\e functionId to invoke\n  \\arg input parameter in a message\n  \\arg output message to receive the reply\n  \\arg RMD specific flags\n  \\arg RMD options\n  \\arg RMD asynchronous calls options\n  \\par\n  While making an asynchronous call, you need to pass options like- priority, timeout value,\n  retries, cookie, and the callback function in a structure ClRmdAsyncOptions. But all the parameters\n  are not mandatory for each and every call. As in case of synchronous call, cookie and callback\n  function are not required to pass.\n  \\par\n  The remote function is identifed by the remote object address and the\n  Function ID.\n\n  \\par Library File:\n  libClRmd\n"]
    pub fn clRmdWithMsg(
        remoteObjAddr: ClIocAddressT,
        funcId: ClUint32T,
        inMsgHdl: ClBufferHandleT,
        outMsgHdl: ClBufferHandleT,
        flags: ClUint32T,
        pOptions: *mut ClRmdOptionsT,
        pAsyncOptions: *mut ClRmdAsyncOptionsT,
    ) -> ClRcT;
}
extern "C" {
    pub fn clRmdWithMsgVer(
        remoteObjAddr: ClIocAddressT,
        version: *mut ClVersionT,
        funcId: ClUint32T,
        inMsgHdl: ClBufferHandleT,
        outMsgHdl: ClBufferHandleT,
        flags: ClUint32T,
        pOptions: *mut ClRmdOptionsT,
        pAsyncOptions: *mut ClRmdAsyncOptionsT,
    ) -> ClRcT;
}
