pub use crate::clBindings::clCommon::*;
pub use crate::clBindings::clRuleApi::*;
/* automatically generated by rust-bindgen 0.66.1 */

#[doc = "  Data Types\n/\n/**\n Handle of the container. Container could be Linked list, Rbtree,\n Hashtable."]
pub type ClCntHandleT = ClPtrT;
#[doc = " Handle of the container Node."]
pub type ClCntNodeHandleT = ClPtrT;
#[doc = " Handle of the data."]
pub type ClCntDataHandleT = ClPtrT;
#[doc = " Handle of the argument which will be passed to callback functions"]
pub type ClCntArgHandleT = ClPtrT;
#[doc = " Handle of the key handle."]
pub type ClCntKeyHandleT = ClPtrT;
#[doc = " Container contains unique key. Duplicate entries are not allowed."]
pub const ClCntKeyTypeT_CL_CNT_UNIQUE_KEY: ClCntKeyTypeT = 1;
#[doc = " Container contains non unique key. Duplicate entries are allowed."]
pub const ClCntKeyTypeT_CL_CNT_NON_UNIQUE_KEY: ClCntKeyTypeT = 2;
#[doc = " Invalid container type."]
pub const ClCntKeyTypeT_CL_CNT_INVALID_KEY_TYPE: ClCntKeyTypeT = 3;
#[doc = " This enum describes type of the container."]
pub type ClCntKeyTypeT = ::std::os::raw::c_uint;
#[doc = "  \\brief Compares the two keys\n\n  \\par Header File:\n   clCntApi.h\n\n  \\param key1 (in) Users passed Key value.\n  \\param key2 (in) already stored Key value in the container.\n\n  \\retval 0 both the keys are equal\n  \\retval >0 key1 is larger than key2\n  \\retval <0 key2 is larger than key1\n\n  \\par Description:\n   This compare callback function does the comparison two keys and returns\n   the result back to the calling function. This will get called, whenever\n   the container does any key related operations.\n\n  \\par Library File:\n   ClCnt\n\n  \\sa clCntLlistCreate(), clCntHashtblCreate(), clCntRbtreeCreate(),\n      clCntNodeFind(), clCntDataForKeyGet()"]
pub type ClCntKeyCompareCallbackT = ::std::option::Option<
    unsafe extern "C" fn(key1: ClCntKeyHandleT, key2: ClCntKeyHandleT) -> ClInt32T,
>;
#[doc = "  \\brief Gets called While destroying the node of the container\n\n  \\par Header File:\n   clCntApi.h\n\n  \\param userKey (in) Key of the node is being destroyed.\n  \\param userData (in) Data of the node is being destroyed.\n\n  \\retval none\n\n  \\par Description:\n   This delete callback function will get invoked whenever a node is getting\n   deleted. The user can do their cleanup here.\n\n  \\par Library File:\n   ClCnt\n\n  \\sa clCntLlistCreate(), clCntHashtblCreate(), clCntRbtreeCreate(),\n      clCntNodeFind(), clCntDataForKeyGet()"]
pub type ClCntDeleteCallbackT = ::std::option::Option<
    unsafe extern "C" fn(userKey: ClCntKeyHandleT, userData: ClCntDataHandleT),
>;
#[doc = "  \\brief Gets called While doing hash table related operations.\n\n  \\par Header File:\n   clCntApi.h\n\n  \\param userKey (in) Key of the node is being accessed.\n\n  \\retval hashVal will be returned.\n\n  \\par Description:\n   Whenever any hash table related operations is being performed, this hash\n   callback will be invoked.\n\n  \\par Library File:\n   ClCnt\n\n  \\sa clCntLlistCreate(), clCntHashtblCreate(), clCntRbtreeCreate(),\n      clCntNodeFind(), clCntDataForKeyGet()"]
pub type ClCntHashCallbackT =
    ::std::option::Option<unsafe extern "C" fn(userKey: ClCntKeyHandleT) -> ClUint32T>;
#[doc = "  \\brief Gets called While performing container walk operation.\n\n  \\par Header File:\n   clCntApi.h\n\n  \\param userKey (in)  Key of the node is being accessed.\n  \\param userData (in) Data of the node is being accessed.\n  \\param userArg (in)  Userarg whatever they pass to clCntWalk function will\n  passed.\n  \\param length  (in)  Length of the arg data.\n\n  \\retval hashVal will be returned.\n\n  \\par Description:\n   Whenever a container Walk is performed on any container, this call back\n   will get invoked.\n\n  \\par Library File:\n   ClCnt\n\n  \\sa clCntLlistCreate(), clCntHashtblCreate(), clCntRbtreeCreate(),"]
pub type ClCntWalkCallbackT = ::std::option::Option<
    unsafe extern "C" fn(
        userKey: ClCntKeyHandleT,
        userData: ClCntDataHandleT,
        userArg: ClCntArgHandleT,
        dataLength: ClUint32T,
    ) -> ClRcT,
>;
extern "C" {
    #[doc = "  \\brief  Creates the container doubly linked list.\n\n  \\par Header File:\n   clCntApi.h\n\n  \\param fpKeyCompare (in) Pointer to the user's key compare function. It accepts two\n  parameters of type \\e ClCntKeyHandleT. This function returns the following values:\n  \\arg a negative value: If first key is lesser than the second key.\n  \\arg zero: If both the keys are equal.\n  \\arg a positive value: If first key is greater than second key. \\n\n  \\b Note: \\n\n  For the APIs where a traversal of the nodes in the container is involved, you must pass a key for\n  a node to be found. This callback function is called by the Container library for every node in\n  the container with the key passed by you and the key for that node. The implementation of this\n  function must compare the keys in the application specific way and return a value as documented below.\n\n  \\param fpUserDeleteCallback (in):  Pointer to the user's destroy callback function. This function is called\n  by the container library whenever either \\e clCntNodeDelete or \\e clCntNodeAllDelete API is called. The\n  delete callback function must free any memory allocated by the application for the node being deleted.\n\n  \\param  fpUserDestroyCallback (in) Pointer to the user's destroy callback function.\n  This function is called, whenever you invoke the destroy API. The\n  user-key and user-data of each node, which is being deleted is passed as first\n  and second argument to this callback.\n\n  \\param  containerKeyType (in)  Enum indicating whether the Container is of a unique\n  key type or a non-unique key type.\n\n  \\param  pContainerHandle (out) Pointer to the variable of type ClCntHandleT in\n  which the function returns a valid Container handle on successful creation of Container.\n\n  \\retval CL_OK The API executed successfully.\n  \\retval CL_ERR_NO_MEMORY On memory allocation failure.\n  \\retval CL_ERR_NULL_POINTER On passing NULL values for either\n  pContainerHandle or compare call back funtion.\n  \\retval CL_ERR_INVALID_PARAMETER On passing invalid values to container\n  type.\n\n  \\note\n  Return value is a combination of the component id and error code. As Return\n  values only the Error Codes are listed above.\n  Use \\c CL_GET_ERROR_CODE(RET_CODE) defined in clCommonErrors.h to retrieve the error code.\n\n  \\par Description:\n  This API is used to create a linked list of a Container. It populates all\n  the functions related with linked list.\n\n  \\par Library File:\n   ClCnt\n\n  \\sa none"]
    pub fn clCntLlistCreate(
        fpKeyCompare: ClCntKeyCompareCallbackT,
        fpUserDeleteCallback: ClCntDeleteCallbackT,
        fpUserDestroyCallback: ClCntDeleteCallbackT,
        containerKeyType: ClCntKeyTypeT,
        pContainerHandle: *mut ClCntHandleT,
    ) -> ClRcT;
}
extern "C" {
    #[doc = "  \\brief  Creates the container doubly linked list with lock variable.\n\n  \\par Header File:\n   clCntApi.h\n\n  \\param fpKeyCompare (in) Pointer to the user's key compare function. It accepts two\n  parameters of type \\e ClCntKeyHandleT. This function returns the following values:\n  \\arg a negative value: If first key is lesser than the second key.\n  \\arg zero: If both the keys are equal.\n  \\arg a positive value: If first key is greater than second key. \\n\n  \\b Note: \\n\n  For the APIs where a traversal of the nodes in the container is involved, you must pass a key for\n  a node to be found. This callback function is called by the Container library for every node in\n  the container with the key passed by you and the key for that node. The implementation of this\n  function must compare the keys in the application specific way and return a value as documented below.\n\n  \\param fpUserDeleteCallback (in):  Pointer to the user's destroy callback function. This function is called\n  by the container library whenever either \\e clCntNodeDelete or \\e clCntNodeAllDelete API is called. The\n  delete callback function must free any memory allocated by the application for the node being deleted.\n\n  \\param  fpUserDestroyCallback (in) Pointer to the user's destroy callback function.\n  This function is called, whenever you invoke the destroy API. The\n  user-key and user-data of each node, which is being deleted is passed as first\n  and second argument to this callback.\n\n  \\param  containerKeyType (in)  Enum indicating whether the Container is of a unique\n  key type or a non-unique key type.\n\n  \\param  pContainerHandle (out) Pointer to the variable of type ClCntHandleT in\n  which the function returns a valid Container handle on successful creation of Container.\n\n  \\retval CL_OK The API executed successfully.\n  \\retval CL_ERR_NO_MEMORY On memory allocation failure.\n  \\retval CL_ERR_NULL_POINTER On passing NULL values for either\n  pContainerHandle or compare call back funtion.\n  \\retval CL_ERR_INVALID_PARAMETER On passing invalid values to container\n  type.\n  \\retval CL_ERR_INVALID_PARAMETER On passing invalid values to container\n  type.\n  \\retval CL_ERR_MUTEX_ERROR On passing invalid values for creationg mutex.\n\n  \\note\n  Return value is a combination of the component id and error code. As Return\n  values only the Error Codes are listed above.\n  Use \\c CL_GET_ERROR_CODE(RET_CODE) defined in clCommonErrors.h to retrieve the error code.\n\n  \\par Description:\n  This API is used to create a linked list of a Container. It populates all\n  the functions related with linked list. It provides thread safe container\n  to the user. At a time only one anylement can be access the container\n  element.\n\n  \\par Library File:\n   ClCnt\n\n  \\sa none"]
    pub fn clCntThreadSafeLlistCreate(
        fpKeyCompare: ClCntKeyCompareCallbackT,
        fpUserDeleteCallback: ClCntDeleteCallbackT,
        fpUserDestroyCallback: ClCntDeleteCallbackT,
        containerKeyType: ClCntKeyTypeT,
        pContainerHandle: *mut ClCntHandleT,
    ) -> ClRcT;
}
extern "C" {
    pub fn clCntOrderedLlistCreate(
        fpKeyCompare: ClCntKeyCompareCallbackT,
        fpUserDeleteCallback: ClCntDeleteCallbackT,
        fpUserDestroyCallback: ClCntDeleteCallbackT,
        containerKeyType: ClCntKeyTypeT,
        pContainerHandle: *mut ClCntHandleT,
    ) -> ClRcT;
}
extern "C" {
    #[doc = "  \\brief  Creates the hash table.\n\n  \\par Header File:\n   clCntApi.h\n\n  \\param  numberOfBuckets  Number of buckets (table size) in the hash table.\n\n  \\param fpKeyCompare (in) Pointer to the user's key compare function. It accepts two\n  parameters of type \\e ClCntKeyHandleT. This function returns the following values:\n  \\arg a negative value: If first key is lesser than the second key.\n  \\arg zero: If both the keys are equal.\n  \\arg a positive value: If first key is greater than second key. \\n\n  \\b Note: \\n\n  For the APIs where a traversal of the nodes in the container is involved, you must pass a key for\n  a node to be found. This callback function is called by the Container library for every node in\n  the container with the key passed by you and the key for that node. The implementation of this\n  function must compare the keys in the application specific way and return a value as documented below.\n\n  \\param fpUserDeleteCallback (in)  Pointer to the user's destroy callback function. This function is called\n  by the container library whenever either \\e clCntNodeDelete or \\e clCntNodeAllDelete API is called. The\n  delete callback function must free any memory allocated by the application for the node being deleted.\n\n  \\param  fpUserDestroyCallback (in) Pointer to the user's destroy callback function.\n  This function is called, whenever you invoke the destroy API. The\n  user-key and user-data of each node, which is being deleted is passed as first\n  and second argument to this callback.\n\n  \\param  containerKeyType (in)  Enum indicating whether the Container is of a unique\n  key type or a non-unique key type.\n\n  \\param  pContainerHandle (out) Pointer to the variable of type ClCntHandleT in\n  which the function returns a valid Container handle on successful creation of Container.\n\n  \\retval CL_OK The API executed successfully.\n  \\retval CL_ERR_NO_MEMORY On memory allocation failure.\n  \\retval CL_ERR_NULL_POINTER On passing NULL values for either\n  pContainerHandle or compare call back funtion.\n  \\retval CL_ERR_INVALID_PARAMETER On passing invalid values to container\n  type.\n  \\retval CL_ERR_INVALID_PARAMETER On passing invalid values to container\n  type.\n  \\retval CL_ERR_MUTEX_ERROR On passing invalid values for creationg mutex.\n\n  \\note\n  Return value is a combination of the component id and error code. As Return\n  values only the Error Codes are listed above.\n  Use \\c CL_GET_ERROR_CODE(RET_CODE) defined in clCommonErrors.h to retrieve the error code.\n\n  \\par Description:\n  This API is used to create a hash table Container with Numbuckets. It populates all\n  the function pointers related with hash table.\n\n  \\par Library File:\n   ClCnt\n\n  \\sa none"]
    pub fn clCntHashtblCreate(
        numberOfBuckets: ClUint32T,
        fpKeyCompare: ClCntKeyCompareCallbackT,
        fpHashFunction: ClCntHashCallbackT,
        fpUserDeleteCallback: ClCntDeleteCallbackT,
        fpUserDestroyCallback: ClCntDeleteCallbackT,
        containerKeyType: ClCntKeyTypeT,
        pContainerHandle: *mut ClCntHandleT,
    ) -> ClRcT;
}
extern "C" {
    #[doc = "  \\brief  Creates a thread safe hash table.\n\n  \\par Header File:\n   clCntApi.h\n\n  \\param  numberOfBuckets  Number of buckets (table size) in the hash table.\n\n  \\param fpKeyCompare (in) Pointer to the user's key compare function. It accepts two\n  parameters of type \\e ClCntKeyHandleT. This function returns the following values:\n  \\arg a negative value: If first key is lesser than the second key.\n  \\arg zero: If both the keys are equal.\n  \\arg a positive value: If first key is greater than second key. \\n\n  \\b Note: \\n\n  For the APIs where a traversal of the nodes in the container is involved, you must pass a key for\n  a node to be found. This callback function is called by the Container library for every node in\n  the container with the key passed by you and the key for that node. The implementation of this\n  function must compare the keys in the application specific way and return a value as documented below.\n\n  \\param fpUserDeleteCallback (in)  Pointer to the user's destroy callback function. This function is called\n  by the container library whenever either \\e clCntNodeDelete or \\e clCntNodeAllDelete API is called. The\n  delete callback function must free any memory allocated by the application for the node being deleted.\n\n  \\param  fpUserDestroyCallback (in) Pointer to the user's destroy callback function.\n  This function is called, whenever you invoke the destroy API. The\n  user-key and user-data of each node, which is being deleted is passed as first\n  and second argument to this callback.\n\n  \\param  containerKeyType (in)  Enum indicating whether the Container is of a unique\n  key type or a non-unique key type.\n\n  \\param  pContainerHandle (out) Pointer to the variable of type ClCntHandleT in\n  which the function returns a valid Container handle on successful creation of Container.\n\n  \\retval CL_OK The API executed successfully.\n  \\retval CL_ERR_NO_MEMORY On memory allocation failure.\n  \\retval CL_ERR_NULL_POINTER On passing NULL values for either\n  pContainerHandle or compare call back funtion.\n  \\retval CL_ERR_INVALID_PARAMETER On passing invalid values to container\n  type.\n  \\retval CL_ERR_INVALID_PARAMETER On passing invalid values to container\n  type.\n  \\retval CL_ERR_MUTEX_ERROR On passing invalid values for creationg mutex.\n\n  \\note\n  Return value is a combination of the component id and error code. As Return\n  values only the Error Codes are listed above.\n  Use \\c CL_GET_ERROR_CODE(RET_CODE) defined in clCommonErrors.h to retrieve the error code.\n\n  \\par Description:\n  This API is used to create a hash table Container with Numbuckets. It populates all\n  the function pointers related with hash table. It provides thread safe\n  container, so locking will be provided.\n\n  \\par Library File:\n   ClCnt\n\n  \\sa none"]
    pub fn clCntThreadSafeHashtblCreate(
        numberOfBuckets: ClUint32T,
        fpKeyCompare: ClCntKeyCompareCallbackT,
        fpHashFunction: ClCntHashCallbackT,
        fpUserDeleteCallback: ClCntDeleteCallbackT,
        fpUserDestroyCallback: ClCntDeleteCallbackT,
        containerKeyType: ClCntKeyTypeT,
        pContainerHandle: *mut ClCntHandleT,
    ) -> ClRcT;
}
extern "C" {
    #[doc = "  \\brief  Creates the container red black tree.\n\n  \\par Header File:\n   clCntApi.h\n\n  \\param fpKeyCompare (in) Pointer to the user's key compare function. It accepts two\n  parameters of type \\e ClCntKeyHandleT. This function returns the following values:\n  \\arg a negative value: If first key is lesser than the second key.\n  \\arg zero: If both the keys are equal.\n  \\arg a positive value: If first key is greater than second key. \\n\n  \\b Note: \\n\n  For the APIs where a traversal of the nodes in the container is involved, you must pass a key for\n  a node to be found. This callback function is called by the Container library for every node in\n  the container with the key passed by you and the key for that node. The implementation of this\n  function must compare the keys in the application specific way and return a value as documented below.\n\n  \\param fpUserDeleteCallback (in):  Pointer to the user's destroy callback function. This function is called\n  by the container library whenever either \\e clCntNodeDelete or \\e clCntNodeAllDelete API is called. The\n  delete callback function must free any memory allocated by the application for the node being deleted.\n\n  \\param  fpUserDestroyCallback (in) Pointer to the user's destroy callback function.\n  This function is called, whenever you invoke the destroy API. The\n  user-key and user-data of each node, which is being deleted is passed as first\n  and second argument to this callback.\n\n  \\param  containerKeyType (in)  Enum indicating whether the Container is of a unique\n  key type or a non-unique key type.\n\n  \\param  pContainerHandle (out) Pointer to the variable of type ClCntHandleT in\n  which the function returns a valid Container handle on successful creation of Container.\n\n  \\retval CL_OK: The API executed successfully.\n  \\retval CL_ERR_NO_MEMORY: On memory allocation failure.\n  \\retval CL_ERR_NULL_POINTER: On passing NULL values for either\n  pContainerHandle or compare call back funtion.\n  \\retval CL_ERR_INVALID_PARAMETER: On passing invalid values to container\n  type.\n  \\retval CL_ERR_INVALID_PARAMETER: On passing invalid values to container\n  type.\n  \\retval CL_ERR_MUTEX_ERROR: On passing invalid values for creationg mutex.\n\n  \\note\n  Return value is a combination of the component id and error code. As Return\n  values only the Error Codes are listed above.\n  Use \\c CL_GET_ERROR_CODE(RET_CODE) defined in clCommonErrors.h to retrieve the error code.\n\n  \\par Description:\n  This API is used to create and initialize Red Black Tree Container that\n  supports only unique keys.\n\n  \\par Library File:\n   ClCnt\n\n  \\sa none"]
    pub fn clCntRbtreeCreate(
        fpKeyCompare: ClCntKeyCompareCallbackT,
        fpUserDeleteCallback: ClCntDeleteCallbackT,
        fpUserDestroyCallback: ClCntDeleteCallbackT,
        containerKeyType: ClCntKeyTypeT,
        pContainerHandle: *mut ClCntHandleT,
    ) -> ClRcT;
}
extern "C" {
    #[doc = "  \\brief  Creates the thread safe container red black tree.\n\n  \\par Header File:\n   clCntApi.h\n\n  \\param fpKeyCompare (in) Pointer to the user's key compare function. It accepts two\n  parameters of type \\e ClCntKeyHandleT. This function returns the following values:\n  \\arg a negative value: If first key is lesser than the second key.\n  \\arg zero: If both the keys are equal.\n  \\arg a positive value: If first key is greater than second key. \\n\n  \\b Note: \\n\n  For the APIs where a traversal of the nodes in the container is involved, you must pass a key for\n  a node to be found. This callback function is called by the Container library for every node in\n  the container with the key passed by you and the key for that node. The implementation of this\n  function must compare the keys in the application specific way and return a value as documented below.\n\n  \\param fpUserDeleteCallback (in):  Pointer to the user's destroy callback function. This function is called\n  by the container library whenever either \\e clCntNodeDelete or \\e clCntNodeAllDelete API is called. The\n  delete callback function must free any memory allocated by the application for the node being deleted.\n\n  \\param  fpUserDestroyCallback (in) Pointer to the user's destroy callback function.\n  This function is called, whenever you invoke the destroy API. The\n  user-key and user-data of each node, which is being deleted is passed as first\n  and second argument to this callback.\n\n  \\param  containerKeyType (in)  Enum indicating whether the Container is of a unique\n  key type or a non-unique key type.\n\n  \\param  pContainerHandle (out) Pointer to the variable of type ClCntHandleT in\n  which the function returns a valid Container handle on successful creation of Container.\n\n  \\retval CL_OK The API executed successfully.\n  \\retval CL_ERR_NO_MEMORY On memory allocation failure.\n  \\retval CL_ERR_NULL_POINTER On passing NULL values for either\n  pContainerHandle or compare call back funtion.\n  \\retval CL_ERR_INVALID_PARAMETER On passing invalid values to container\n  type.\n  \\retval CL_ERR_INVALID_PARAMETER On passing invalid values to container\n  type.\n  \\retval CL_ERR_MUTEX_ERROR On passing invalid values for creationg mutex.\n\n  \\note\n  Return value is a combination of the component id and error code. As Return\n  values only the Error Codes are listed above.\n  Use \\c CL_GET_ERROR_CODE(RET_CODE) defined in clCommonErrors.h to retrieve the error code.\n\n  \\par Description:\n  This API is used to create and initialize Red Black Tree Container that\n  supports only unique keys. It provides thread safe through mutex\n  variables.\n\n  \\par Library File:\n   ClCnt\n\n  \\sa none"]
    pub fn clCntThreadSafeRbtreeCreate(
        fpKeyCompare: ClCntKeyCompareCallbackT,
        fpUserDeleteCallback: ClCntDeleteCallbackT,
        fpUserDestroyCallback: ClCntDeleteCallbackT,
        containerKeyType: ClCntKeyTypeT,
        pContainerHandle: *mut ClCntHandleT,
    ) -> ClRcT;
}
extern "C" {
    #[doc = "  \\brief Adds a new node to Container and returns the node handle.\n\n  \\par Header File:\n   clCntApi.h\n\n  \\param containerHandle (in) Handle of Container returned by the create API.\n\n  \\param userKey (in) Handle of the user key.\n\n  \\param userData (in) User specified data. Memory allocation\n  for this parameter must be done by you.\n\n  \\param pExp (in) An RBE Expression to associate with this new node.\n\n  \\param pNodeHandle (out) Pointer to the variable of type ClCntNodeHandleT\n  in which handle of the node is added.\n\n  \\retval CL_OK The API executed successfully.\n  \\retval CL_ERR_NULL_POINTER On passing a NULL pointer.\n  \\retval CL_ERR_INVALID_HANDLE On passing an invalid Container handle.\n  \\retval CL_ERR_NO_MEMORY On memory allocation failure.\n  \\retval CL_ERR_DUPLICATE If user-key already exists and the Container created supports only unique keys.\n\n  \\note\n  Return value is a combination of the component id and error code. As Return\n  values only the Error Codes are listed above.\n  Use \\c CL_GET_ERROR_CODE(RET_CODE) defined in clCommonErrors.h to retrieve the error code.\n\n  \\par Description:\n  This API is used to create and insert a new node into the Container as well as to return\n  the handle of the newly created node.\n\n  \\par Library File:\n   ClCnt\n\n  \\sa clCntLlistCreate(), clCntHashtblCreate(), clCntRbtreeCreate(),\n"]
    pub fn clCntNodeAddAndNodeGet(
        containerHandle: ClCntHandleT,
        userKey: ClCntKeyHandleT,
        userData: ClCntDataHandleT,
        pExp: *mut ClRuleExprT,
        pNodeHandle: *mut ClCntNodeHandleT,
    ) -> ClRcT;
}
extern "C" {
    #[doc = "  \\brief Adds a new node to Container.\n\n  \\par Header File:\n   clCntApi.h\n\n  \\param containerHandle (in) Handle of Container returned by the create API.\n  \\param userKey (in) Handle of the user-key.\n  \\param userData (in) User specified data. Memory allocation\n   for \\e userData must be done by you.\n  \\param rbeExpression (in)  An RBE expression to associate with the new node.\n\n  \\retval CL_OK The API executed successfully.\n  \\retval CL_ERR_NULL_POINTER On passing a NULL pointer.\n  \\retval CL_ERR_INVALID_HANDLE On passing an invalid Container handle.\n  \\retval CL_ERR_NO_MEMORY On memory allocation failure.\n  \\retval CL_ERR_DUPLICATE If user-key already exists and the Container created supports only unique keys.\n\n  \\note\n  Return value is a combination of the component id and error code. As Return\n  values only the Error Codes are listed above.\n  Use \\c CL_GET_ERROR_CODE(RET_CODE) defined in clCommonErrors.h to retrieve the error code.\n\n  \\par Description:\n  This API is used to create and insert a new node into the Container.\n\n  \\par Library File:\n   ClCnt\n\n  \\sa clCntLlistCreate(), clCntHashtblCreate(), clCntRbtreeCreate(),\n"]
    pub fn clCntNodeAdd(
        containerHandle: ClCntHandleT,
        userKey: ClCntKeyHandleT,
        userData: ClCntDataHandleT,
        rbeExpression: *mut ClRuleExprT,
    ) -> ClRcT;
}
extern "C" {
    #[doc = "  \\brief Deletes all the nodes from the Container.\n\n  \\par Header File:\n   clCntApi.h\n\n  \\param containerHandle (in) Handle of Container returned by the create API.\n\n  \\retval CL_OK The API executed successfully.\n  \\retval CL_ERR_NULL_POINTER On passing a NULL pointer.\n  \\retval CL_ERR_INVALID_HANDLE On passing an invalid Container handle.\n  \\retval CL_ERR_NOT_EXIST If node does not exist.\n  \\note\n  Return value is a combination of the component id and error code. As Return\n  values only the Error Codes are listed above.\n  Use \\c CL_GET_ERROR_CODE(RET_CODE) defined in clCommonErrors.h to retrieve the error code.\n\n  \\par Description:\n  This API is used to delete all the nodes from the Container, but does not affect the user-data.\n  You are required to perform memory allocation and de-allocation for data.\n\n  \\par Library File:\n   ClCnt\n\n  \\sa clCntLlistCreate(), clCntHashtblCreate(), clCntRbtreeCreate(),\n"]
    pub fn clCntAllNodesDelete(containerHandle: ClCntHandleT) -> ClRcT;
}
extern "C" {
    #[doc = "  \\par Deletes all the nodes associated with specific key from the Container.\n\n  \\par Header File:\n   clCntApi.h\n\n  \\param  containerHandle (in) Handle of Container returned by the create API.\n  \\param  userKey (in) User specified key.\n\n  \\retval CL_OK The API executed successfully.\n  \\retval CL_ERR_NULL_POINTER On passing a NULL pointer.\n  \\retval CL_ERR_INVALID_HANDLE On passing an invalid Container handle.\n  \\retval CL_ERR_NOT_EXIST If node does not exist.\n\n  \\note\n  Return value is a combination of the component id and error code. As Return\n  values only the Error Codes are listed above.\n  Use \\c CL_GET_ERROR_CODE(RET_CODE) defined in clCommonErrors.h to retrieve the error code.\n\n  \\par Description:\n  This API is used to delete all the nodes associated with the specific user key, but does not\n  affect the user-data. You are required to perform memory allocation and de-allocation for data.\n\n  \\par Library File:\n   ClCnt\n\n  \\sa clCntLlistCreate(), clCntHashtblCreate(), clCntRbtreeCreate(),\n      clCntNodeFind(), clCntDataForKeyGet(), clCntNodeUserDataGet(),\n      clCntNodeUserKeyGet()\n"]
    pub fn clCntAllNodesForKeyDelete(
        containerHandle: ClCntHandleT,
        userKey: ClCntKeyHandleT,
    ) -> ClRcT;
}
extern "C" {
    #[doc = "  \\brief Deletes a specific node from the Container.\n\n  \\par Header File:\n   clCntApi.h\n\n  \\param containerHandle (in) Handle of Container returned by the create API.\n  \\param nodeHandle (in) Handle of the node to be deleted.\n\n  \\retval CL_OK The API executed successfully.\n  \\retval CL_ERR_NULL_POINTER On passing a NULL pointer.\n  \\retval CL_ERR_INVALID_HANDLE On passing an invalid Container handle.\n  \\retval CL_ERR_NOT_EXIST If node does not exist.\n\n  \\note\n  Return value is a combination of the component id and error code. As Return\n  values only the Error Codes are listed above.\n  Use \\c CL_GET_ERROR_CODE(RET_CODE) defined in clCommonErrors.h to retrieve the error code.\n\n  \\par Description:\n  This API is used to delete the specific node from the Container, but it does not affect the user data.\n  You are required to perform memory allocation and de-allocation for data.\n\n  \\par Library File:\n   ClCnt\n\n  \\sa clCntLlistCreate(), clCntHashtblCreate(), clCntRbtreeCreate(),\n      clCntNodeFind(), clCntDataForKeyGet(), clCntNodeUserDataGet(),\n      clCntNodeUserKeyGet()\n"]
    pub fn clCntNodeDelete(containerHandle: ClCntHandleT, nodeHandle: ClCntNodeHandleT) -> ClRcT;
}
extern "C" {
    #[doc = "  \\brief Finds a specific node in the Container.\n\n  \\par Header File:\n   clCntApi.h\n\n  \\param containerHandle (in) Handle of Container returned by the create API.\n  \\param userKey (in) User specified key.\n  \\param pNodeHandle (out) Pointer to the variable of type ClCntNodeHandleT\n  in which handle of the node is found.\n\n  \\retval CL_OK The API executed successfully.\n  \\retval CL_ERR_NULL_POINTER On passing a NULL pointer.\n  \\retval CL_ERR_INVALID_HANDLE On passing an invalid Container handle.\n  \\retval CL_ERR_NOT_EXIST If user-key does not exist.\n\n  \\note\n  Return value is a combination of the component id and error code. As Return\n  values only the Error Codes are listed above.\n  Use \\c CL_GET_ERROR_CODE(RET_CODE) defined in clCommonErrors.h to retrieve the error code.\n\n  \\par Description:\n  This API is used to search for a specific node in the Container. It returns the node associated\n  with the specific key from the Container. If multiple nodes are associated with the same key,\n  the node handle of first node associated with the key is returned.\n\n  \\par Library File:\n   ClCnt\n\n  \\sa clCntLlistCreate(), clCntHashtblCreate(), clCntRbtreeCreate(),\n      clCntDataForKeyGet(), clCntNodeUserDataGet(), clCntNodeUserKeyGet()\n"]
    pub fn clCntNodeFind(
        containerHandle: ClCntHandleT,
        userKey: ClCntKeyHandleT,
        pNodeHandle: *mut ClCntNodeHandleT,
    ) -> ClRcT;
}
extern "C" {
    pub fn clCntNonUniqueKeyFind(
        container: ClCntHandleT,
        key: ClCntKeyHandleT,
        givenData: ClCntDataHandleT,
        cmp: ::std::option::Option<
            unsafe extern "C" fn(data1: ClCntDataHandleT, data2: ClCntDataHandleT) -> ClInt32T,
        >,
        pDataHandle: *mut ClCntDataHandleT,
    ) -> ClRcT;
}
extern "C" {
    #[doc = "  \\brief Returns the first node from the Container.\n\n  \\par Header File:\n   clCntApi.h\n\n  \\param containerHandle (in) Handle of Container returned by the create API.\n  \\param pNodeHandle (out) Pointer to the variable of type ClCntNodeHandleT\n  in which handle of the node is found.\n\n  \\retval CL_OK The API executed successfully.\n  \\retval CL_ERR_NULL_POINTER On passing a NULL pointer.\n  \\retval CL_ERR_INVALID_HANDLE On passing an invalid Container handle or if the Container is empty.\n\n  \\note\n  Return value is a combination of the component id and error code. As Return\n  values only the Error Codes are listed above.\n  Use \\c CL_GET_ERROR_CODE(RET_CODE) defined in clCommonErrors.h to retrieve the error code.\n\n  \\par Description:\n  This API is used to retrieve the first node from the Container.\n\n  \\par Library File:\n   ClCnt\n\n  \\sa clCntLlistCreate(), clCntHashtblCreate(), clCntRbtreeCreate(),\n      clCntNodeFind()\n"]
    pub fn clCntFirstNodeGet(
        containerHandle: ClCntHandleT,
        pNodeHandle: *mut ClCntNodeHandleT,
    ) -> ClRcT;
}
extern "C" {
    #[doc = "  \\brief Returns the last node from the Container.\n\n  \\par Header File:\n   clCntApi.h\n\n  \\param containerHandle (in)  Handle of Container returned by the create API.\n  \\param currentNodeHandle (out)  Handle of the current node.\n  \\param pNextNodeHandle  (out) Pointer to the variable of type ClCntNodeHandleT\n   in which the handle of the next node is returned.\n\n  \\retval CL_OK The API executed successfully.\n  \\retval CL_ERR_NULL_POINTER On passing a NULL pointer.\n  \\retval CL_ERR_INVALID_HANDLE On passing an invalid Container handle or if the Container is empty.\n\n  \\note\n  Return value is a combination of the component id and error code. As Return\n  values only the Error Codes are listed above.\n  Use \\c CL_GET_ERROR_CODE(RET_CODE) defined in clCommonErrors.h to retrieve the error code.\n\n  \\par Description:\n  This API is used to return the last node from the Container.\n\n  \\par Library File:\n   ClCnt\n\n  \\sa clCntLlistCreate(), clCntHashtblCreate(), clCntRbtreeCreate(),\n      clCntNodeFind()\n"]
    pub fn clCntLastNodeGet(
        containerHandle: ClCntHandleT,
        pNodeHandle: *mut ClCntNodeHandleT,
    ) -> ClRcT;
}
extern "C" {
    #[doc = "  \\brief Returns the next node from the Container.\n\n  \\par Header File:\n   clCntApi.h\n\n  \\param containerHandle (in) Handle of Container returned by the create API.\n  \\param currentNodeHandle (in) Handle of current node.\n  \\param pNextNodeHandle  (out) Pointer to the variable of type ClCntNodeHandleT\n   in which the handle of the next node is returned.\n\n  \\retval CL_OK The API executed successfully.\n  \\retval CL_ERR_NULL_POINTER On passing a NULL pointer.\n  \\retval CL_ERR_INVALID_HANDLE On passing an invalid Container handle or if the Container is empty.\n\n  \\note\n  Return value is a combination of the component id and error code. As Return\n  values only the Error Codes are listed above.\n  Use \\c CL_GET_ERROR_CODE(RET_CODE) defined in clCommonErrors.h to retrieve the error code.\n\n  \\par Description:\n  This API is used to return the next node after a specific node in the Container.\n\n  \\par Library File:\n   ClCnt\n\n  \\sa clCntLlistCreate(), clCntHashtblCreate(), clCntRbtreeCreate(),\n      clCntNodeFind()\n"]
    pub fn clCntNextNodeGet(
        containerHandle: ClCntHandleT,
        currentNodeHandle: ClCntNodeHandleT,
        pNextNodeHandle: *mut ClCntNodeHandleT,
    ) -> ClRcT;
}
extern "C" {
    #[doc = "  \\brief Returns the previous node from the Container.\n\n  \\par Header File:\n   clCntApi.h\n\n  \\param containerHandle (in) Handle of the Container returned by the create API.\n  \\param currentNodeHandle (in) Handle of the current node.\n  \\param pPreviousNodeHandle (out) Pointer to the variable of type ClCntNodeHandleT\n  in which the handle of the previous node is returned.\n\n  \\retval CL_OK The API executed successfully.\n  \\retval CL_ERR_NULL_POINTER On passing a NULL pointer.\n  \\retval CL_ERR_INVALID_HANDLE On passing an invalid Container handle or if the Container is empty.\n\n  \\note\n  Return value is a combination of the component id and error code. As Return\n  values only the Error Codes are listed above.\n  Use \\c CL_GET_ERROR_CODE(RET_CODE) defined in clCommonErrors.h to retrieve the error code.\n\n  \\par Description:\n  This API is used to return the node before a specific node in the Container.\n\n  \\par Library File:\n   ClCnt\n\n  \\sa clCntLlistCreate(), clCntHashtblCreate(), clCntRbtreeCreate(),\n      clCntNodeFind()\n"]
    pub fn clCntPreviousNodeGet(
        containerHandle: ClCntHandleT,
        currentNodeHandle: ClCntNodeHandleT,
        pPreviousNodeHandle: *mut ClCntNodeHandleT,
    ) -> ClRcT;
}
extern "C" {
    #[doc = "  \\brief Walks through the Container.\n\n  \\param containerHandle (in) Handle of the Container returned by the create API.\n\n  \\param fpUserWalkCallback (in) Pointer to the user's walk callback function.\n  It accepts the following arguments:\n  \\arg ClCntKeyHandleT   Handle to user-key of the node\n  \\arg ClCntDataHandleT  Handle to user-data of the node.\n  The \\e userKey and \\e userData of each node are passed as first and second\n  arguments to the callback function. User specified \\e userArg is also passed.\n\n  \\param userArg (in)  User specified argument, which is passed as third parameter\n  to the user walk callback function. This parameter is also passed to the\n  \\e clRbeExprEvaluate API.\n\n  \\param length (in) Length of \\e userArg. This parameter is also passed to\n  clRbeExprEvaluate API.\n\n  \\retval CL_OK The API executed successfully.\n  \\retval CL_ERR_NULL_POINTER On passing a NULL pointer.\n  \\retval CL_ERR_INVALID_HANDLE On passing an invalid Container handle or if the Container is empty.\n\n  \\note\n  Return value is a combination of the component id and error code. As Return\n  values only the Error Codes are listed above.\n  Use \\c CL_GET_ERROR_CODE(RET_CODE) defined in clCommonErrors.h to retrieve the error code.\n\n  \\par Description:\n  This API is used to perform a walk through the Container. For each node encountered\n  during the walk, if the RBE associated with the node evaluates to: \\n\n<BR>\n  \\arg TRUE or NULL The user specific callback function is called with the key and data\n   handles present in the encountered node.\n  \\arg FALSE: The callback function is not called for the current node. The walk function\n  continues with the next node.\n\n  \\par Library File:\n   ClCnt\n\n  \\sa clCntLlistCreate(), clCntHashtblCreate(), clCntRbtreeCreate(),\n"]
    pub fn clCntWalk(
        containerHandle: ClCntHandleT,
        fpUserWalkCallback: ClCntWalkCallbackT,
        userArg: ClCntArgHandleT,
        length: ClInt32T,
    ) -> ClRcT;
}
extern "C" {
    pub fn clCntWalkFailSafe(
        containerHandle: ClCntHandleT,
        fpUserWalkCallback: ClCntWalkCallbackT,
        userArg: ClCntArgHandleT,
        length: ClInt32T,
    ) -> ClRcT;
}
extern "C" {
    #[doc = "  \\brief Returns the user-key from the node.\n\n  \\par Header File:\n   clCntApi.h\n\n  \\param containerHandle (in) Handle of the Container returned by the create API.\n  \\param nodeHandle (in) Handle of node from which user-key is to be retrieved.\n  \\param pUserKey (out) Pointer to the variable of type ClCntNodeHandleT\n  in which the handle of the user-key is returned.\n\n  \\retval CL_OK The API executed successfully.\n  \\retval CL_ERR_NULL_POINTER On passing a NULL pointer.\n  \\retval CL_ERR_INVALID_HANDLE On passing an invalid Container handle or if the Container is empty.\n\n  \\note\n  Return value is a combination of the component id and error code. As Return\n  values only the Error Codes are listed above.\n  Use \\c CL_GET_ERROR_CODE(RET_CODE) defined in clCommonErrors.h to retrieve the error code.\n\n  \\par Description:\n  This API is used to retrieve the user-key from a specified node.\n\n  \\par Library File:\n   ClCnt\n\n  \\sa clCntLlistCreate(), clCntHashtblCreate(), clCntRbtreeCreate(),\n      clCntNodeFind(), clCntDataForKeyGet(), clCntNodeUserDataGet()\n"]
    pub fn clCntNodeUserKeyGet(
        containerHandle: ClCntHandleT,
        nodeHandle: ClCntNodeHandleT,
        pUserKey: *mut ClCntKeyHandleT,
    ) -> ClRcT;
}
extern "C" {
    #[doc = "  \\brief Returns the user-data associated with a specified key.\n\n  \\par Header File:\n   clCntApi.h\n\n  \\param containerHandle (in)  Handle of the Container returned by the create API.\n  \\param userKey (in) User-key, for which associated data is to be retrieved.\n  \\param pUserData (out) Pointer to the variable of type \\e ClCntNodeHandleT\n  in which the handle of the user-data associated with a specific key is returned.\n\n  \\retval CL_OK The API executed successfully.\n  \\retval CL_ERR_NULL_POINTER On passing a NULL pointer.\n  \\retval CL_ERR_INVALID_HANDLE On passing an invalid Container handle or if the Container is empty.\n  \\retval CL_ERR_NOT_EXIST If user-key does not exist.\n  \\retval CL_ERR_NOT_IMPLEMENTED If this API is used with non-unique keys.\n\n  \\note\n  Return value is a combination of the component id and error code. As Return\n  values only the Error Codes are listed above.\n  Use \\c CL_GET_ERROR_CODE(RET_CODE) defined in clCommonErrors.h to retrieve the error code.\n\n  \\par Description:\n  This API is used to retrieve the user-data associated with a specified key. It must\n  be used only if the keys are unique. For non-unique keys, the API returns an error.\n\n  \\par Library File:\n   ClCnt\n\n  \\sa clCntLlistCreate(), clCntHashtblCreate(), clCntRbtreeCreate(),\n      clCntNodeFind(), clCntNodeUserKeyGet(), clCntNodeUserDataGet()\n"]
    pub fn clCntDataForKeyGet(
        containerHandle: ClCntHandleT,
        userKey: ClCntKeyHandleT,
        pUserData: *mut ClCntDataHandleT,
    ) -> ClRcT;
}
extern "C" {
    #[doc = "  \\brief Returns the user-data from the node.\n\n  \\par Header File:\n   clCntApi.h\n\n  \\param containerHandle (in) Handle of the Container returned by the create API.\n  \\param nodeHandle (in)  Handle of the node.\n  \\param pUserDataHandle  (out) Pointer to the variable of type \\e ClCntNodeHandleT\n  in which the handle of the user-data associated with a specific key is returned.\n\n  \\retval CL_OK The API executed successfully.\n  \\retval CL_ERR_NULL_POINTER On passing a NULL pointer.\n  \\retval CL_ERR_INVALID_HANDLE On passing an invalid Container handle or if the Container is empty.\n\n  \\note\n  Return value is a combination of the component id and error code. As Return\n  values only the Error Codes are listed above.\n  Use \\c CL_GET_ERROR_CODE(RET_CODE) defined in clCommonErrors.h to retrieve the error code.\n\n  \\par Description:\n  This API is used to retrieve the user-data from a specific node.\n\n  \\par Library File:\n   ClCnt\n\n  \\sa clCntLlistCreate(), clCntHashtblCreate(), clCntRbtreeCreate(),\n      clCntNodeFind(), clCntNodeUserKeyGet(), clCntDataForKeyGet()\n"]
    pub fn clCntNodeUserDataGet(
        containerHandle: ClCntHandleT,
        nodeHandle: ClCntNodeHandleT,
        pUserDataHandle: *mut ClCntDataHandleT,
    ) -> ClRcT;
}
extern "C" {
    #[doc = "  \\brief Returns the size of the Container.\n\n  \\par Header File:\n   clCntApi.h\n\n  \\param containerHandle (in) Handle of the Container returned by the create API.\n  \\param pSize (out) Pointer to the variable of type \\e ClCntNodeHandleT\n  in which size of the Container is returned.\n\n  \\retval CL_OK The API executed successfully.\n  \\retval CL_ERR_NULL_POINTER On passing a NULL pointer.\n  \\retval CL_ERR_INVALID_HANDLE On passing an invalid Container handle or if the Container is empty.\n\n  \\note\n  Return value is a combination of the component id and error code. As Return\n  values only the Error Codes are listed above.\n  Use \\c CL_GET_ERROR_CODE(RET_CODE) defined in clCommonErrors.h to retrieve the error code.\n\n  \\par Description:\n  This API is used to return the total number of nodes in the Container.\n\n  \\par Library File:\n   ClCnt\n\n  \\sa clCntLlistCreate(), clCntHashtblCreate(), clCntRbtreeCreate()\n"]
    pub fn clCntSizeGet(containerHandle: ClCntHandleT, pSize: *mut ClUint32T) -> ClRcT;
}
extern "C" {
    #[doc = "  \\brief Returns the number of nodes associated with a user-key.\n\n  \\par Header File:\n   clCntApi.h\n\n  \\param containerHandle (in) Handle of the Container returned by the create API.\n  \\param userKey (in) Handle of the user-key.\n  \\param pSize (out) Pointer to the variable of type \\e ClCntNodeHandleT\n  in which the number of nodes associated with the specified user-key is returned.\n\n  \\retval CL_OK The API executed successfully.\n  \\retval CL_ERR_NULL_POINTER On passing a NULL pointer.\n  \\retval CL_ERR_INVALID_HANDLE On passing an invalid Container handle or if the Container is empty.\n\n  \\note\n  Return value is a combination of the component id and error code. As Return\n  values only the Error Codes are listed above.\n  Use \\c CL_GET_ERROR_CODE(RET_CODE) defined in clCommonErrors.h to retrieve the error code.\n\n  \\par Description:\n  This API is used to return the number of nodes associated with a\n  specific user-key.\n\n  \\par Library File:\n   ClCnt\n\n  \\sa clCntLlistCreate(), clCntHashtblCreate(), clCntRbtreeCreate()\n"]
    pub fn clCntKeySizeGet(
        containerHandle: ClCntHandleT,
        userKey: ClCntKeyHandleT,
        pSize: *mut ClUint32T,
    ) -> ClRcT;
}
extern "C" {
    #[doc = "  \\brief Destroys the Container.\n\n  \\par Header File:\n   clCntApi.h\n\n  \\param containerHandle(in) Handle of Container returned by the create API.\n\n  \\retval CL_OK The API executed successfully.\n  \\retval CL_ERR_NULL_POINTER On passing a NULL pointer.\n  \\retval CL_ERR_INVALID_HANDLE On passing an invalid Container handle.\n\n  \\note\n  Return value is a combination of the component id and error code. As Return\n  values only the Error Codes are listed above.\n  Use \\c CL_GET_ERROR_CODE(RET_CODE) defined in clCommonErrors.h to retrieve the error code.\n\n  \\par Description:\n  This API is used to delete all the nodes and destroy the Container\n  but it does not affect any user-data.\n\n  \\par Library File:\n   ClCnt\n\n  \\sa clCntLlistCreate(), clCntHashtblCreate(), clCntRbtreeCreate()\n"]
    pub fn clCntDelete(containerHandle: ClCntHandleT) -> ClRcT;
}
extern "C" {
    pub fn clCntNonUniqueKeyDelete(
        container: ClCntHandleT,
        key: ClCntKeyHandleT,
        givenData: ClCntDataHandleT,
        cmp: ::std::option::Option<
            unsafe extern "C" fn(arg1: ClCntDataHandleT, arg2: ClCntDataHandleT) -> ClInt32T,
        >,
    ) -> ClRcT;
}
