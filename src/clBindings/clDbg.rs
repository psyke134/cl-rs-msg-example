/* automatically generated by rust-bindgen 0.66.1 */

extern "C" {
    pub static mut clDbgPauseOn: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut clDbgPauseOnCodeError: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut clDbgNoKillComponents: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut clDbgCompTimeoutOverride: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut clDbgLogLevel: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut clDbgResourceLogLevel: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut clDbgReverseTiming: ::std::os::raw::c_int;
}
extern "C" {
    pub fn clDbgInitialize();
}
extern "C" {
    pub fn clDbgPauseFn(file: *const ::std::os::raw::c_char, line: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = "  \\page clDbgResume\n\n  \\par Synopsis:\n  Continue a paused thread -- do not call in code!\n\n  \\par Header File:\n  clDbg.h\n\n  \\par Syntax:\n  \\code \t void clDebugPause();\n  \\endcode\n\n  \\par Description:\n  Call this function from the debugger to resume a paused thread this thread.\n  Useful when you don't have a chance to set a breakpoint.\n\n  \\par Library File:\n   libClDebugClient.a\n\n  \\par Related Function(s):\n   \\ref \"clDebugResume\""]
    pub fn clDbgResume();
}
extern "C" {
    pub fn clDbgMsg(
        pid: ::std::os::raw::c_int,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        fn_: *const ::std::os::raw::c_char,
        level: ::std::os::raw::c_int,
        str_: *const ::std::os::raw::c_char,
    );
}
pub const clDbgHandleResource: _bindgen_ty_1 = 1;
pub const clDbgHandleGroupResource: _bindgen_ty_1 = 2;
pub const clDbgWorkHandleResource: _bindgen_ty_1 = 3;
pub const clDbgMemoryResource: _bindgen_ty_1 = 4;
pub const clDbgMutexResource: _bindgen_ty_1 = 5;
pub const clDbgComponentResource: _bindgen_ty_1 = 6;
pub const clDbgCheckpointResource: _bindgen_ty_1 = 7;
pub const clDbgAllocate: _bindgen_ty_1 = 1000;
pub const clDbgRelease: _bindgen_ty_1 = 1001;
#[doc = "  \\page clDbgResourceNotify\n\n  \\par Synopsis:\n  Call to indiciate the allocation or release of a resource, for debugging purposes\n\n  \\par Header File:\n  clDbg.h\n\n  \\par Syntax:\n  \\code \t clDbgResourceNotify(resourceType, operation, resource, printfParams)\n  \\endcode\n\n  \\par Description:\n  Call this function when you are allocating/deallocating a resource or initializing/deinitializing a service.  The debugging infrastructure will\n  track this resource to make sure it is not leaked, inited/destructed twice, etc.\n  The resourceType is one of the \"Resource\" enums defined below, go ahead and add others when necessary\n  The resource operation must be to allocate or release (enum defined below)\n  The resourceid is a integer that uniquely identifies the resource within the resourceType.  You get to choose what exactly this is for each type if you\n  add a new type.\n\n  For Handles, this is the handle id.  For Memory a pointer to the memory.  For Mutexes, a pointer to the mutex.\n  For Services use the ClCompIdT (defined in clCommon.h).\n\n  \\par Library File:\n   libClUtils.a\n\n  \\par Related Function(s):\n"]
pub type _bindgen_ty_1 = ::std::os::raw::c_uint;
