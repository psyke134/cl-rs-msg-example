pub use crate::clBindings::clIocApi::*;
/* automatically generated by rust-bindgen 0.66.1 */

#[repr(C)]
pub struct __BindgenUnionField<T>(::std::marker::PhantomData<T>);
impl<T> __BindgenUnionField<T> {
    #[inline]
    pub const fn new() -> Self {
        __BindgenUnionField(::std::marker::PhantomData)
    }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T {
        ::std::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T {
        ::std::mem::transmute(self)
    }
}
impl<T> ::std::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self {
        Self::new()
    }
}
impl<T> ::std::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self {
        Self::new()
    }
}
impl<T> ::std::marker::Copy for __BindgenUnionField<T> {}
impl<T> ::std::fmt::Debug for __BindgenUnionField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.write_str("__BindgenUnionField")
    }
}
impl<T> ::std::hash::Hash for __BindgenUnionField<T> {
    fn hash<H: ::std::hash::Hasher>(&self, _state: &mut H) {}
}
impl<T> ::std::cmp::PartialEq for __BindgenUnionField<T> {
    fn eq(&self, _other: &__BindgenUnionField<T>) -> bool {
        true
    }
}
impl<T> ::std::cmp::Eq for __BindgenUnionField<T> {}
pub const CL_IOC_NO_SESSION: u32 = 0;
pub const CL_IOC_SESSION_BASED: u32 = 1;
pub const ClIocNotificationId_CL_IOC_NODE_ARRIVAL_NOTIFICATION: ClIocNotificationId = 0;
pub const ClIocNotificationId_CL_IOC_NODE_LEAVE_NOTIFICATION: ClIocNotificationId = 1;
pub const ClIocNotificationId_CL_IOC_COMP_ARRIVAL_NOTIFICATION: ClIocNotificationId = 2;
pub const ClIocNotificationId_CL_IOC_COMP_DEATH_NOTIFICATION: ClIocNotificationId = 3;
pub const ClIocNotificationId_CL_IOC_SENDQ_WM_NOTIFICATION: ClIocNotificationId = 4;
pub const ClIocNotificationId_CL_IOC_COMM_PORT_WM_NOTIFICATION: ClIocNotificationId = 5;
pub const ClIocNotificationId_CL_IOC_LOG_NOTIFICATION: ClIocNotificationId = 6;
pub const ClIocNotificationId_CL_IOC_NODE_VERSION_NOTIFICATION: ClIocNotificationId = 7;
pub const ClIocNotificationId_CL_IOC_NODE_VERSION_REPLY_NOTIFICATION: ClIocNotificationId = 8;
pub const ClIocNotificationId_CL_IOC_NODE_DISCOVER_NOTIFICATION: ClIocNotificationId = 9;
pub const ClIocNotificationId_CL_IOC_NODE_LINK_UP_NOTIFICATION: ClIocNotificationId = 10;
pub const ClIocNotificationId_CL_IOC_NODE_LINK_DOWN_NOTIFICATION: ClIocNotificationId = 11;
pub const ClIocNotificationId_CL_IOC_NODE_DISCOVER_PEER_NOTIFICATION: ClIocNotificationId = 12;
#[doc = " The port close notification payload\n"]
pub type ClIocNotificationId = ::std::os::raw::c_uint;
#[doc = " The port close notification payload\n"]
pub use self::ClIocNotificationId as ClIocNotificationIdT;
#[repr(C)]
pub struct ClIocQueueNotification {
    pub wmID: ClWaterMarkIdT,
    pub wm: ClWaterMarkT,
    pub queueSize: ClUint32T,
    pub messageLength: ClUint32T,
}
#[test]
fn bindgen_test_layout_ClIocQueueNotification() {
    const UNINIT: ::std::mem::MaybeUninit<ClIocQueueNotification> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ClIocQueueNotification>(),
        32usize,
        concat!("Size of: ", stringify!(ClIocQueueNotification))
    );
    assert_eq!(
        ::std::mem::align_of::<ClIocQueueNotification>(),
        8usize,
        concat!("Alignment of ", stringify!(ClIocQueueNotification))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).wmID) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ClIocQueueNotification),
            "::",
            stringify!(wmID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).wm) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ClIocQueueNotification),
            "::",
            stringify!(wm)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).queueSize) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ClIocQueueNotification),
            "::",
            stringify!(queueSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).messageLength) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(ClIocQueueNotification),
            "::",
            stringify!(messageLength)
        )
    );
}
pub type ClIocQueueNotificationT = ClIocQueueNotification;
#[repr(C)]
pub struct ClIocNotification {
    pub id: ClIocNotificationIdT,
    pub protoVersion: ClUint32T,
    pub nodeAddress: ClIocAddressT,
    pub nodeVersion: ClUint32T,
    pub notificationData: ClIocNotification__bindgen_ty_1,
}
#[repr(C)]
pub struct ClIocNotification__bindgen_ty_1 {
    pub sendqWMNotification:
        __BindgenUnionField<ClIocNotification__bindgen_ty_1_sendqWMNotification>,
    pub commPortWMNotification:
        __BindgenUnionField<ClIocNotification__bindgen_ty_1_commPortWMNotification>,
    pub bindgen_union_field: [u64; 4usize],
}
#[repr(C)]
pub struct ClIocNotification__bindgen_ty_1_sendqWMNotification {
    pub queueNotification: ClIocQueueNotificationT,
}
#[test]
fn bindgen_test_layout_ClIocNotification__bindgen_ty_1_sendqWMNotification() {
    const UNINIT: ::std::mem::MaybeUninit<ClIocNotification__bindgen_ty_1_sendqWMNotification> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ClIocNotification__bindgen_ty_1_sendqWMNotification>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(ClIocNotification__bindgen_ty_1_sendqWMNotification)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<ClIocNotification__bindgen_ty_1_sendqWMNotification>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(ClIocNotification__bindgen_ty_1_sendqWMNotification)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).queueNotification) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ClIocNotification__bindgen_ty_1_sendqWMNotification),
            "::",
            stringify!(queueNotification)
        )
    );
}
#[repr(C)]
pub struct ClIocNotification__bindgen_ty_1_commPortWMNotification {
    pub queueNotification: ClIocQueueNotificationT,
}
#[test]
fn bindgen_test_layout_ClIocNotification__bindgen_ty_1_commPortWMNotification() {
    const UNINIT: ::std::mem::MaybeUninit<ClIocNotification__bindgen_ty_1_commPortWMNotification> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ClIocNotification__bindgen_ty_1_commPortWMNotification>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(ClIocNotification__bindgen_ty_1_commPortWMNotification)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<ClIocNotification__bindgen_ty_1_commPortWMNotification>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(ClIocNotification__bindgen_ty_1_commPortWMNotification)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).queueNotification) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ClIocNotification__bindgen_ty_1_commPortWMNotification),
            "::",
            stringify!(queueNotification)
        )
    );
}
#[test]
fn bindgen_test_layout_ClIocNotification__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<ClIocNotification__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ClIocNotification__bindgen_ty_1>(),
        32usize,
        concat!("Size of: ", stringify!(ClIocNotification__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<ClIocNotification__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(ClIocNotification__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sendqWMNotification) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ClIocNotification__bindgen_ty_1),
            "::",
            stringify!(sendqWMNotification)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).commPortWMNotification) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ClIocNotification__bindgen_ty_1),
            "::",
            stringify!(commPortWMNotification)
        )
    );
}
#[test]
fn bindgen_test_layout_ClIocNotification() {
    const UNINIT: ::std::mem::MaybeUninit<ClIocNotification> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ClIocNotification>(),
        56usize,
        concat!("Size of: ", stringify!(ClIocNotification))
    );
    assert_eq!(
        ::std::mem::align_of::<ClIocNotification>(),
        8usize,
        concat!("Alignment of ", stringify!(ClIocNotification))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ClIocNotification),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).protoVersion) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ClIocNotification),
            "::",
            stringify!(protoVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nodeAddress) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ClIocNotification),
            "::",
            stringify!(nodeAddress)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nodeVersion) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ClIocNotification),
            "::",
            stringify!(nodeVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).notificationData) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ClIocNotification),
            "::",
            stringify!(notificationData)
        )
    );
}
pub type ClIocNotificationT = ClIocNotification;
extern "C" {
    #[doc = "  \\brief Returns the maximum payload size.\n\n  \\par Header File:\n  clIocApiExt.h\n\n  \\par Library Files:\n  libClIoc\n\n  \\param pSize The maximum supported payload size is returned in this.\n\n  \\retval CL_OK The API is successfully executed.\n  \\retval  CL_ERR_NOT_INITIALIZED If IOC is not initialized.\n  \\retval CL_ERR_NULL_POINTER If pSize is NULL.\n\n  \\par Description:\n  This API returns the maximum payload size that can be sent over\n  the IOC. This doesnot include the IOC header size.\n\n  \\note\n  In this release there is no limit over the payload size in\n  IOC, so this API may not be very useful.\n\n"]
    pub fn clIocMaxPayloadSizeGet(pSize: *mut ClUint32T) -> ClRcT;
}
extern "C" {
    #[doc = "  \\brief Returns the total number of neighbour nodes.\n\n  \\par Header File:\n  clIocApiExt.h\n\n  \\par Library Files:\n  libClIoc\n\n  \\param pNumberOfEntries (out) Number of neighbor nodes.\n\n  \\retval CL_OK The API is successfully executed.\n  \\retval CL_ERR_NOT_INITIALIZED If IOC is not initialized.\n  \\retval CL_ERR_NULL_POINTER If \\e pNumberOfEntries is NULL.\n\n  \\par Description:\n  This API returns the total number of neighbor nodes(including\n  duplicates and local) of the current node. This should be\n  called before the clIocNeighborListGet() is called.\n\n  \\sa\n  clIocNeighborListGet().\n\n"]
    pub fn clIocTotalNeighborEntryGet(pNumberOfEntries: *mut ClUint32T) -> ClRcT;
}
extern "C" {
    #[doc = "  \\brief change configuration all component\n\n  \\par Header File:\n  clIocApiExt.h\n\n  \\par Library Files:\n  libClIoc\n\n  \\param requestType configure change type.\n\n\n"]
    pub fn clConfigChange(requestType: ClConfigChange) -> ClRcT;
}
extern "C" {
    #[doc = "  \\brief Returns the list of neighbours IOC nodes.\n\n  \\par Header File:\n  clIocApiExt.h\n\n  \\par Library Files:\n  libClIoc\n\n  \\param pNumberOfEntries (in/out) The number of entries the array can\n  hold is passed by you. IOC will modify this number if it fills less\n  number of entries in the pAddrList ayrray.\n\n  \\param pAddrList (out) The Array of IOC node address passed by you. The number\n  of entries an array can hold is passed in the other parameter \\e pNumberOfEntries.\n\n  \\retval CL_OK The API is successfully executed.\n  \\retval CL_ERR_NOT_INITIALIZED If IOC is not initialized.\n  \\retval CL_ERR_NULL_POINTER If either \\e pNumberOfEntries or \\e pAddrList is NULL.\n  \\retval CL_ERR_NO_MEMORY If the memory allocation or any other resource\n  allocation fails.\n\n  \\par Description:\n  This API returns the list of neighbor-IOC nodes including the local node.\n  It takes an Array of ClIocNodeAddressT and the number of entries the\n  array can hold. IOC will pass the list of neighbors in the array.\n  <BR><BR> If the number of entries is less than the passed array size then\n  pNumberOfEntries is used to inform the exact number of entries.\n  <BR><BR> You must call the API clIocTotalNeighborEntryGet() to get the total number\n  of neighbors and accordingly the space to get the addresses can be allocated.\n\n  \\sa\n  clIocTotalNeighborEntryGet().\n\n"]
    pub fn clIocNeighborListGet(
        pNumberOfEntries: *mut ClUint32T,
        pAddrList: *mut ClIocNodeAddressT,
    ) -> ClRcT;
}
extern "C" {
    #[doc = "  \\brief Configures and initializes the IOC.\n\n  \\par Header File:\n  clIocApiExt.h\n\n  \\par Library Files:\n  libClIoc\n\n  \\par Parameters:\n   None\n\n  \\retval CL_OK The API is successfully executed.\n  \\retval  CL_IOC_ERR_INIT_FAILED If IOC initialization fails.\n\n  \\par Description:\n  This API is configures and initialize the IOC. This API needs to be\n  called before any other function of IOC. This function also initiates\n  the transport configuration and initialization.\n\n  \\sa\n  clIocLibFinalize(), clIocLibConfigGet().\n"]
    pub fn clIocLibInitialize(pConfig: ClPtrT) -> ClRcT;
}
extern "C" {
    #[doc = "  \\brief Cleans up the IOC.\n\n  \\par Header File:\n  clIocApiExt.h\n\n  \\par Library Files:\n  libClIoc\n\n  \\par Parameters:\n   None\n\n  \\retval CL_OK The API is successfully executed.\n\n  \\par Description:\n  This API is used to perform IOC clean up. This deregists all the\n  trnasport and cleans up all the data held by it. After this call\n  no IOC call should be made.\n\n  \\sa\n  clIocLibInitialize().\n\n"]
    pub fn clIocLibFinalize() -> ClRcT;
}
extern "C" {
    pub fn clIocCommPortDebug(portId: ClIocPortT, pCommand: *mut ClCharT) -> ClRcT;
}
extern "C" {
    pub fn clIocGeographicalAddressGet(
        iocNodeAddr: ClIocNodeAddressT,
        pGeoAddr: *mut ClCharT,
    ) -> ClRcT;
}
extern "C" {
    pub fn clIocGeographicalAddressSet(
        iocNodeAddr: ClIocNodeAddressT,
        pGeoAddr: *mut ClCharT,
    ) -> ClRcT;
}
extern "C" {
    pub fn clIocSessionReset(
        iocCommPortHdl: ClIocCommPortHandleT,
        pIocLogicalAddress: *mut ClIocLogicalAddressT,
    ) -> ClRcT;
}
extern "C" {
    pub fn clIocBind(toName: *mut ClNameT, pToHandle: *mut ClIocToBindHandleT) -> ClRcT;
}
