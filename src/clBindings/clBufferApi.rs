pub use crate::clBindings::clCommon::*;
pub use crate::clBindings::clRuleApi::*;
pub use crate::clBindings::clMemStats::*;
pub use crate::clBindings::clPoolIpi::*;
/* automatically generated by rust-bindgen 0.66.1 */

#[doc = " This is to set the read or write offset pointer to a position mentioned\n from the BEGINING of the Buffer message."]
pub const ClBufferSeekTypeT_CL_BUFFER_SEEK_SET: ClBufferSeekTypeT = 0;
#[doc = " This is to set the read or write offset pointer to a position mentioned\n from the CURRENT position of the pointer of the Buffer message."]
pub const ClBufferSeekTypeT_CL_BUFFER_SEEK_CUR: ClBufferSeekTypeT = 1;
#[doc = " This is to set the read or write offset pointer to a position mentioned\n from the END of the Buffer message."]
pub const ClBufferSeekTypeT_CL_BUFFER_SEEK_END: ClBufferSeekTypeT = 2;
#[doc = " This is to set the read or write offset pointer to a position mentioned\n from the END of the Buffer message."]
pub const ClBufferSeekTypeT_CL_BUFFER_SEEK_MAX: ClBufferSeekTypeT = 3;
pub type ClBufferSeekTypeT = ::std::os::raw::c_uint;
#[doc = " The type of the handle for the buffer messages."]
pub type ClBufferHandleT = ClPtrT;
#[doc = " In this mode the buffer library uses the malloc and free for allocating and\n deallocating memory for buffers."]
pub const ClBufferMode_CL_BUFFER_NATIVE_MODE: ClBufferMode = 0;
#[doc = " This mode makes buffer library uses Clovis implementation of Pool for\n allocating and deallocating memory for buffers."]
pub const ClBufferMode_CL_BUFFER_PREALLOCATED_MODE: ClBufferMode = 1;
#[doc = " This mode makes buffer library uses Clovis implementation of Pool for\n allocating and deallocating memory for buffers."]
pub const ClBufferMode_CL_BUFFER_MAX_MODE: ClBufferMode = 2;
#[doc = " The config mode of the Buffer. When configured in native mode,\n malloc is used for fetching the memory for the configured buffer pools\n instead of the clovis pool implementation."]
pub type ClBufferMode = ::std::os::raw::c_uint;
#[doc = " The config mode of the Buffer. When configured in native mode,\n malloc is used for fetching the memory for the configured buffer pools\n instead of the clovis pool implementation."]
pub use self::ClBufferMode as ClBufferModeT;
#[doc = " The type of the buffer configuration info."]
#[repr(C)]
pub struct ClBufferPoolConfigT {
    #[doc = " The Number pools used for buffer library."]
    pub numPools: ClUint32T,
    #[doc = " Pool configuration of all the pools used by buffer library."]
    pub pPoolConfig: *mut ClPoolConfigT,
    #[doc = " Mode of usage of pools"]
    pub lazy: ClBoolT,
    #[doc = " Mode configured for Buffer fof fetching the memory.\n i.e \\e CL_BUFFER_NATIVE_MODE, or \\e CL_BUFFER_PREALLOCATED_MODE."]
    pub mode: ClBufferModeT,
}
#[test]
fn bindgen_test_layout_ClBufferPoolConfigT() {
    const UNINIT: ::std::mem::MaybeUninit<ClBufferPoolConfigT> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ClBufferPoolConfigT>(),
        24usize,
        concat!("Size of: ", stringify!(ClBufferPoolConfigT))
    );
    assert_eq!(
        ::std::mem::align_of::<ClBufferPoolConfigT>(),
        8usize,
        concat!("Alignment of ", stringify!(ClBufferPoolConfigT))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numPools) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ClBufferPoolConfigT),
            "::",
            stringify!(numPools)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pPoolConfig) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ClBufferPoolConfigT),
            "::",
            stringify!(pPoolConfig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lazy) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ClBufferPoolConfigT),
            "::",
            stringify!(lazy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mode) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ClBufferPoolConfigT),
            "::",
            stringify!(mode)
        )
    );
}
extern "C" {
    #[doc = "  \\brief Initializes the Buffer Management library.\n\n  \\par Header File:\n  clBufferApi.h\n\n  \\par Parameters:\n  \\param pConfig This should contain the pool configuration to be used by\n  the Buffer library. If NULL is passed then the default pool configuration\n  will be used.\n\n  \\retval CL_OK The API executed successfully.\n  \\retval CL_ERR_NO_MEMORY On memory allocation failure.\n  \\retval CL_ERR_INITIALIZED If the Buffer Management library is already initialized.\n\n  \\par Description:\n  This API is used to initialize the Buffer Management library. It must be\n  called before calling any other Buffer library APIs. Since Buffer\n  library uses OpenClovis OSAL APIs, the OSAL library should be initialized\n  before intializing the Buffer library.\n\n  \\par Library Files:\n  ClBuffer\n\n  \\sa clBufferFinalize()\n"]
    pub fn clBufferInitialize(pConfig: *const ClBufferPoolConfigT) -> ClRcT;
}
extern "C" {
    #[doc = "  \\brief Cleans up the Buffer Management library.\n\n  \\par Header File:\n  clBufferApi.h\n\n  \\par Parameters:\n   None\n\n  \\retval CL_OK The API executed successfully.\n  \\retval CL_ERR_NOT_INITIALIZED If Buffer Management library is not initialized.\n\n  \\par Description:\n  This API is should be called when an application decides of not using the\n  buffer management library any more. The application must have invoked\n  clBufferInitialize() before it invokes this function. It is called typically\n  when an application calling this function is shutting down and wants to\n  releave all the resources used by it.\n\n  \\par Library Files:\n\t ClBuffer\n\n  \\sa clBufferInitialize()\n"]
    pub fn clBufferFinalize() -> ClRcT;
}
extern "C" {
    #[doc = "  \\brief Creates a new message.\n\n  \\par Header File:\n  clBufferApi.h\n\n  \\param pMessageHandle (out) A pointer to the handle of type \\e ClBufferHandleT\n  designating the buffer for a message created.\n\n  \\retval CL_OK The API successfully created a buffer for a message.\n  \\retval CL_ERR_NULL_POINTER On passing a NULL pointer.\n  \\retval CL_ERR_NO_MEMORY On memory allocation failure.\n  \\retval CL_ERR_NOT_INITIALIZED If Buffer Management library is not initialized.\n\n  \\par Description:\n  This API is used to create a buffer for a message. It allocates a buffer\n  of 2 kilobytes size, even if a write operation on the buffer is to be\n  performed at a later stage in the application. The write operation\n  on the buffer handle provided by this API, the buffer management library\n  will use this pre-allocated buffer.\n\n  \\par Library Files:\n\t ClBuffer\n\n  \\sa clBufferCreateAndAllocate(), clBufferDelete(), clBufferClear()"]
    pub fn clBufferCreate(pMessageHandle: *mut ClBufferHandleT) -> ClRcT;
}
extern "C" {
    #[doc = "  \\brief Creates buffers for a requested size of a message.\n\n  \\par Header File:\n  clBufferApi.h\n\n  \\param size Initial size of a message buffer in bytes.\n  \\param pMessageHandle A pointer to the buffer message of type\n  \\e ClBufferHandleT designating the message buffer created.\n\n  \\retval CL_OK The buffers for a message are successfully created.\n  \\retval CL_ERR_NULL_POINTER On passing a NULL pointer.\n  \\retval CL_ERR_NO_MEMORY On memory allocation failure.\n  \\retval CL_ERR_NOT_INITIALIZED If Buffer Management library is not initialized.\n\n  \\par Description:\n  This API is used to create buffers to hold a message of size mentioned by\n  \\e size. It allocates the buffers even if the write operation is to be\n  performed at a later stage in application. As a write is performed onto\n  this buffer handle returned by this API, the buffer management library\n  will use these pre-allocated buffers.\n\n  \\par Library Files:\n\t ClBuffer\n\n  \\sa clBufferDelete(), clBufferClear(), clBufferCreate()\n"]
    pub fn clBufferCreateAndAllocate(
        size: ClUint32T,
        pMessageHandle: *mut ClBufferHandleT,
    ) -> ClRcT;
}
extern "C" {
    #[doc = "  \\brief Deletes the Buffers.\n\n  \\par Header File:\n  clBufferApi.h\n\n  \\param pMessageHandle Pointer to the message handle, which is to be deleted.\n\n  \\retval CL_OK The Buffers are deleted successfully.\n  \\retval CL_ERR_NULL_POINTER On passing a NULL pointer.\n  \\retval CL_ERR_INVALID_HANDLE On passing an invalid handle.\n  \\retval CL_ERR_NOT_INITIALIZED If Buffer Management library is not initialized.\n\n  \\par Description:\n  This API is used to delete message buffer(s) designated by the handle\n  obtained through \\e clBufferCreate() API. Successful invocation of this\n  API will make the handle invalid.\n\n  \\par Library Files:\n\t ClBuffer\n\n  \\sa clBufferClear(), clBufferCreateAndAllocate(), clBufferCreate()\n"]
    pub fn clBufferDelete(pMessageHandle: *mut ClBufferHandleT) -> ClRcT;
}
extern "C" {
    #[doc = "  \\brief Deletes the content of the buffer message.\n\n  \\par Header File:\n  clBufferApi.h\n\n  \\param pMessageHandle Pointer to the message handle returned by \\e clBufferCreate() API.\n\n  \\retval CL_OK The buffer message is cleared successfully.\n  \\retval CL_ERR_NULL_POINTER On passing a NULL pointer.\n  \\retval CL_ERR_INVALID_HANDLE On passing an invalid handle.\n  \\retval CL_ERR_NOT_INITIALIZED If Buffer Management library is not initialized.\n\n  \\par Description:\n  This API is used to delete message buffer(s) designated by the handle\n  obtained through \\e clBufferCreate() API.\n  The handle is still available for re-use.\n\n  \\par Library Files:\n\t ClBuffer\n\n  \\sa clBufferDelete(), clBufferCreateAndAllocate(), clBufferCreate()\n"]
    pub fn clBufferClear(messageHandle: ClBufferHandleT) -> ClRcT;
}
extern "C" {
    #[doc = "  \\brief Returns the length of the message.\n\n  \\par Header File:\n  clBufferApi.h\n\n  \\param messageHandle Handle to the message returned by \\e clBufferCreate() API.\n  \\param pMessageLength (out) Pointer to a variable of type \\e ClUint32T,\n  in which the total length of the message is returned.\n\n  \\retval CL_OK The API executed successfully.\n  \\retval CL_ERR_NULL_POINTER On passing a NULL pointer.\n  \\retval CL_ERR_INVALID_HANDLE On passing an invalid handle.\n  \\retval CL_ERR_NOT_INITIALIZED If Buffer Management library is not initialized.\n\n  \\par Description:\n  This API is used to retrieve the total length of the message. There is no\n  impact on the read and write offset of the message even on subsequent\n  invocation of this API.\n\n  \\par Library Files:\n\t ClBuffer\n\n  \\sa clBufferCreate(), clBufferNBytesWrite()\n"]
    pub fn clBufferLengthGet(
        messageHandle: ClBufferHandleT,
        pMessageLength: *mut ClUint32T,
    ) -> ClRcT;
}
extern "C" {
    #[doc = "  \\brief Recompute the message length & set internal variable\n\n  \\param messageHandle Handle to the message returned by \\e clBufferCreate() API.\n\n  \\retval CL_OK The API executed successfully.\n  \\retval CL_ERR_NULL_POINTER On passing a NULL pointer.\n  \\retval CL_ERR_INVALID_HANDLE On passing an invalid handle.\n  \\retval CL_ERR_NOT_INITIALIZED If Buffer Management library is not initialized.\n\n  \\par Description:\n  This API is used to recompute the total message length, to be used if another entity (IOC)\n  fools with the buffers.\n\n  \\par Library Files:\n\t ClBuffer\n\n"]
    pub fn clBufferLengthCalc(bufferHandle: ClBufferHandleT) -> ClRcT;
}
extern "C" {
    #[doc = "  \\brief Reads the specified number of bytes of data from a message.\n\n  \\par Header File:\n  clBufferApi.h\n\n  \\param messageHandle Handle to the message returned by \\e clBufferCreate() API.\n  \\param pByteBuffer Pointer to a stream of memory of type \\e ClUint8T*, in which *pNumberOfBytesToRead of the read data is returned. Memory allocation and deallocation for this parameter must be done by the caller.\n  \\param pNumberOfBytesToRead Pointer to variable of type \\e ClUint32T, which contains number of bytes of data to be read. And the number of bytes of data that has been successfully read is returned in this parameter.\n\n  \\retval CL_OK The API executed successfully.\n  \\retval CL_ERR_NULL_POINTER On passing a NULL pointer.\n  \\retval CL_ERR_INVALID_HANDLE On passing an invalid handle.\n  \\retval CL_ERR_NOT_INITIALIZED If Buffer Management library is not initialized.\n\n  \\par Description:\n  This API is used to read \\e *pNumberOfBytesToRead number of bytes of data\n  from a buffer message pointed by \\e messageHandle, starting from the\n  where the last read has stopped at in that buffer message. If the buffer\n  doesnt contain \\e *pNumberOfBytesToRead number of bytes of data then\n  \\e *pNumberOfBytesToRead parameter will be updated with actually read number of\n  bytes. The current read offset(or pointer), is automatically updated by\n  \\e *pNumberOfBytesToRead bytes after every read, so that the next read\n  operation starts from the point where this read has left at.\n\n  \\par Library Files:\n\t ClBuffer\n\n  \\sa clBufferClear(), clBufferNBytesWrite(), clBufferCreate()\n"]
    pub fn clBufferNBytesRead(
        messageHandle: ClBufferHandleT,
        pByteBuffer: *mut ClUint8T,
        pNumberOfBytesToRead: *mut ClUint32T,
    ) -> ClRcT;
}
extern "C" {
    #[doc = "  \\brief Writes the specified number bytes of data from a message.\n\n  \\par Header File:\n  clBufferApi.h\n\n  \\param messageHandle Handle to the message returned by \\e clBufferCreate() API\n  into which n bytes of data is to be written.\n  \\param pByteBuffer Pointer to the byte buffer from which \\e numberOfBytesToWrite bytes are to be written into the buffer message.\n  \\param numberOfBytesToWrite Number of bytes to be written.\n\n  \\retval CL_OK The API executed successfully.\n  \\retval CL_ERR_NULL_POINTER On passing a NULL pointer.\n  \\retval CL_ERR_INVALID_HANDLE On passing an invalid handle.\n  \\retval CL_ERR_NOT_INITIALIZED If Buffer Management library is not initialized.\n\n  \\par Description:\n  This API is used to write n bytes of data into the message referred by the\n  message handle, starting from the current write offset. While writing data\n  to a buffer message if the buffer gets full then a new buffer will be\n  allocated automatically and then the write continues into that buffer. The\n  write offset is automatically updated by \\e numberOfBytesToWrite bytes\n  after every write, so that the next write can continue from the point\n  where this write ended at.\n\n  \\par Library Files:\n\t ClBuffer\n\n  \\sa clBufferClear(), clBufferNBytesRead(), clBufferCreate()\n"]
    pub fn clBufferNBytesWrite(
        messageHandle: ClBufferHandleT,
        pByteBuffer: *mut ClUint8T,
        numberOfBytesToWrite: ClUint32T,
    ) -> ClRcT;
}
extern "C" {
    #[doc = "  \\brief Computes a 16-bit checksum on a message.\n\n  \\par Header File:\n  clBufferApi.h\n\n  \\param messageHandle Handle to the message returned by \\e clBufferCreate() API for which the checksum is to be computed.\n  \\param startOffset Offset from the beginning of the message, from which the data for computing the checksum begins.\n  \\param length Number of bytes of data for which the checksum is to be computed.\n  \\param pChecksum (out) Pointer to variable of type \\e ClUint32T in which the computed checksum is returned.\n\n  \\retval CL_OK The API executed successfully.\n  \\retval CL_ERR_NULL_POINTER On passing a NULL pointer.\n  \\retval CL_ERR_INVALID_HANDLE On passing an invalid handle.\n  \\retval CL_ERR_NOT_INITIALIZED If Buffer Management library is not initialized.\n\n  \\par Description:\n  This API is used to compute a 16-bit checksum on a message from\n  \\e startOffset for \\e length number of bytes in the message. This checksum\n  can be used to check the validity of the buffer message after passing it\n  through a network.\n\n  \\par Library Files:\n\t ClBuffer\n\n  \\sa clBufferCreate(), clBufferChecksum32Compute()\n"]
    pub fn clBufferChecksum16Compute(
        messageHandle: ClBufferHandleT,
        startOffset: ClUint32T,
        length: ClUint32T,
        pChecksum: *mut ClUint16T,
    ) -> ClRcT;
}
extern "C" {
    #[doc = "  \\brief Computes a 32-bit checksum on a message.\n\n  \\par Header File:\n  clBufferApi.h\n\n  \\param messageHandle Handle to the message returned by \\e clBufferCreate() API for which the checksum is to be computed.\n  \\param startOffset Offset from the beginning of the message, from which the data for computing the checksum begins.\n  \\param length Number of bytes of data for which the checksum is to be computed.\n  \\param pChecksum (out) Pointer to variable of type \\e ClUint32T in which the computed checksum is returned.\n\n  \\retval CL_OK The API executed successfully.\n  \\retval CL_ERR_NULL_POINTER On passing a NULL pointer.\n  \\retval CL_ERR_INVALID_HANDLE On passing an invalid handle.\n  \\retval CL_ERR_NOT_INITIALIZED If Buffer Management library is not initialized.\n\n  \\par Description:\n  This API is used to compute a 32-bit checksum on a message from\n  \\e startOffset for \\e length number of bytes in the message. This checksum\n  can be used to check the validity of the buffer message after passing it\n  through a network.\n\n  \\par Library Files:\n\t ClBuffer\n\n  \\sa clBufferCreate(), clBufferChecksum16Compute()\n"]
    pub fn clBufferChecksum32Compute(
        messageHandle: ClBufferHandleT,
        startOffset: ClUint32T,
        length: ClUint32T,
        pChecksum: *mut ClUint32T,
    ) -> ClRcT;
}
extern "C" {
    #[doc = "  \\brief Prepends specified number of bytes at the begining of message.\n\n  \\par Header File:\n  clBufferApi.h\n\n  \\param messageHandle Handle to the message returned by \\e clBufferCreate() API.\n  \\param pByteBuffer Pointer to a variable of type \\e ClUint8T, in which \\e numberOfBytesToRead bytes of data is returned.\n  \\param numberOfBytesToWrite Number of bytes to be written.\n\n  \\retval CL_OK The API executed successfully.\n  \\retval CL_ERR_NULL_POINTER On passing a NULL pointer.\n  \\retval CL_ERR_INVALID_HANDLE On passing an invalid handle.\n  \\retval CL_ERR_NOT_INITIALIZED If Buffer Management library is not initialized.\n\n  \\par Description:\n  This API is used to prepend \\e numberOfBytesToWrite number of bytes at\n  the beginning of the buffer message. The write offset of the buffer\n  message will be updated and is set to \\e numberOfBytesToWrite, i.e. the\n  next write-operation performed will begin the write at\n  \\e numberOfBytesToWrite offset from the starting of the message.\n  Note that the current write offset is lost. Hence, it is advisable to\n  preserve the write offset before invoking this API.\n\n  \\par Library Files:\n\t ClBuffer\n\n  \\sa clBufferNBytesWrite(), clBufferConcatenate(), clBufferDelete()\n"]
    pub fn clBufferDataPrepend(
        messageHandle: ClBufferHandleT,
        pByteBuffer: *mut ClUint8T,
        numberOfBytesToWrite: ClUint32T,
    ) -> ClRcT;
}
extern "C" {
    #[doc = "  \\brief Concatenates source message to destination message.\n\n  \\par Header File:\n  clBufferApi.h\n\n  \\param destination This is buffer message handle to which the \\e pSource buffer message will be concatinated. The handle of the concatenated message will be the same \\e destination buffer message handle .\n  \\param pSource (in/out) Pointer to buffer message handle of the message, which is to be concatenated with \\e destination buffer message.\n\n  \\retval CL_OK The API executed successfully.\n  \\retval CL_ERR_NULL_POINTER On passing a NULL pointer.\n  \\retval CL_ERR_INVALID_HANDLE On passing an invalid handle.\n  \\retval CL_ERR_NOT_INITIALIZED If Buffer Management library is not initialized.\n\n  \\par Description:\n  This API is used to concatenate the \\e pSource buffer message to the end\n  of \\e destination message. The \\e pSource message handle will become\n  not-usable after this concatination operation and the \\e pSource message\n  will be deleted. The write offset of the resultant \\e destination\n  message will be set to end of the message and the read offset of the to\n  start of the message.\n\n  \\par Library Files:\n\t ClBuffer\n\n  \\sa clBufferCreate(), clBufferDataAppend(),\n      clBufferDelete(), clBufferDataPrepend()\n"]
    pub fn clBufferConcatenate(
        destination: ClBufferHandleT,
        pSource: *mut ClBufferHandleT,
    ) -> ClRcT;
}
extern "C" {
    #[doc = "  \\brief Returns current read offset of the message.\n\n  \\par Header File:\n  clBufferApi.h\n\n  \\param messageHandle Handle to the message returned by \\e clBufferCreate() API.\n  \\param pReadOffset Pointer to a variable of type \\e ClUint32T, in which the current read offset is returned.\n\n  \\retval CL_OK The API executed successfully.\n  \\retval CL_ERR_NULL_POINTER On passing a NULL pointer.\n  \\retval CL_ERR_INVALID_HANDLE On passing an invalid handle.\n  \\retval CL_ERR_NOT_INITIALIZED If Buffer Management library is not initialized.\n\n  \\par Description:\n  This API is used to retrieve the current read offset of the buffer message.\n  This offset is updated on invoking the clBufferNBytesRead() API or it can\n  be set using clBufferReadOffsetSet().\n\n  \\par Library Files:\n\t ClBuffer\n\n  \\sa\n  clBufferCreate(), clBufferWriteOffsetGet()\n  clBufferDelete(), clBufferReadOffsetSet()\n  clBufferWriteOffsetSet(), clBufferTrailerTrim()\n  clBufferHeaderTrim(), clBufferNBytesRead()\n"]
    pub fn clBufferReadOffsetGet(
        messageHandle: ClBufferHandleT,
        pReadOffset: *mut ClUint32T,
    ) -> ClRcT;
}
extern "C" {
    #[doc = "  \\brief Returns current write offset of the message.\n\n  \\par Header File:\n  clBufferApi.h\n\n  \\param messageHandle Handle to the message returned by \\e clBufferCreate API\n  \\param pWriteOffset Pointer to a variable of type \\e ClUint32T, in which the current write offset is returned.\n\n  \\retval CL_OK The API executed successfully.\n  \\retval CL_ERR_NULL_POINTER On passing a NULL pointer.\n  \\retval CL_ERR_INVALID_HANDLE On passing an invalid handle.\n  \\retval CL_ERR_NOT_INITIALIZED If Buffer Management library is not initialized.\n\n  \\par Description:\n  This API is used to retrieve the current write offset of the message. This\n  offset is updated on invoking the clBufferNBytesWrite() API or\n  directly through clBufferWriteOffsetSet().\n\n  \\par Library Files:\n\t ClBuffer\n\n  \\sa\n  clBufferCreate(), clBufferReadOffsetGet(),\n  clBufferDelete(), clBufferReadOffsetSet(),\n  clBufferWriteOffsetSet(), clBufferTrailerTrim(),\n  clBufferHeaderTrim()\n"]
    pub fn clBufferWriteOffsetGet(
        messageHandle: ClBufferHandleT,
        pWriteOffset: *mut ClUint32T,
    ) -> ClRcT;
}
extern "C" {
    #[doc = "  \\brief Sets current read offset of the message.\n\n  \\par Header File:\n  clBufferApi.h\n\n  \\param messageHandle Handle to the message returned by clBufferCreate() API\n  \\param seekType This parameter accepts the following values:\n  \\arg \\c CL_BUFFER_SEEK_SET: The read offset should be set to a position from the beginning of the message.\n  \\arg \\c CL_BUFFER_SEEK_CUR: The read offset should be set to a position from its current location.\n  \\arg \\c CL_BUFFER_SEEK_END: The read offset should be set to a position from the the end of the message.\n  \\param newReadOffset The offset at which the current read offset is to be set.\n  If \\e seekType is set to CL_BUFFER_SEEK_SET then the value of\n  \\e newReadOffset should be 0 or greater, for CL_BUFFER_SEEK_CUR it can be\n  a positive of negative number and for CL_BUFFER_END it should be 0 or a negative number.\n\n\n  \\retval CL_OK The API executed successfully.\n  \\retval CL_ERR_NULL_POINTER On passing a NULL pointer.\n  \\retval CL_ERR_INVALID_HANDLE On passing an invalid handle.\n  \\retval CL_ERR_NOT_INITIALIZED If Buffer Management library is not initialized.\n  \\retval CL_ERR_INVALID_PARAMETER On passing an invalid parameter.\n\n  \\par Description:\n  This API is used to set the read offset of the buffer message pointed by\n  the \\e messageHandle. This is used, when an application wants to read the\n  data from the buffer message from a specific point onwards. This\n  offset is also automatically updated on invoking the clBufferNBytesRead().\n\n  \\par Library Files:\n\t ClBuffer\n\n  \\sa\n  clBufferCreate(), clBufferWriteOffsetGet(), clBufferDelete(),\n  clBufferWriteOffsetSet(), clBufferTrailerTrim(),\n  clBufferHeaderTrim(), clBufferNBytesRead()\n"]
    pub fn clBufferReadOffsetSet(
        messageHandle: ClBufferHandleT,
        newReadOffset: ClInt32T,
        seekType: ClBufferSeekTypeT,
    ) -> ClRcT;
}
extern "C" {
    #[doc = "  \\brief Sets current write offset of the message.\n\n  \\par Header File:\n  clBufferApi.h\n\n  \\param messageHandle Handle to the message returned by clBufferCreate() API.\n  \\param seekType This parameter can accept the following values:\n  \\arg \\c CL_BUFFER_SEEK_SET: The write offset should be set to a position from the beginning of the message.\n  \\arg \\c CL_BUFFER_SEEK_CUR: The write offset should be set to a position from its current location.\n  \\arg \\c CL_BUFFER_SEEK_END: The write offset should be set to a position from the the end of the message.\n  \\param newWriteOffset The offset at which the current write offset is to be set.\n  If \\e seekType is set to CL_BUFFER_SEEK_SET then the value of\n  \\e newWriteOffset should be 0 or greater, for CL_BUFFER_SEEK_CUR it can be\n  a positive of negative number and for CL_BUFFER_END it should be 0 or a negative number.\n\n  \\retval CL_OK The API executed successfully.\n  \\retval CL_ERR_NULL_POINTER On passing a NULL pointer.\n  \\retval CL_ERR_INVALID_HANDLE On passing an invalid handle.\n  \\retval CL_ERR_NOT_INITIALIZED If Buffer Management library is not initialized.\n  \\retval CL_ERR_INVALID_PARAMETER If an invalid parameter is passed.\n\n  \\par Description:\n  This API is used to set the current write offset of the buffer message\n  pointed by \\e messageHandle. The application wanting to write some data\n  to the buffer message starting at a perticular point in the buffer\n  message should set the buffer message's current write offset to that\n  point and then do the write operation. This offset is also\n  automatically updated on invoking the clBufferNBytesWrite().\n\n  \\par Library Files:\n\t ClBuffer\n\n  \\sa\n  clBufferCreate(), clBufferWriteOffsetGet(), clBufferDelete(),\n  clBufferReadOffsetSet(), clBufferTrailerTrim(),\n  clBufferHeaderTrim(), clBufferNBytesRead()\n"]
    pub fn clBufferWriteOffsetSet(
        messageHandle: ClBufferHandleT,
        newWriteOffset: ClInt32T,
        seekType: ClBufferSeekTypeT,
    ) -> ClRcT;
}
extern "C" {
    #[doc = "  \\brief Trims the start of the message.\n\n  \\par Header File:\n  clBufferApi.h\n\n  \\param messageHandle Handle to the message returned by \\e clBufferCreate() API.\n  \\param numberOfBytes Number of bytes to delete from the start of the message.\n\n  \\retval CL_OK The API executed successfully.\n  \\retval CL_ERR_NULL_POINTER On passing a NULL pointer.\n  \\retval CL_ERR_INVALID_HANDLE On passing an invalid handle.\n  \\retval CL_ERR_NOT_INITIALIZED If Buffer Management library is not initialized.\n  \\retval CL_ERR_INVALID_PARAMETER On passing an invalid parameter.\n\n  \\par Description:\n  This API is used to delete a specific number of bytes from the start of the\n  message pointed by \\e messageHandle. If the read/write offset is in the\n  region being deleted, the read/write offset will be set to 0, i.e, the\n  beginning of the message, after performing the trim operation.\n\n  \\par Library Files:\n\t ClBuffer\n\n  \\sa clBufferCreate(), clBufferHeaderTrim(), clBufferDelete()\n"]
    pub fn clBufferHeaderTrim(messageHandle: ClBufferHandleT, numberOfBytes: ClUint32T) -> ClRcT;
}
extern "C" {
    #[doc = "  \\brief Trims the tail of the message.\n\n  \\par Header File:\n  clBufferApi.h\n\n  \\param messageHandle Handle to the message returned by clBufferCreate() API.\n  \\param numberOfBytes Number of bytes to delete from the tail of the message.\n\n  \\retval CL_OK The API executed successfully.\n  \\retval CL_ERR_NULL_POINTER On passing a NULL pointer.\n  \\retval CL_ERR_INVALID_HANDLE On passing an invalid handle.\n  \\retval CL_ERR_NOT_INITIALIZED If Buffer Management library is not initialized.\n  \\retval CL_ERR_INVALID_PARAMETER On passing an invalid parameter.\n\n  \\par Description:\n  This API is used to delete a specific number of bytes from tail of the\n  message pointed by \\e messageHandle. If the read/write offset is in the\n  region being deleted, the read/write offset will be set to length of the\n  buffer message, i.e, the end of the message, after performing the\n  trim operation.\n\n  \\par Library Files:\n\t ClBuffer\n\n  \\sa clBufferCreate(), clBufferHeaderTrim(), clBufferDelete()\n"]
    pub fn clBufferTrailerTrim(messageHandle: ClBufferHandleT, numberOfBytes: ClUint32T) -> ClRcT;
}
extern "C" {
    #[doc = "  \\brief Copies specific number of bytes from one message to another.\n\n  \\par Header File:\n  clBufferApi.h\n\n  \\param sourceMessage Handle to the message returned by \\e clBufferCreate() API, from which data is to be copied.\n  \\param sourceMessageOffset Offset with respect to beginning of \\e sourceMessage, from where the copying is to begin.\n  \\param destinationMessage Handle to the message returned by \\e clBufferCreate() API, into which data is being copied.\n  \\param numberOfBytes Number of bytes to be copied from \\e sourceMessage to \\e destinationMessage.\n\n  \\retval CL_OK The API executed successfully.\n  \\retval CL_ERR_NULL_POINTER On passing a NULL pointer.\n  \\retval CL_ERR_INVALID_HANDLE On passing an invalid handle.\n  \\retval CL_ERR_NOT_INITIALIZED If Buffer Management library is not initialized.\n  \\retval CL_ERR_INVALID_PARAMETER On passing an invalid parameter.\n  \\retval CL_ERR_NO_MEMORY On memory allocation failure.\n\n  \\par Description:\n  This API is used to copy the \\e numberOfBytes bytes starting at\n  \\e sourceMessageOffset offset in \\e sourceMessage. The data will be copied\n  in \\e destinationMessage starting at write offset of the message.\n\n  \\par Library Files:\n\t ClBuffer\n\n  \\sa\n  clBufferCreate(), clBufferReadOffsetGet(), clBufferDelete(),\n  clBufferWriteOffsetGet(), clBufferToBufferCopy(),\n  clBufferDuplicate()\n"]
    pub fn clBufferToBufferCopy(
        sourceMessage: ClBufferHandleT,
        sourceMessageOffset: ClUint32T,
        destinationMessage: ClBufferHandleT,
        numberOfBytes: ClUint32T,
    ) -> ClRcT;
}
extern "C" {
    #[doc = "  \\brief Duplicates a message.\n\n  \\par Header File:\n  clBufferApi.h\n\n  \\param messageHandle Handle to the message returned by \\e clBufferCreate() API, which is to be duplicated.\n  \\param pDuplicatedMessage (out) Pointer to variable of type \\e ClBufferHandleT, in which handle of the duplicate\n  message is returned.\n\n  \\retval CL_OK The API executed successfully.\n  \\retval CL_ERR_NULL_POINTER On passing a NULL pointer.\n  \\retval CL_ERR_INVALID_HANDLE On passing an invalid handle.\n  \\retval CL_ERR_NOT_INITIALIZED If Buffer Management library is not initialized.\n  \\retval CL_ERR_INVALID_PARAMETER On passing an invalid parameter.\n  \\retval CL_ERR_NO_MEMORY On memory allocation failure.\n\n  \\par Description:\n  This API is used to make duplicate copy of \\e messageHandle. The newly\n  created buffer message handle will be returned in \\e pDuplicateMessage.\n  The read and write offsets of the newly created buffer message are set\n  to the values same as that of the \\e messageHandle.\n\n  \\par Library Files:\n\t ClBuffer\n\n  \\sa\n  clBufferCreate(), clBufferDelete(),\n  clBufferToBufferCopy()\n"]
    pub fn clBufferDuplicate(
        messageHandle: ClBufferHandleT,
        pDuplicatedMessage: *mut ClBufferHandleT,
    ) -> ClRcT;
}
extern "C" {
    pub fn clBufferClone(source: ClBufferHandleT, pClone: *mut ClBufferHandleT) -> ClRcT;
}
extern "C" {
    pub fn clBufferAppendHeap(
        source: ClBufferHandleT,
        buffer: *mut ClUint8T,
        size: ClUint32T,
    ) -> ClRcT;
}
extern "C" {
    #[doc = "  \\brief Flattens message into a single buffer.\n\n  \\par Header File:\n  clBufferApi.h\n\n  \\param messageHandle Handle to message returned by \\e clBufferCreate() API.\n  \\param ppFlattenBuffer (out) The flatten buffer would be returned in this location.\n  This must be a valid pointer and cannot be NULL.\n\n  \\retval CL_OK The API executed successfully.\n  \\retval CL_ERR_NULL_POINTER On passing a NULL pointer.\n  \\retval CL_ERR_INVALID_HANDLE On passing an invalid handle.\n  \\retval CL_ERR_NOT_INITIALIZED If Buffer Management library is not initialized.\n  \\retval CL_ERR_NO_MEMORY On memory allocation failure.\n\n  \\par Description:\n  This API is used to copy the message from a buffer message into a single flat buffer stream. The buffer library will allocate the memory for the flat buffer stream and this has to be freed by the caller of this API.\n\n  \\par Library Files:\n  ClBuffer\n\n  \\sa clBufferCreate(), clBufferDelete()\n"]
    pub fn clBufferFlatten(
        messageHandle: ClBufferHandleT,
        ppFlattenBuffer: *mut *mut ClUint8T,
    ) -> ClRcT;
}
extern "C" {
    #[doc = "  \\brief Copies message from user-space to kernel-space.\n\n  \\par Header File:\n  clBufferApi.h\n\n  \\note\n  This API is available only inside the kernel. It cannot be invoked from the user-space.\n\n  \\param userMessageHandle Handle to message returned by \\e clBufferCreate() API, which is to be copied into kernel\n  space.\n  \\param pKernelMessageHandle (out) Pointer to variable of type \\e ClBufferHandleT, in which the handle to\n  message in the kernel space is returned.\n\n  \\retval CL_OK The API executed successfully.\n  \\retval CL_ERR_NULL_POINTER On passing a NULL pointer.\n  \\retval CL_ERR_INVALID_HANDLE On passing an invalid handle.\n  \\retval CL_ERR_NOT_INITIALIZED If Buffer Management library is not initialized.\n  \\retval CL_ERR_NO_MEMORY On memory allocation failure.\n\n  \\par Description:\n  This API is used to copy a message from user-space to kernel-space. The kernel\n  space message will be created by the Buffer Management Library and the handle to\n  created message will be returned. Write offset would be set to the end and read offset\n  would point to the beginning of the kernel space message.\n\n  \\par Library Files:\n\t ClBuffer\n\n  \\sa\n  clBufferCreate(), clBufferDelete(), clBufferKernelToUserCopy()\n"]
    pub fn clBufferUserToKernelCopy(
        userMessageHandle: ClBufferHandleT,
        pKernelMessageHandle: *mut ClBufferHandleT,
    ) -> ClRcT;
}
extern "C" {
    #[doc = "  \\brief Copies message from kernel-space to user-space.\n\n  \\par Header File:\n  clBufferApi.h\n\n  \\note\n  This API is available only inside the kernel. It cannot be invoked from the user-space.\n\n  \\param kernelMessageHandle Handle to kernel-space message returned by \\e clBufferCreate()\n  API, from which data is to be copied into user-space message.\n\n  \\param userMessageHandle Handle to user-space message returned by \\e clBufferCreate()\n  API,into which data is to be copied from kernel-space message.\n\n  \\retval CL_OK The API executed successfully.\n  \\retval CL_ERR_NULL_POINTER On passing a NULL pointer.\n  \\retval CL_ERR_INVALID_HANDLE On passing an invalid handle.\n  \\retval CL_ERR_NOT_INITIALIZED If Buffer Management library is not initialized.\n  \\retval CL_ERR_NO_MEMORY On memory allocation failure.\n\n  \\par Description:\n  This API is used to copy a message from kernel-space to user-space. The user-space\n  message must be created in user space. The contents of the kernel-space\n  message will be copied into the user-space message.Write offset would be set to the end\n  and read offset would point to the beginning of the user-space message.\n\n  \\par Library Files:\n\t ClBuffer\n\n  \\sa clBufferCreate(), clBufferDelete(), clBufferUserToKernelCopy()\n"]
    pub fn clBufferKernelToUserCopy(
        kernelMessageHandle: ClBufferHandleT,
        userMessageHandle: ClBufferHandleT,
    ) -> ClRcT;
}
extern "C" {
    #[doc = "  \\brief Frees up the unused pools of all sizes.\n\n  \\par Header File:\n  clBufferApi.h\n\n  \\param pShrinkOptions This is pointer to the shrik option parameter of\n  type ClPoolShrinkOptionsT. The values that can be passed are\n  \\arg CL_POOL_SHRINK_DEFAULT: This option will free half of total unused pools.\n  \\arg CL_POOL_SHRINK_ONE: This option will free only one pool of all the unused pools.\n  \\arg CL_POOL_SHRINK_ALL: This option will free all the unused pools.\n\n  \\retval CL_OK The API executed successfully.\n  \\retval CL_ERR_NOT_INITIALIZED If Buffer Management library is not initialized.\n\n  \\par Description:\n  This API is used to free the unused pools. The new pools of a size get\n  allocated when there is shortage of space for creating new buffer messages.\n  And after using the buffer messages they will be freed using\n  clBufferDelete(), but the pool remains. So these pools are required to be\n  freed up at times.\n\n  \\par Library Files:\n\t ClBuffer\n\n  \\sa clBufferCreate(), clBufferDelete()\n"]
    pub fn clBufferShrink(pShrinkOptions: *mut ClPoolShrinkOptionsT) -> ClRcT;
}
extern "C" {
    #[doc = " \\brief Dumps the buffer for debugging, etc"]
    pub fn clDbgBufferPrint(buffer: ClBufferHandleT) -> ClRcT;
}
extern "C" {
    pub fn clBufferStatsGet(pBufferStats: *mut ClMemStatsT) -> ClRcT;
}
extern "C" {
    pub fn clBufferPoolStatsGet(
        numPools: ClUint32T,
        pPoolSize: *mut ClUint32T,
        pBufferPoolStats: *mut ClPoolStatsT,
    ) -> ClRcT;
}
extern "C" {
    pub fn clBufferVectorize(
        buffer: ClBufferHandleT,
        ppIOVector: *mut *mut iovec,
        pNumVectors: *mut ClInt32T,
    ) -> ClRcT;
}
pub type ClBufferMessageHandleT = ClBufferHandleT;
extern "C" {
    pub fn clBufferMessageCreate(pMessageHandle: *mut ClBufferHandleT) -> ClRcT;
}
extern "C" {
    pub fn clBufferMessageCreateAndAllocate(
        size: ClUint32T,
        pMessageHandle: *mut ClBufferHandleT,
    ) -> ClRcT;
}
extern "C" {
    pub fn clBufferMessageDelete(pMessageHandle: *mut ClBufferHandleT) -> ClRcT;
}
extern "C" {
    pub fn clBufferMessageClear(messageHandle: ClBufferHandleT) -> ClRcT;
}
extern "C" {
    pub fn clBufferMessageLengthGet(
        messageHandle: ClBufferHandleT,
        pMessageLength: *mut ClUint32T,
    ) -> ClRcT;
}
extern "C" {
    pub fn clBufferMessageNBytesRead(
        messageHandle: ClBufferHandleT,
        pByteBuffer: *mut ClUint8T,
        pNumberOfBytesToRead: *mut ClUint32T,
    ) -> ClRcT;
}
extern "C" {
    pub fn clBufferMessageNBytesWrite(
        messageHandle: ClBufferHandleT,
        pByteBuffer: *mut ClUint8T,
        numberOfBytesToWrite: ClUint32T,
    ) -> ClRcT;
}
extern "C" {
    pub fn clBufferMessageDataPrepend(
        messageHandle: ClBufferHandleT,
        pByteBuffer: *mut ClUint8T,
        numberOfBytesToWrite: ClUint32T,
    ) -> ClRcT;
}
extern "C" {
    pub fn clBufferMessageConcatenate(
        destination: ClBufferHandleT,
        pSource: *mut ClBufferHandleT,
    ) -> ClRcT;
}
extern "C" {
    pub fn clBufferMessageReadOffsetGet(
        messageHandle: ClBufferHandleT,
        pReadOffset: *mut ClUint32T,
    ) -> ClRcT;
}
extern "C" {
    pub fn clBufferMessageWriteOffsetGet(
        messageHandle: ClBufferHandleT,
        pWriteOffset: *mut ClUint32T,
    ) -> ClRcT;
}
extern "C" {
    pub fn clBufferMessageReadOffsetSet(
        messageHandle: ClBufferHandleT,
        newReadOffset: ClInt32T,
        seekType: ClBufferSeekTypeT,
    ) -> ClRcT;
}
extern "C" {
    pub fn clBufferMessageWriteOffsetSet(
        messageHandle: ClBufferHandleT,
        newWriteOffset: ClInt32T,
        seekType: ClBufferSeekTypeT,
    ) -> ClRcT;
}
extern "C" {
    pub fn clBufferMessageHeaderTrim(
        messageHandle: ClBufferHandleT,
        numberOfBytes: ClUint32T,
    ) -> ClRcT;
}
extern "C" {
    pub fn clBufferMessageTrailerTrim(
        messageHandle: ClBufferHandleT,
        numberOfBytes: ClUint32T,
    ) -> ClRcT;
}
extern "C" {
    pub fn clBufferMessageToMessageCopy(
        source: ClBufferHandleT,
        sourceOffset: ClUint32T,
        destination: ClBufferHandleT,
        numberOfBytes: ClUint32T,
    ) -> ClRcT;
}
extern "C" {
    pub fn clBufferMessageDuplicate(
        source: ClBufferHandleT,
        pDuplicate: *mut ClBufferHandleT,
    ) -> ClRcT;
}
