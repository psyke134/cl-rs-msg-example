pub use crate::clBindings::clCommon::*;
pub use crate::clBindings::clBufferApi::*;
pub use crate::clBindings::clIocServices::*;
pub use crate::clBindings::clIocProtocols::*;
pub use crate::clBindings::clIocErrors::*;
/* automatically generated by rust-bindgen 0.66.1 */

#[repr(C)]
pub struct __BindgenUnionField<T>(::std::marker::PhantomData<T>);
impl<T> __BindgenUnionField<T> {
    #[inline]
    pub const fn new() -> Self {
        __BindgenUnionField(::std::marker::PhantomData)
    }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T {
        ::std::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T {
        ::std::mem::transmute(self)
    }
}
impl<T> ::std::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self {
        Self::new()
    }
}
impl<T> ::std::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self {
        Self::new()
    }
}
impl<T> ::std::marker::Copy for __BindgenUnionField<T> {}
impl<T> ::std::fmt::Debug for __BindgenUnionField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.write_str("__BindgenUnionField")
    }
}
impl<T> ::std::hash::Hash for __BindgenUnionField<T> {
    fn hash<H: ::std::hash::Hasher>(&self, _state: &mut H) {}
}
impl<T> ::std::cmp::PartialEq for __BindgenUnionField<T> {
    fn eq(&self, _other: &__BindgenUnionField<T>) -> bool {
        true
    }
}
impl<T> ::std::cmp::Eq for __BindgenUnionField<T> {}
pub const CL_IOC_HEADER_VERSION: u32 = 1;
pub const CL_IOC_NOTIFICATION_VERSION: u32 = 1;
pub const CL_IOC_TIMEOUT_FOREVER: i32 = -1;
pub const CL_IOC_RECEIVE_TIMEOUT: u32 = 1500;
pub const CL_IOC_UNRELIABLE_MESSAGING: u32 = 0;
pub const CL_IOC_RELIABLE_MESSAGING: u32 = 1;
pub const CL_IOC_NODE_UP: u32 = 1;
pub const CL_IOC_NODE_DOWN: u32 = 0;
pub const CL_IOC_LINK_UP: u32 = 2;
pub const CL_IOC_LINK_DOWN: u32 = 3;
pub const CL_IOC_BROADCAST_ADDRESS: u32 = 4294967295;
pub const CL_IOC_RESERVED_ADDRESS: u32 = 0;
pub const CL_IOC_GEO_ADDR_MAX_LENGTH: u32 = 128;
pub const CL_IOC_PHYSICAL_ADDRESS_TYPE: u32 = 0;
pub const CL_IOC_LOGICAL_ADDRESS_TYPE: u32 = 1;
pub const CL_IOC_MULTICAST_ADDRESS_TYPE: u32 = 2;
pub const CL_IOC_MASTER_ADDRESS_TYPE: u32 = 3;
pub const CL_IOC_INTRANODE_ADDRESS_TYPE: u32 = 4;
pub const CL_IOC_USER_ADDRESS_TYPE: u32 = 10;
pub const CL_IOC_BROADCAST_ADDRESS_TYPE: u32 = 255;
pub const CL_IOC_ADDRESS_TYPE_BITS: u32 = 8;
pub const CL_IOC_ADDRESS_TYPE_MASK: u32 = 255;
pub const CL_IOC_NODE_MASK: i32 = -1;
pub const CL_IOC_ADDRESS_TYPE_SHIFT_WORD: u32 = 24;
pub const CL_IOC_ADDRESS_TYPE_SHIFT_DWORD: u32 = 56;
pub const CL_IOC_TL_ACTIVE: u32 = 0;
pub const CL_IOC_TL_STDBY: u32 = 1;
pub const CL_IOC_TL_NO_REPLICATION: u32 = 0;
#[doc = " This is the default priority. This tells the IOC to use the lowest priority for sending the packet."]
pub const ClIocPriorityT_CL_IOC_DEFAULT_PRIORITY: ClIocPriorityT = 0;
#[doc = " This is the higest priority with which a packet can be sent."]
pub const ClIocPriorityT_CL_IOC_HIGH_PRIORITY: ClIocPriorityT = 1;
#[doc = " This is the lowest priority. The packets sent with this priority might get rejected if there is congestion on the transports."]
pub const ClIocPriorityT_CL_IOC_LOW_PRIORITY: ClIocPriorityT = 2;
#[doc = " This is the lowest priority. The packets sent with this priority might get rejected if there is congestion on the transports."]
pub const ClIocPriorityT_CL_IOC_ORDERED_PRIORITY: ClIocPriorityT = 3;
#[doc = " This is the lowest priority. The packets sent with this priority might get rejected if there is congestion on the transports."]
pub const ClIocPriorityT_CL_IOC_NOTIFICATION_PRIORITY: ClIocPriorityT = 4;
#[doc = " This is reserved by IOC for future use."]
pub const ClIocPriorityT_CL_IOC_RESERVED_PRIORITY: ClIocPriorityT = 5;
#[doc = " This is reserved by IOC for future use."]
pub const ClIocPriorityT_CL_IOC_RESERVED_PRIORITY_USER: ClIocPriorityT = 6;
#[doc = " This is reserved by IOC for future use."]
pub const ClIocPriorityT_CL_IOC_RESERVED_PRIORITY_USER_END: ClIocPriorityT = 16;
#[doc = " This limits the use of the number of priorities that can be used with IOC."]
pub const ClIocPriorityT_CL_IOC_MAX_PRIORITIES: ClIocPriorityT = 17;
#[doc = " This defines all the priorities that can be used with IOC."]
pub type ClIocPriorityT = ::std::os::raw::c_uint;
#[doc = " Disables component/node arrival/departure notifications."]
pub const ClIocNotificationActionT_CL_IOC_NOTIFICATION_DISABLE: ClIocNotificationActionT = 0;
#[doc = " Enable scomponent/node arrival/departure notifications."]
pub const ClIocNotificationActionT_CL_IOC_NOTIFICATION_ENABLE: ClIocNotificationActionT = 1;
#[doc = " This defines all notification related actions that can be performed on a port."]
pub type ClIocNotificationActionT = ::std::os::raw::c_uint;
#[doc = " The IOC node address."]
pub type ClIocNodeAddressT = ClUint32T;
#[doc = " The IOC communication port."]
pub type ClIocPortT = ClUint32T;
#[doc = " The Communication port handle."]
pub type ClIocCommPortHandleT = ClWordT;
#[doc = " The Transport handle."]
pub type ClIocToBindHandleT = ClHandleT;
#[doc = " Port Type. It can be have the following values:\n \\arg \\c CL_IOC_UNRELIABLE_MESSAGING: for unreliable messaging\n \\arg \\c CL_IOC_RELIABLE_MESSAGING: for reliable messaging"]
pub type ClIocCommPortFlagsT = ClUint32T;
#[doc = " IOC Logical address."]
pub type ClIocLogicalAddressT = ClUint64T;
#[doc = " IOC Multicast address."]
pub type ClIocMulticastAddressT = ClUint64T;
#[doc = " The IOC Physical address of an application's communication end point."]
#[repr(C)]
pub struct ClIocPhysicalAddress {
    #[doc = " The IOC Node address."]
    pub nodeAddress: ClIocNodeAddressT,
    #[doc = " The IOC communication end point identification on a node."]
    pub portId: ClIocPortT,
}
#[test]
fn bindgen_test_layout_ClIocPhysicalAddress() {
    const UNINIT: ::std::mem::MaybeUninit<ClIocPhysicalAddress> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ClIocPhysicalAddress>(),
        8usize,
        concat!("Size of: ", stringify!(ClIocPhysicalAddress))
    );
    assert_eq!(
        ::std::mem::align_of::<ClIocPhysicalAddress>(),
        4usize,
        concat!("Alignment of ", stringify!(ClIocPhysicalAddress))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nodeAddress) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ClIocPhysicalAddress),
            "::",
            stringify!(nodeAddress)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).portId) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ClIocPhysicalAddress),
            "::",
            stringify!(portId)
        )
    );
}
#[doc = " The IOC Physical address of an application's communication end point."]
pub type ClIocPhysicalAddressT = ClIocPhysicalAddress;
#[doc = " IOC address."]
#[repr(C)]
pub struct ClIocAddress {
    #[doc = " Physical address."]
    pub iocPhyAddress: __BindgenUnionField<ClIocPhysicalAddressT>,
    #[doc = " Logical address."]
    pub iocLogicalAddress: __BindgenUnionField<ClIocLogicalAddressT>,
    #[doc = " Multicast address."]
    pub iocMulticastAddress: __BindgenUnionField<ClIocMulticastAddressT>,
    pub bindgen_union_field: u64,
}
#[test]
fn bindgen_test_layout_ClIocAddress() {
    const UNINIT: ::std::mem::MaybeUninit<ClIocAddress> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ClIocAddress>(),
        8usize,
        concat!("Size of: ", stringify!(ClIocAddress))
    );
    assert_eq!(
        ::std::mem::align_of::<ClIocAddress>(),
        8usize,
        concat!("Alignment of ", stringify!(ClIocAddress))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).iocPhyAddress) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ClIocAddress),
            "::",
            stringify!(iocPhyAddress)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).iocLogicalAddress) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ClIocAddress),
            "::",
            stringify!(iocLogicalAddress)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).iocMulticastAddress) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ClIocAddress),
            "::",
            stringify!(iocMulticastAddress)
        )
    );
}
#[doc = " IOC address."]
pub type ClIocAddressT = ClIocAddress;
#[doc = " The message is persistent in nature and is not consumed by IOC\n on send."]
pub const ClIocMessageOption_CL_IOC_PERSISTENT_MSG: ClIocMessageOption = 0;
#[doc = " The message is non persistent in nature and is consumed by IOC\n on send. This message cannot be reused."]
pub const ClIocMessageOption_CL_IOC_NON_PERSISTENT_MSG: ClIocMessageOption = 1;
#[doc = " The send message option."]
pub type ClIocMessageOption = ::std::os::raw::c_uint;
#[doc = " The send message option."]
pub use self::ClIocMessageOption as ClIocMessageOptionT;
#[doc = " Send related options."]
#[repr(C)]
pub struct ClIocSendOption {
    #[doc = " Message priority."]
    pub priority: ClUint8T,
    #[doc = " The send type, it can be session based or not."]
    pub sendType: ClUint8T,
    #[doc = " The Handle for uniquely identifying Transport and Link."]
    pub linkHandle: ClWordT,
    #[doc = " The message type, it can be persistent or non persistent message."]
    pub msgOption: ClIocMessageOptionT,
    #[doc = " The timeout interval in milliseconds."]
    pub timeout: ClUint32T,
}
#[test]
fn bindgen_test_layout_ClIocSendOption() {
    const UNINIT: ::std::mem::MaybeUninit<ClIocSendOption> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ClIocSendOption>(),
        24usize,
        concat!("Size of: ", stringify!(ClIocSendOption))
    );
    assert_eq!(
        ::std::mem::align_of::<ClIocSendOption>(),
        8usize,
        concat!("Alignment of ", stringify!(ClIocSendOption))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priority) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ClIocSendOption),
            "::",
            stringify!(priority)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sendType) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(ClIocSendOption),
            "::",
            stringify!(sendType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).linkHandle) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ClIocSendOption),
            "::",
            stringify!(linkHandle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msgOption) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ClIocSendOption),
            "::",
            stringify!(msgOption)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timeout) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ClIocSendOption),
            "::",
            stringify!(timeout)
        )
    );
}
#[doc = " Send related options."]
pub type ClIocSendOptionT = ClIocSendOption;
#[doc = " The IOC receive returns this structure along with the message."]
#[repr(C)]
pub struct ClIocRecvParam {
    #[doc = " Priority of the message received."]
    pub priority: ClUint8T,
    #[doc = " Protocol used."]
    pub protoType: ClUint8T,
    #[doc = " Length of the message received."]
    pub length: ClUint32T,
    #[doc = " Sender address."]
    pub srcAddr: ClIocAddressT,
}
#[test]
fn bindgen_test_layout_ClIocRecvParam() {
    const UNINIT: ::std::mem::MaybeUninit<ClIocRecvParam> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ClIocRecvParam>(),
        16usize,
        concat!("Size of: ", stringify!(ClIocRecvParam))
    );
    assert_eq!(
        ::std::mem::align_of::<ClIocRecvParam>(),
        8usize,
        concat!("Alignment of ", stringify!(ClIocRecvParam))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priority) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ClIocRecvParam),
            "::",
            stringify!(priority)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).protoType) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(ClIocRecvParam),
            "::",
            stringify!(protoType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ClIocRecvParam),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).srcAddr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ClIocRecvParam),
            "::",
            stringify!(srcAddr)
        )
    );
}
#[doc = " The IOC receive returns this structure along with the message."]
pub type ClIocRecvParamT = ClIocRecvParam;
#[doc = " IOC receive options."]
#[repr(C)]
pub struct ClIocRecvOption {
    #[doc = " Timeout value for blocking call."]
    pub recvTimeout: ClUint32T,
}
#[test]
fn bindgen_test_layout_ClIocRecvOption() {
    const UNINIT: ::std::mem::MaybeUninit<ClIocRecvOption> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ClIocRecvOption>(),
        4usize,
        concat!("Size of: ", stringify!(ClIocRecvOption))
    );
    assert_eq!(
        ::std::mem::align_of::<ClIocRecvOption>(),
        4usize,
        concat!("Alignment of ", stringify!(ClIocRecvOption))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).recvTimeout) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ClIocRecvOption),
            "::",
            stringify!(recvTimeout)
        )
    );
}
#[doc = " IOC receive options."]
pub type ClIocRecvOptionT = ClIocRecvOption;
pub const ClIocQueueId_CL_IOC_SENDQ: ClIocQueueId = 0;
pub const ClIocQueueId_CL_IOC_RECVQ: ClIocQueueId = 1;
pub const ClIocQueueId_CL_IOC_QUEUE_MAX: ClIocQueueId = 2;
pub type ClIocQueueId = ::std::os::raw::c_uint;
pub use self::ClIocQueueId as ClIocQueueIdT;
#[repr(C)]
pub struct ClIocQueueInfo {
    pub queueSize: ClUint32T,
    pub queueWM: ClWaterMarkT,
}
#[test]
fn bindgen_test_layout_ClIocQueueInfo() {
    const UNINIT: ::std::mem::MaybeUninit<ClIocQueueInfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ClIocQueueInfo>(),
        24usize,
        concat!("Size of: ", stringify!(ClIocQueueInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<ClIocQueueInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(ClIocQueueInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).queueSize) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ClIocQueueInfo),
            "::",
            stringify!(queueSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).queueWM) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ClIocQueueInfo),
            "::",
            stringify!(queueWM)
        )
    );
}
pub type ClIocQueueInfoT = ClIocQueueInfo;
#[repr(C)]
pub struct ClIocQueueStats {
    pub queueInfo: ClIocQueueInfoT,
    pub queueUtilisation: ClUint32T,
}
#[test]
fn bindgen_test_layout_ClIocQueueStats() {
    const UNINIT: ::std::mem::MaybeUninit<ClIocQueueStats> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ClIocQueueStats>(),
        32usize,
        concat!("Size of: ", stringify!(ClIocQueueStats))
    );
    assert_eq!(
        ::std::mem::align_of::<ClIocQueueStats>(),
        8usize,
        concat!("Alignment of ", stringify!(ClIocQueueStats))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).queueInfo) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ClIocQueueStats),
            "::",
            stringify!(queueInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).queueUtilisation) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ClIocQueueStats),
            "::",
            stringify!(queueUtilisation)
        )
    );
}
pub type ClIocQueueStatsT = ClIocQueueStats;
#[repr(C)]
pub struct ClIocLibConfig {
    #[doc = " Version of IOC."]
    pub version: ClUint8T,
    #[doc = " The IOC address of the node."]
    pub nodeAddress: ClIocNodeAddressT,
    #[doc = " The Geographical address."]
    pub iocGeoGraphicalAddress: [ClCharT; 129usize],
    #[doc = " Maximum Number of priority."]
    pub iocMaxNumOfPriorities: ClUint32T,
    #[doc = " The reassembly timeout."]
    pub iocReassemblyTimeOut: ClUint32T,
    #[doc = " Maximum number of transport."]
    pub iocMaxNumOfXports: ClUint32T,
    #[doc = " IOC node level heartbeating time interval."]
    pub iocHeartbeatTimeInterval: ClUint32T,
    #[doc = " Maximum number of entries for the Transparency Layer."]
    pub iocTLMaxEntries: ClUint32T,
    pub iocSendQInfo: ClIocQueueInfoT,
    pub iocRecvQInfo: ClIocQueueInfoT,
    pub iocNodeRepresentative: ClIocPortT,
    pub isNodeRepresentative: ClBoolT,
}
#[test]
fn bindgen_test_layout_ClIocLibConfig() {
    const UNINIT: ::std::mem::MaybeUninit<ClIocLibConfig> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ClIocLibConfig>(),
        216usize,
        concat!("Size of: ", stringify!(ClIocLibConfig))
    );
    assert_eq!(
        ::std::mem::align_of::<ClIocLibConfig>(),
        8usize,
        concat!("Alignment of ", stringify!(ClIocLibConfig))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ClIocLibConfig),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nodeAddress) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ClIocLibConfig),
            "::",
            stringify!(nodeAddress)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).iocGeoGraphicalAddress) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ClIocLibConfig),
            "::",
            stringify!(iocGeoGraphicalAddress)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).iocMaxNumOfPriorities) as usize - ptr as usize },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(ClIocLibConfig),
            "::",
            stringify!(iocMaxNumOfPriorities)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).iocReassemblyTimeOut) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(ClIocLibConfig),
            "::",
            stringify!(iocReassemblyTimeOut)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).iocMaxNumOfXports) as usize - ptr as usize },
        148usize,
        concat!(
            "Offset of field: ",
            stringify!(ClIocLibConfig),
            "::",
            stringify!(iocMaxNumOfXports)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).iocHeartbeatTimeInterval) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(ClIocLibConfig),
            "::",
            stringify!(iocHeartbeatTimeInterval)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).iocTLMaxEntries) as usize - ptr as usize },
        156usize,
        concat!(
            "Offset of field: ",
            stringify!(ClIocLibConfig),
            "::",
            stringify!(iocTLMaxEntries)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).iocSendQInfo) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(ClIocLibConfig),
            "::",
            stringify!(iocSendQInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).iocRecvQInfo) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(ClIocLibConfig),
            "::",
            stringify!(iocRecvQInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).iocNodeRepresentative) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(ClIocLibConfig),
            "::",
            stringify!(iocNodeRepresentative)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).isNodeRepresentative) as usize - ptr as usize },
        212usize,
        concat!(
            "Offset of field: ",
            stringify!(ClIocLibConfig),
            "::",
            stringify!(isNodeRepresentative)
        )
    );
}
pub type ClIocLibConfigT = ClIocLibConfig;
#[doc = " The context for Global scope entries."]
pub const ClIocTLContext_CL_IOC_TL_GLOBAL_SCOPE: ClIocTLContext = 0;
#[doc = " The context for local scope entries."]
pub const ClIocTLContext_CL_IOC_TL_LOCAL_SCOPE: ClIocTLContext = 1;
#[doc = " Transparency layer context."]
pub type ClIocTLContext = ::std::os::raw::c_uint;
#[doc = " Transparency layer context."]
pub use self::ClIocTLContext as ClIocTLContextT;
#[doc = " Data-type for holding the physical address and its state."]
#[repr(C)]
pub struct ClIocTLMappingT {
    #[doc = " State of the component corresponding to the physicalAddr."]
    pub haState: ClUint32T,
    #[doc = " Physical address of the component."]
    pub physicalAddr: ClIocPhysicalAddressT,
}
#[test]
fn bindgen_test_layout_ClIocTLMappingT() {
    const UNINIT: ::std::mem::MaybeUninit<ClIocTLMappingT> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ClIocTLMappingT>(),
        12usize,
        concat!("Size of: ", stringify!(ClIocTLMappingT))
    );
    assert_eq!(
        ::std::mem::align_of::<ClIocTLMappingT>(),
        4usize,
        concat!("Alignment of ", stringify!(ClIocTLMappingT))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).haState) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ClIocTLMappingT),
            "::",
            stringify!(haState)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).physicalAddr) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ClIocTLMappingT),
            "::",
            stringify!(physicalAddr)
        )
    );
}
#[doc = " Transparency layer parameters"]
#[repr(C)]
pub struct ClIocTlInfo {
    #[doc = " Logical address of the service."]
    pub logicalAddr: ClIocLogicalAddressT,
    #[doc = " Id of the component providing the service."]
    pub compId: ClUint32T,
    #[doc = " Context, it can be either \\c GLOBAL or \\c LOCAL."]
    pub contextType: ClIocTLContextT,
    #[doc = " Replication Semantics."]
    pub unused: ClUint32T,
    #[doc = " Active or Standby mode."]
    pub haState: ClUint32T,
    #[doc = " Physical address of the component."]
    pub physicalAddr: ClIocPhysicalAddressT,
}
#[test]
fn bindgen_test_layout_ClIocTlInfo() {
    const UNINIT: ::std::mem::MaybeUninit<ClIocTlInfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ClIocTlInfo>(),
        32usize,
        concat!("Size of: ", stringify!(ClIocTlInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<ClIocTlInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(ClIocTlInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).logicalAddr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ClIocTlInfo),
            "::",
            stringify!(logicalAddr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).compId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ClIocTlInfo),
            "::",
            stringify!(compId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).contextType) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ClIocTlInfo),
            "::",
            stringify!(contextType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unused) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ClIocTlInfo),
            "::",
            stringify!(unused)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).haState) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ClIocTlInfo),
            "::",
            stringify!(haState)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).physicalAddr) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ClIocTlInfo),
            "::",
            stringify!(physicalAddr)
        )
    );
}
#[doc = " Transparency layer parameters"]
pub type ClIocTLInfoT = ClIocTlInfo;
#[repr(C)]
pub struct ClIocMcastUserInfo {
    pub mcastAddr: ClIocMulticastAddressT,
    pub physicalAddr: ClIocPhysicalAddressT,
}
#[test]
fn bindgen_test_layout_ClIocMcastUserInfo() {
    const UNINIT: ::std::mem::MaybeUninit<ClIocMcastUserInfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ClIocMcastUserInfo>(),
        16usize,
        concat!("Size of: ", stringify!(ClIocMcastUserInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<ClIocMcastUserInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(ClIocMcastUserInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mcastAddr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ClIocMcastUserInfo),
            "::",
            stringify!(mcastAddr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).physicalAddr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ClIocMcastUserInfo),
            "::",
            stringify!(physicalAddr)
        )
    );
}
pub type ClIocMcastUserInfoT = ClIocMcastUserInfo;
extern "C" {
    #[doc = "  \\brief Creates a communication port.\n\n  \\par Header File:\n  clIocApi.h\n\n  \\par Library Files:\n  libClIoc\n\n  \\param portId Id of the communication port to be created. If portId is 0,\n  then a communication port id is generated by IOC.\n  \\param portType This parameter refers to the type of communication that\n  can be reliable or unreliable. This parameter can have the following two\n  values:\n  \\arg \\c CL_IOC_UNRELIABLE_MESSAGING, for unreliable messaging.\n  \\arg \\c CL_IOC_RELIABLE_MESSAGING, for reliable messaging.\n  \\param pIocCommPortHdl Handle to the communication port used by\n  applications to send and receive the messages.\n\n  \\retval CL_OK The API is successfully executed.\n  \\retval CL_ERR_NOT_INITIALIZED If the IOC is not initialized\n  \\retval CL_ERR_NULL_POINTER If the \\e pIocCommPortHdl is passed as NULL.\n  \\retval CL_ERR_NOT_IMPLEMENTED If portType is not\n  \\c CL_IOC_UNRELIABLE_MESSAGING.\n  \\retval CL_ERR_INVALID_PARAMETER If the portId is more than\n  \\c CL_IOC_COMMPORT_END.\n  \\retval CL_ERR_NOT_EXIST If 0 is passed as portId and no ephemeral\n  communication port is free.\n  \\retval CL_IOC_ERR_COMMPORT_REG_FAIL If communication port registration failed.\n  \\retval CL_ERR_NO_MEMORY If the memory allocation or any other resource\n  allocation fails.\n  \\retval CL_ERR_UNSPECIFIED In case of other failures.\n\n  \\par Description:\n  This API is used to create a communication port. A communication port is\n  compulsary for an ASP application which wants to communicate with another\n  ASP application. The mode of communication can be reliable or unreliable,\n  which should be specified through /e portType parameter. The communication\n  port created will be in the blocking mode.\n\n  \\sa clIocSend(), clIocReceive(), clIocCommPortDelete().\n\n"]
    pub fn clIocCommPortCreate(
        portId: ClIocPortT,
        portType: ClIocCommPortFlagsT,
        pIocCommPortHdl: *mut ClIocCommPortHandleT,
    ) -> ClRcT;
}
extern "C" {
    #[doc = "  \\brief Deletes the communication port.\n\n  \\par Header File:\n  clIocApi.h\n\n  \\par Library Files:\n  libClIoc\n\n  \\param iocCommPortHdl Handle to communication port to be deleted.\n\n  \\retval CL_OK The API is successfully executed.\n  \\retval CL_ERR_NOT_INITIALIZED If the IOC is not initialized\n  \\retval CL_ERR_INVALID_HANDLE If Invalid communication port handle is\n  passed.\n  \\retval CL_IOC_ERR_COMMPORT_BLOCKED If The communication port is blocked.\n\n  \\par Description:\n  This API is used to delete the already existing communication port, which\n  was created by calling \\e clIocCommPortCreate() API. Before deleting the\n  communication port, it should made sure that no thread is using the\n  communication port and no one is blocked on receive.\n\n  \\sa clIocCommPortCreate(), clIocSend(), clIocReceive().\n"]
    pub fn clIocCommPortDelete(iocCommPortHdl: ClIocCommPortHandleT) -> ClRcT;
}
extern "C" {
    #[doc = "  \\brief Gets the socket descriptor used by communication of a CommPort.\n\n  \\par Header File:\n  clIocApi.h\n\n  \\par Library Files:\n  libClIoc\n\n  \\param portHandle This is the communication port handle, which was\n  returned on creating the commport through \\e clIocCommPortCreate() API.\n  \\param pSd This is pointer to a variable of type ClInt32T in which the\n  socket descriptor for the CommPort will be returned.\n\n  \\retval CL_OK The API is successfully executed.\n  \\retval CL_ERR_NOT_INITIALIZED If the IOC is not initialized\n  \\retval CL_ERR_INVALID_HANDLE If Invalid communication port handle is\n  passed.\n  \\retval CL_ERR_NULL_POINTER If the address for holding the socket descriptor\n  is NULL.\n\n  \\par Description:\n  This API is used to get the socket descriptor of a communication port, created\n  by \\e clIocCommPortCreate() API. This API is useful when select() or poll() on\n  few IOC communication ports is to performed. On calling this API with\n  communication port returns with socket descriptor and then this socket\n  descriptor can be used in select() or poll(). Now the applications which\n  are interested in communicating with each other have to use either the\n  socket descriptor or the communication port handle but the mixed usage,\n  Mixed usage results into dataloss.\n\n  \\sa clIocCommPortCreate(), clIocSend(), clIocReceive().\n"]
    pub fn clIocCommPortFdGet(portHandle: ClIocCommPortHandleT, pSd: *mut ClInt32T) -> ClRcT;
}
extern "C" {
    #[doc = "  \\brief Returns the port Id.\n\n  \\par Header File:\n  clIocApi.h\n\n  \\par Library Files:\n  libClIoc\n\n  \\param pIocCommPort Handle to the communication port.\n  \\param pPortId A pointer to the port Id, on successful\n  execution.\n\n  \\retval CL_OK The API is successfully executed.\n  \\retval CL_ERR_NOT_INITIALIZED If the IOC is not initialized\n  \\retval CL_ERR_NULL_POINTER If the pPortId is passed as NULL.\n\n  \\par Description:\n  This API returns the port Id for a given communication port handle.\n  It needs to be called when the communication port related\n  parameters are required to be set. This can be called only if the\n  communication port is created through \\e clIocCommPortCreate().\n\n  \\sa\n  clIocCommPortCreate(), clIocSend(), clIocReceive(),\n  clIocCommPortDelete(), clIocLastErrorGet().\n"]
    pub fn clIocCommPortGet(pIocCommPort: ClIocCommPortHandleT, pPortId: *mut ClIocPortT) -> ClRcT;
}
extern "C" {
    #[doc = "  \\brief Enables/Disables the notifications form IOC on the port.\n\n  \\par Header File:\n  clIocApi.h\n\n  \\par Library Files:\n  libClIoc\n\n  \\param port Port number for who the notification configuration needs to be modified.\n  \\param action The notification action that needs to performed on the port.\n  execution.\n\n  \\retval CL_OK The API is successfully executed.\n  \\retval CL_ERR_DOESNT_EXIST If an invalid port is passed or if the port is not yet created.\n\n  \\par Description:\n  This API enables/disables the port to receive notifications genereted by\n  IOC. The IOC generated notifications like component/node arrival/departure. And\n  these notifications are sent to all the components on the node. But the notifications\n  will reach the applications only if the application enables notification for that port.\n  And if port disables the notification then no notification received by port will reach\n  the application. It will be dropped by IOC. By default the ports will be disabled for\n  receiving notifications.\n\n  \\sa\n  clIocCommPortCreate(), clIocCommPortGet(), clIocCommPortDelete().\n"]
    pub fn clIocPortNotification(port: ClIocPortT, action: ClIocNotificationActionT) -> ClRcT;
}
extern "C" {
    #[doc = "  \\brief Sends message on a communication port.\n\n  \\par Header File:\n  clIocApi.h\n\n  \\par Library Files:\n  libClIoc\n\n  \\param commPortHandle Handle to a communication port on which message\n  is to be sent.\n\n  \\param message The message to be sent across the communication port.\n  The message must be created by you and the data to be sent across is\n  be passed in this message. If the message is persistent, it must be\n  freed by you.\n\n  \\param protoType The protocol ID must be specified by you.\n  \\param pDestAddr A pointer to the destination address where message need\n  to be sent.\n  \\param pSendOption The options available to send a message. If\n  \\e pSendOption is NULL, the default values are used.\n\n  \\par The structure ClIocSendOptionT has the following fields:\n\n  \\arg \\e priority: The priority to send across a message. If the message\n  priority is more than the maximum supported value then the message will\n  be sent with 0 (default value) priority.\n  \\arg \\e sendType: This is used in case of sending a message to a logical\n  address. The values for this parameters are\n  \\c CL_IOC_SESSION_BASED A session will be established on sending a\n  message with this parameter set to a logical address. Every subsequent\n  send to the same logical address will end up going to the same physcial\n  address without doing any lookup for physical address of that logical\n  address. In case if the destination component changes its physical\n  location then the send will return with an error and the session will be\n  lost.\n  \\c CL_IOC_NO_SESSION (default value) Every time the logical address to\n  physical address conversion is done and sent to the physical address.\n  \\arg \\e msgOption: This parameters is used to define the message as\n  peristent or non-persistent and can have any of the following two values:\n  -# \\c CL_IOC_PERSISTENT_MSG: For persistant message. These buffer messages\n  will not be deleted on error or in case of successful sending of the\n  message. here the sening application has to delete the buffer message.\n  -# \\c CL_IOC_NON_PERSISTENT_MSG: Default value, for non-persistant message.\n  In this case the message will be deleted by IOC.\n\n  \\arg \\e timeout: It is the timeout value  in miliseconds. Default is 0.\n  If 0 is passed, the first error encountered is returned. If it is\n  non zero then this API on seeing the Flow control related messages will\n  try to resend the message until the timeout expires and if the timeout\n  expires in between it will return the error. If a big message\n  is sent then fragmentation and reassembly will kickin, if the finite\n  timeout is specified then it may return the timeout error, if the total\n  time required to send all the fragments out is more than the 'timeout'\n  period.\n\n\n  \\retval CL_OK The API is successfully executed.\n  \\retval CL_ERR_NOT_INITIALIZED If the IOC is not initialized.\n  \\retval CL_ERR_INVALID_HANDLE If Invalid communication port handle is passed.\n  \\retval CL_ERR_NULL_POINTER If the pDestAddr is passed as NULL.\n  \\retval CL_ERR_INVALID_BUFFER If the message is invalid.\n  \\retval CL_IOC_ERR_PROTO_IN_USE_WITH_IOC If the protocol id passed is in\n  use by IOC.\n  \\retval CL_IOC_ERR_INVALID_MSG_OPTION If the message option passed in the\n  pSendOption is invalid.\n  \\retval CL_ERR_INVALID_PARAMETER If the sendType passed in the pSendOption\n  is invalid or the destination address is not of supported type, or\n  the message size is 0.\n  \\retval CL_ERR_NO_MEMORY On memory allocation failure.\n  \\retval CL_ERR_NOT_EXIST If the logical address is passed and there is no\n  mapping for it in the Transparency Layer.\n  \\retval CL_IOC_ERR_INVALID_SESSION If session based communication is\n  requested and the destination is moved to a different location.\n  \\retval CL_IOC_ERR_FLOW_XOFF_STATE If the destination has send an XOFF message.\n  \\retval CL_IOC_ERR_HOST_UNREACHABLE If the host can not be reached.\n  \\retval CL_ERR_BUFFER_OVERRUN If the priority queue has no space left\n  for this message.\n  \\retval CL_ERR_TIMEOUT If send operation can not be completed within the\n   specified timeout interval.\n  \\retval CL_ERR_UNSPECIFIED Other errors.\n\n  \\par Description:\n  This API is used to send a message to an ASP application. The message\n  passed can be persistent or non persistent as  specified in the \\e\n  messageType field of the \\e sendoption structure. The persistant\n  messages are required to be deleted by the sending application and\n  non-persistant messages will be deleted by IOC on completing the send\n  operation. Since IOC supports fragmentation and reassembly of the messages\n  any big data can be sent. The thing that needs to be considered at the\n  time of sending big messages is the timeout value. If the send operation\n  cannot completely send the data within that time it will return with\n  CL_ERR_TIMEOUT error.\n\n  \\sa\n  clIocCommPortCreate(), clIocReceive(),\n  clIocCommPortDelete().\n"]
    pub fn clIocSend(
        commPortHandle: ClIocCommPortHandleT,
        message: ClBufferHandleT,
        protoType: ClUint8T,
        pDestAddr: *mut ClIocAddressT,
        pSendOption: *mut ClIocSendOptionT,
    ) -> ClRcT;
}
extern "C" {
    #[doc = "  \\brief Receives message on communication port.\n\n  \\par Header File:\n  clIocApi.h\n\n  \\par Library Files:\n  libClIoc\n\n  \\param commPortHdl Handle of the given communication port.\n\n  \\param pRecvOption  This structure is used for options like timeout.\n  If NULL, the structure makes use of all the default values.\n\n  \\param userMsg (out) Handle to the message. This must be created and freed by you once the call returns.\n  After the successfully receving the data, the received data is passed to the message.\n\n  \\param pRecvParam (out) The parameter related to the message priority, origin of the message,\n  length of the message and protocol is returned here on successful receive. It can not be NULL.\n  \\arg \\e priority The priority of the message with which the sender sent the message.\n  \\arg \\e protoType The protocol of the message with which sender sent, so\n  that the receiver can analyse the packet using that prottocol.\n  \\arg \\e length Length of the message just received.\n  \\arg \\e srcAddr The physical address of the sender of the message.\n\n\n  \\retval CL_OK The API is successfully executed.\n  \\retval CL_ERR_NOT_INITIALIZED If the IOC is not initialized.\n  \\retval CL_ERR_INVALID_HANDLE If Invalid communication port handle is passed.\n  \\retval CL_ERR_NULL_POINTER If the pRecvParam is passed as NULL.\n  \\retval CL_ERR_INVALID_BUFFER If the message is invalid.\n  \\retval CL_IOC_ERR_TRY_AGAIN On failing to receive any message on non-blocking communication port.\n  \\retval CL_ERR_TIMEOUT If nothing is received within specified timeout interval.\n  \\retval CL_IOC_ERR_RECV_UNBLOCKED If receiver is unblocked.\n  \\retval  CL_ERR_UNSPECIFIED Other errors.\n\n  \\par Description:\n  This API is used to receive a message on the communication port. The\n  messages are received as per the priority, and the same priority\n  order is maintained through out. The behavior of this call depends\n  on the current mode of the port, i.e., blocking or non-blocking mode.\n  If the mode is set to blocking and there is no data in commport receive queue, the\n  receiver thread gets blocked. If the mode is non-blocking and there is no data\n  attached in the commport receive queue then \\c CL_IOC_ERR_TRY_AGAIN error code is\n  returned. To receive data in non-blocking mode, the application has to poll on the communication\n  port checking for data availability.\n\n  \\sa\n  clIocCommPortCreate(), clIocSend(),\n  clIocCommPortDelete().\n"]
    pub fn clIocReceive(
        commPortHdl: ClIocCommPortHandleT,
        pRecvOption: *mut ClIocRecvOptionT,
        userMsg: ClBufferHandleT,
        pRecvParam: *mut ClIocRecvParamT,
    ) -> ClRcT;
}
extern "C" {
    pub fn clIocReceiveAsync(
        commPortHdl: ClIocCommPortHandleT,
        pRecvOption: *mut ClIocRecvOptionT,
        userMsg: ClBufferHandleT,
        pRecvParam: *mut ClIocRecvParamT,
    ) -> ClRcT;
}
extern "C" {
    pub fn clIocReceiveWithBuffer(
        commPortHdl: ClIocCommPortHandleT,
        pRecvOption: *mut ClIocRecvOptionT,
        buffer: *mut ClUint8T,
        bufSize: ClUint32T,
        userMsg: ClBufferHandleT,
        pRecvParam: *mut ClIocRecvParamT,
    ) -> ClRcT;
}
extern "C" {
    pub fn clIocReceiveWithBufferAsync(
        commPortHdl: ClIocCommPortHandleT,
        pRecvOption: *mut ClIocRecvOptionT,
        buffer: *mut ClUint8T,
        bufSize: ClUint32T,
        userMsg: ClBufferHandleT,
        pRecvParam: *mut ClIocRecvParamT,
    ) -> ClRcT;
}
extern "C" {
    #[doc = "  \\brief Unblocks all receive calls.\n\n  \\par Header File:\n  clIocApi.h\n\n  \\par Library Files:\n  libClIoc\n\n  \\param commPortHdl Handle of the communication port to be unblocked.\n\n  \\retval CL_OK The API is successfully executed.\n  \\retval CL_ERR_NOT_INITIALIZED If the IOC is not initialized.\n  \\retval CL_ERR_INVALID_HANDLE If the communication port handle is invalid.\n\n  \\par Description:\n  This API is used to unblock the receive call which is blocked inside IOC on\n  the given communication port. The blocked receive call is unblocked and returns\n  \\c CL_IOC_RECV_UNBLOCKED after this call. The receive on this communication port stops after this call.\n  To start the receive again on the communication port you must call API clIocCommPortBlockRecvSet.\n\n  \\sa\n  clIocCommPortCreate(), clIocCommPortDelete(), clIocCommPortModeSet(),\n  clIocCommPortModeGet(), clIocCommPortBlockRecvSet(), clIocCommPortDebug().\n\n\n"]
    pub fn clIocCommPortReceiverUnblock(commPortHdl: ClIocCommPortHandleT) -> ClRcT;
}
extern "C" {
    #[doc = "  \\brief Registers an application's logical address with Transparency Layer.\n\n  \\par Header File:\n  clIocApi.h\n\n  \\par Library Files:\n  libClIoc\n\n  \\param pTLInfo (in/out) This parameter contains the logical address\n  registration related information.\n  \\arg \\e logicalAddr This is the logical address of the application which is\n  being registered with the Transparency layer.\n  \\arg \\e compId This is component Id of the application, on which the IOC\n  receive will be blocked for receiving the data.\n  \\arg \\e contextType This registers the logical address either in GLOBAL or\n  in LOCAL context. the GLOBAL context registrations will be updated on all\n  the nodes immediately.\n  \\arg \\e haState The indicates the state of the application, whether it\n  is active or standby.\n\n  \\retval CL_OK The API is successfully executed.\n  \\retval CL_ERR_NOT_INITIALIZED If IOC is not initialized.\n  \\retval CL_ERR_NULL_POINTER If pTLInfo is NULL\n  \\retval CL_IOC_ERR_TL_LIMIT_EXCEEDED If there is no space left in registration database.\n  \\retval CL_ERR_INVALID_PARAMETER If context passed in pTLInfo is not a valid type.\n  \\retval CL_ERR_NO_MEMORY On memory allocation failure.\n  \\retval CL_IOC_ERR_TL_DUPLICATE_ENTRY If the entry already exists.\n\n  \\par Description:\n  This API is used to register an application's logical address with the\n  Transparency Layer. Once the registration is done the application can be\n  reached on its logical address.\n\n  \\sa\n  clIocTransparencyDeregister(),\n  clIocTransparencyLogicalToPhysicalAddrGet().\n\n"]
    pub fn clIocTransparencyRegister(pTLInfo: *mut ClIocTLInfoT) -> ClRcT;
}
extern "C" {
    #[doc = "  \\brief De-registers the application with Transparency Layer.\n\n  \\par Header File:\n  clIocApi.h\n\n  \\par Library Files:\n  ClIoc\n\n  \\param compId Id of the component which wants to deregister all its\n  registration with Transparency Layer.\n\n  \\retval CL_OK The API is successfully executed.\n  \\retval CL_ERR_NOT_INITIALIZED If IOC is not initialized.\n\n  \\par Description:\n  This API is used to deregister the application with Transparency layer.\n  The application cannot be reached with the logical address after this API\n  is called for the comp id. But it can be reached through the physical\n  address if it is known.\n\n  \\sa clIocTransparencyRegister().\n"]
    pub fn clIocTransparencyDeregister(compId: ClUint32T) -> ClRcT;
}
extern "C" {
    #[doc = "  \\brief Registers an application against a multicast address with IOC Multicast Layer.\n\n  \\par Header File:\n  clIocIpi.h\n\n  \\par Library Files:\n  libClIoc\n\n  \\param pMcastInfo This parameter contains the registration related information, which includes the multicast address and IOC physical address.\n\n  \\retval CL_OK The function has successfully executed.\n  \\retval CL_ERR_NOT_INITIALIZED If IOC is not initialized.\n  \\retval CL_ERR_NULL_POINTER If pMcastInfo is NULL\n  \\retval CL_ERR_INVALID_PARAMETER If any field of pMcastInfo is not a valid type.\n  \\retval CL_ERR_NO_MEMORY IOC could not get enough memory to complete the requested operation.\n  \\retval CL_ERR_ALREADY_EXIST The specified mapping already exist.\n\n  \\par Description:\n  This API is used to register an application against a multicast address\n  with the Multicast Layer. The IOC physical address of an application is\n  used to register to a multicast group, in which the application is\n  interested, using the groups multicast address. Any message sent to the\n  multicast group by any application in the system will reach all the\n  applications, who have registered for that multicast address.\n\n  \\sa clIocMulticastDeregister(),\n\n"]
    pub fn clIocMulticastRegister(pMcastInfo: *mut ClIocMcastUserInfoT) -> ClRcT;
}
extern "C" {
    #[doc = "  \\brief De-registers the application against a multicast address\n  with the IOC Multicast Layer.\n\n  \\par Header File:\n  clIocIpi.h\n\n  \\par Library Files:\n  libClIoc\n\n\n  \\param pMcastInfo This parameter contains the multicast\n  deregistration information which includes physical address to be de-registered and the multicast address\n  against which the deregistration should happen.\n  \\retval CL_OK The function has successfully executed.\n  \\retval CL_ERR_NOT_INITIALIZED If IOC is not initialized.\n  \\retval CL_ERR_NULL_POINTER If pMcastInfo is NULL\n  \\retval CL_ERR_INVALID_PARAMETER If any of the fields in pMcastInfo is\n  ascertained to be invalid.\n  \\retval CL_ERR_NOT_EXIST This physical address was not registered\n  against this multicast address through a previous invocation of\n  clIocMulticastRegister.\n\n  \\par Description:\n  This API is called to deregister the application from the multicast group\n  identifed by multicastAddress. The physical address is deregistered from\n  the multicast address' list. The multicast address is also\n  removed from the multicast table if the deregistred address was the\n  only left physical address with that multicast address group.\n\n  \\sa clIocMulticastRegister(), clIocMulticastDeregisterAll().\n\n\n"]
    pub fn clIocMulticastDeregister(pMcastInfo: *mut ClIocMcastUserInfoT) -> ClRcT;
}
extern "C" {
    #[doc = "  \\brief De-registers the application against a multicast address\n  with the IOC Multicast Layer.\n\n  \\par Header File:\n  clIocIpi.h\n\n  \\par Library Files:\n  libClIoc\n\n\n  \\param pMcastAddress This parameter contains the multicast\n  deregistration information which includes the multicast address\n  against which the deregistration should happen.All the physical\n  addresses for the given multicast address are deregistered along\n  with the multicast address.\n  \\retval CL_OK The function has successfully executed.\n  \\retval CL_ERR_NOT_INITIALIZED If IOC is not initialized.\n  \\retval CL_ERR_NULL_POINTER If pMcastInfo is NULL\n  \\retval CL_ERR_INVALID_PARAMETER If any of the fields in pMcastInfo is\n  ascertained to be invalid.\n  \\retval CL_ERR_NOT_EXIST This multicast address was not registered\n  through a previous invocation of clIocMulticastRegister.\n\n  \\par Description:\n  This API is called to deregister all the applications from the multicast group\n  identifed by multicastAddress. The physical addresses for the\n  multicast address are deregistered. The multicast address is also\n  removed from the multicast table. This should be called only when a node\n  is shutting down. This is good if called only from ASP AMF component, since\n  only this component know when the node is going down.\n\n  \\sa\n  clIocMulticastRegister(),\n  clIocMulticastDeregister().\n\n\n"]
    pub fn clIocMulticastDeregisterAll(pMcastAddress: *mut ClIocMulticastAddressT) -> ClRcT;
}
extern "C" {
    #[doc = "  \\brief Returns the local IOC node addrress.\n\n  \\par Header File:\n  clIocApi.h\n\n  \\par Library Files:\n  libClIoc\n\n  \\par Parameters:\n  None\n\n  \\par Return values:\n  On successful execution this API returns the local IOC node\n  address. In case of error, the API returns 0.\n\n  \\par Description:\n  This API returns the IOC node address of the current node.\n"]
    pub fn clIocLocalAddressGet() -> ClIocNodeAddressT;
}
extern "C" {
    #[doc = "  \\brief Checks for appropriate version of application.\n\n  \\par Header File:\n  clIocApi.h\n\n  \\par Library Files:\n  libClIoc\n\n  \\par Parameters:\n  None\n\n  \\retval CL_OK The API is successfully executed.\n\n  \\par Description:\n  This API checks whether the application version matches\n  with any of the supported versions of the IOC client\n  library and server module. If it doesnot then returns error.\n\n"]
    pub fn clIocVersionCheck(pVersion: *mut ClVersionT) -> ClRcT;
}
extern "C" {
    pub fn clIocTransparencyLogicalToPhysicalAddrGet(
        logicalAddr: ClIocLogicalAddressT,
        pPhysicalAddr: *mut *mut ClIocTLMappingT,
        pNoEntries: *mut ClUint32T,
    ) -> ClRcT;
}
