pub use crate::clBindings::clTimerApi::*;
pub use crate::clBindings::clCommon::*;
pub use crate::clBindings::clDbg::*;
pub use crate::clBindings::clLogUtilApi::*;
pub use crate::clBindings::clLogIpiWrap::*;
/* automatically generated by rust-bindgen 0.66.1 */

pub const CL_LOG_STREAM_NAME_MAX_LENGTH: u32 = 128;
pub const CL_LOG_SLINE_MSG_LEN: u32 = 256;
pub const CL_LOG_STREAM_CREATE: u32 = 1;
pub const CL_LOG_HANDLER_WILL_ACK: u32 = 1;
pub const CL_LOG_FILTER_ASSIGN: u32 = 1;
pub const CL_LOG_FILTER_MERGE_ADD: u32 = 2;
pub const CL_LOG_FILTER_MERGE_DELETE: u32 = 3;
pub const CL_LOG_MSGID_BUFFER: u32 = 0;
pub const CL_LOG_MSGID_PRINTF_FMT: u32 = 1;
pub const CL_LOG_TAG_TERMINATE: u32 = 0;
pub const CL_LOG_TAG_BASIC_SIGNED: u32 = 1;
pub const CL_LOG_TAG_BASIC_UNSIGNED: u32 = 2;
pub const CL_LOG_TAG_STRING: u32 = 3;
pub const CL_LOG_PRNT_FMT_STR: &[u8; 36] = b"%-26s [%s:%d] (%.*s.%d : %s.%3s.%3s\0";
pub const CL_LOG_PRNT_FMT_STR_CONSOLE: &[u8; 49] =
    b"%-26s [%s:%d] (%.*s.%d : %s.%3s.%3s.%05d : %6s) \0";
pub const CL_LOG_PRNT_FMT_STR_WO_FILE: &[u8; 28] = b"%-26s (%.*s.%d : %s.%3s.%3s\0";
pub const CL_LOG_PRNT_FMT_STR_WO_FILE_CONSOLE: &[u8; 41] =
    b"%-26s (%.*s.%d : %s.%3s.%3s.%05d : %6s) \0";
#[doc = " The type of handle supplied by Log Service during initialization."]
pub type ClLogHandleT = ClHandleT;
#[doc = " The type of handle supplied by Log Service during log streamOpen and\n a process register itself as stream handler for the stream."]
pub type ClLogStreamHandleT = ClHandleT;
#[doc = " The type of handle supplied by Log Service to a process\n who has opened a file for consuming log records."]
pub type ClLogFileHandleT = ClHandleT;
#[doc = " Flags specifies the streams global to the node."]
pub const ClLogStreamScopeT_CL_LOG_STREAM_GLOBAL: ClLogStreamScopeT = 0;
#[doc = " Flag specifies the streams local to the node."]
pub const ClLogStreamScopeT_CL_LOG_STREAM_LOCAL: ClLogStreamScopeT = 1;
#[doc = " This enumeration is used to specify the scope of the stream.\n A stream can be local to the node(Local log stream) or global\n to the cluster(Global log stream)."]
pub type ClLogStreamScopeT = ::std::os::raw::c_uint;
#[doc = " It directs the Log Service to create a new Log File Unit when the current\n Log File Unit becomes full. The number of maximum Log File Units that can\n simultaneously exist is limited by maxFilesRotated attribute of the Log Stream.\n Once this limit is reached, the oldest Log File Unit is deleted and a new one is\n created."]
pub const ClLogFileFullActionT_CL_LOG_FILE_FULL_ACTION_ROTATE: ClLogFileFullActionT = 0;
#[doc = " It makes the Log Service treat the Log File as a circular buffer, i.e., when the Log\n File becomes full, Log Service starts overwriting oldest records."]
pub const ClLogFileFullActionT_CL_LOG_FILE_FULL_ACTION_WRAP: ClLogFileFullActionT = 1;
#[doc = " Log Service stops putting more records in the Log File once it becomes full."]
pub const ClLogFileFullActionT_CL_LOG_FILE_FULL_ACTION_HALT: ClLogFileFullActionT = 2;
#[doc = " This enumeration is used to specify the behavior of Log Service once the Log\n File into which this Log Stream is going becomes full."]
pub type ClLogFileFullActionT = ::std::os::raw::c_uint;
#[doc = " This structure describes the attributes of the stream."]
#[repr(C)]
pub struct ClLogStreamAttributesT {
    #[doc = " Its the prefix name of file units that are going to be created."]
    pub fileName: *mut ClCharT,
    #[doc = " Its the path where the log file unit(s) will be created."]
    pub fileLocation: *mut ClCharT,
    #[doc = " Size of the file unit. It will be truncated to multiples of recordSize."]
    pub fileUnitSize: ClUint32T,
    #[doc = " Size of the log record."]
    pub recordSize: ClUint32T,
    #[doc = " Log file replication property. Currently is not supported."]
    pub haProperty: ClBoolT,
    #[doc = " Action that log service has to take, when the log file unit becomes full."]
    pub fileFullAction: ClLogFileFullActionT,
    #[doc = " If fileAction is CL_LOG_FILE_FULL_ACTION_ROTATE, the maximum num of log\n file units that will be created by logService.Otherwise ignored."]
    pub maxFilesRotated: ClUint32T,
    #[doc = " Num of log records after which the log stream records must be flushed."]
    pub flushFreq: ClUint32T,
    #[doc = " Time after which the log stream records must be flushed."]
    pub flushInterval: ClTimeT,
    #[doc = " The water mark for file units.When the size of file reaches this level,\n the water mark event will be published."]
    pub waterMark: ClWaterMarkT,
    pub syslog: ClBoolT,
}
#[test]
fn bindgen_test_layout_ClLogStreamAttributesT() {
    const UNINIT: ::std::mem::MaybeUninit<ClLogStreamAttributesT> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ClLogStreamAttributesT>(),
        72usize,
        concat!("Size of: ", stringify!(ClLogStreamAttributesT))
    );
    assert_eq!(
        ::std::mem::align_of::<ClLogStreamAttributesT>(),
        8usize,
        concat!("Alignment of ", stringify!(ClLogStreamAttributesT))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fileName) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ClLogStreamAttributesT),
            "::",
            stringify!(fileName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fileLocation) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ClLogStreamAttributesT),
            "::",
            stringify!(fileLocation)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fileUnitSize) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ClLogStreamAttributesT),
            "::",
            stringify!(fileUnitSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).recordSize) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ClLogStreamAttributesT),
            "::",
            stringify!(recordSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).haProperty) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ClLogStreamAttributesT),
            "::",
            stringify!(haProperty)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fileFullAction) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(ClLogStreamAttributesT),
            "::",
            stringify!(fileFullAction)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxFilesRotated) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ClLogStreamAttributesT),
            "::",
            stringify!(maxFilesRotated)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flushFreq) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(ClLogStreamAttributesT),
            "::",
            stringify!(flushFreq)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flushInterval) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ClLogStreamAttributesT),
            "::",
            stringify!(flushInterval)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).waterMark) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ClLogStreamAttributesT),
            "::",
            stringify!(waterMark)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).syslog) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(ClLogStreamAttributesT),
            "::",
            stringify!(syslog)
        )
    );
}
#[doc = " This flags to specify the stream should be created or opened."]
pub type ClLogStreamOpenFlagsT = ClUint8T;
#[doc = " This structure describes all the information about the log stream."]
#[repr(C)]
pub struct ClLogStreamInfoT {
    #[doc = " Name of the log stream."]
    pub streamName: ClNameT,
    #[doc = " Scope of the log stream."]
    pub streamScope: ClLogStreamScopeT,
    #[doc = " The name of the node on which the stream exist."]
    pub streamScopeNode: ClNameT,
    #[doc = " The unique id for the stream in the cluster."]
    pub streamId: ClUint16T,
    #[doc = " Attributes of the log stream."]
    pub streamAttr: ClLogStreamAttributesT,
}
#[test]
fn bindgen_test_layout_ClLogStreamInfoT() {
    const UNINIT: ::std::mem::MaybeUninit<ClLogStreamInfoT> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ClLogStreamInfoT>(),
        600usize,
        concat!("Size of: ", stringify!(ClLogStreamInfoT))
    );
    assert_eq!(
        ::std::mem::align_of::<ClLogStreamInfoT>(),
        8usize,
        concat!("Alignment of ", stringify!(ClLogStreamInfoT))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).streamName) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ClLogStreamInfoT),
            "::",
            stringify!(streamName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).streamScope) as usize - ptr as usize },
        260usize,
        concat!(
            "Offset of field: ",
            stringify!(ClLogStreamInfoT),
            "::",
            stringify!(streamScope)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).streamScopeNode) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(ClLogStreamInfoT),
            "::",
            stringify!(streamScopeNode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).streamId) as usize - ptr as usize },
        522usize,
        concat!(
            "Offset of field: ",
            stringify!(ClLogStreamInfoT),
            "::",
            stringify!(streamId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).streamAttr) as usize - ptr as usize },
        528usize,
        concat!(
            "Offset of field: ",
            stringify!(ClLogStreamInfoT),
            "::",
            stringify!(streamAttr)
        )
    );
}
#[doc = " This structure describes the information about the log stream to\n stream Id mapping."]
#[repr(C)]
pub struct ClLogStreamMapT {
    #[doc = " Name of the log stream."]
    pub streamName: ClNameT,
    #[doc = " Scope of the log stream."]
    pub streamScope: ClLogStreamScopeT,
    #[doc = " Node name on which the stream exist."]
    pub nodeName: ClNameT,
    #[doc = " Unique id of the stream in the cluster."]
    pub streamId: ClUint16T,
}
#[test]
fn bindgen_test_layout_ClLogStreamMapT() {
    const UNINIT: ::std::mem::MaybeUninit<ClLogStreamMapT> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ClLogStreamMapT>(),
        524usize,
        concat!("Size of: ", stringify!(ClLogStreamMapT))
    );
    assert_eq!(
        ::std::mem::align_of::<ClLogStreamMapT>(),
        4usize,
        concat!("Alignment of ", stringify!(ClLogStreamMapT))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).streamName) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ClLogStreamMapT),
            "::",
            stringify!(streamName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).streamScope) as usize - ptr as usize },
        260usize,
        concat!(
            "Offset of field: ",
            stringify!(ClLogStreamMapT),
            "::",
            stringify!(streamScope)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nodeName) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(ClLogStreamMapT),
            "::",
            stringify!(nodeName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).streamId) as usize - ptr as usize },
        522usize,
        concat!(
            "Offset of field: ",
            stringify!(ClLogStreamMapT),
            "::",
            stringify!(streamId)
        )
    );
}
#[doc = " While registering as strean handler, the process should specify\n this flag."]
pub type ClLogStreamHandlerFlagsT = ClUint8T;
#[doc = " setting severity as EMERGENCY."]
pub const ClLogSeverityT_CL_LOG_SEV_EMERGENCY: ClLogSeverityT = 1;
#[doc = " setting severity as ALERT."]
pub const ClLogSeverityT_CL_LOG_SEV_ALERT: ClLogSeverityT = 2;
#[doc = " setting severity as CRITICAL."]
pub const ClLogSeverityT_CL_LOG_SEV_CRITICAL: ClLogSeverityT = 3;
#[doc = " setting severity as ERROR."]
pub const ClLogSeverityT_CL_LOG_SEV_ERROR: ClLogSeverityT = 4;
#[doc = " setting severity as WARNING."]
pub const ClLogSeverityT_CL_LOG_SEV_WARNING: ClLogSeverityT = 5;
#[doc = " setting severity as NOTICE."]
pub const ClLogSeverityT_CL_LOG_SEV_NOTICE: ClLogSeverityT = 6;
#[doc = " setting severity as INFORMATION."]
pub const ClLogSeverityT_CL_LOG_SEV_INFO: ClLogSeverityT = 7;
#[doc = " setting severity as DEBUG."]
pub const ClLogSeverityT_CL_LOG_SEV_DEBUG: ClLogSeverityT = 8;
#[doc = " setting severity as DEBUG."]
pub const ClLogSeverityT_CL_LOG_SEV_DEBUG1: ClLogSeverityT = 8;
#[doc = " setting severity as DEBUG."]
pub const ClLogSeverityT_CL_LOG_SEV_DEBUG2: ClLogSeverityT = 9;
#[doc = " setting severity as DEBUG."]
pub const ClLogSeverityT_CL_LOG_SEV_DEBUG3: ClLogSeverityT = 10;
#[doc = " setting severity as DEBUG."]
pub const ClLogSeverityT_CL_LOG_SEV_DEBUG4: ClLogSeverityT = 11;
#[doc = " setting severity as DEBUG."]
pub const ClLogSeverityT_CL_LOG_SEV_DEBUG5: ClLogSeverityT = 12;
#[doc = " setting severity as DEBUG."]
pub const ClLogSeverityT_CL_LOG_SEV_TRACE: ClLogSeverityT = 12;
#[doc = " setting severity as DEBUG."]
pub const ClLogSeverityT_CL_LOG_SEV_DEBUG6: ClLogSeverityT = 13;
#[doc = " setting severity as DEBUG."]
pub const ClLogSeverityT_CL_LOG_SEV_DEBUG7: ClLogSeverityT = 14;
#[doc = " setting severity as DEBUG."]
pub const ClLogSeverityT_CL_LOG_SEV_DEBUG8: ClLogSeverityT = 15;
#[doc = " setting severity as DEBUG."]
pub const ClLogSeverityT_CL_LOG_SEV_DEBUG9: ClLogSeverityT = 16;
#[doc = " Maximum severity level."]
pub const ClLogSeverityT_CL_LOG_SEV_MAX: ClLogSeverityT = 16;
pub type ClLogSeverityT = ::std::os::raw::c_uint;
#[doc = " Variables of this type is used as a bitmap. Values from\n ClLogSeverityT are used to set the individual bits in the\n bitmap."]
pub type ClLogSeverityFilterT = ClUint16T;
#[doc = " It takes the values of above specifed flags."]
pub type ClLogFilterFlagsT = ClUint8T;
#[doc = " This structure describes the filter settings for the stream."]
#[repr(C)]
pub struct ClLogFilterT {
    #[doc = " This field identifies the severity level."]
    pub severityFilter: ClLogSeverityFilterT,
    #[doc = " The size of the memory pointed by pMsgIdSet in bytes."]
    pub msgIdSetLength: ClUint16T,
    #[doc = " This memory will be treated as bitmap to mask the message ids"]
    pub pMsgIdSet: *mut ClUint8T,
    #[doc = " The size of the memory pointed by pCompIdSet in bytes."]
    pub compIdSetLength: ClUint16T,
    #[doc = " This memory will be treated as bitmap to mask the component ids"]
    pub pCompIdSet: *mut ClUint8T,
}
#[test]
fn bindgen_test_layout_ClLogFilterT() {
    const UNINIT: ::std::mem::MaybeUninit<ClLogFilterT> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ClLogFilterT>(),
        32usize,
        concat!("Size of: ", stringify!(ClLogFilterT))
    );
    assert_eq!(
        ::std::mem::align_of::<ClLogFilterT>(),
        8usize,
        concat!("Alignment of ", stringify!(ClLogFilterT))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).severityFilter) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ClLogFilterT),
            "::",
            stringify!(severityFilter)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msgIdSetLength) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(ClLogFilterT),
            "::",
            stringify!(msgIdSetLength)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pMsgIdSet) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ClLogFilterT),
            "::",
            stringify!(pMsgIdSet)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).compIdSetLength) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ClLogFilterT),
            "::",
            stringify!(compIdSetLength)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pCompIdSet) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ClLogFilterT),
            "::",
            stringify!(pCompIdSet)
        )
    );
}
#[doc = "  \\brief This function gets called When clLogStreamOpenAsync() call\n   returns on the server.\n\n  \\par Header File:\n  clLogApi.h\n\n  \\param invocation (in) invocation value of the call. This is basically an\n  identification about the call.\n\n  \\param hStream (in) contains handle of the opened stream, if the\n  clLogStreamOpenAsync() was succesfull.\n\n  \\param rc (in) return value of the clLogStreamOpenAsync() call.\n\n  \\retval  CL_OK The Log stream is opened successfully.\n\n  \\retval  CL_ERR_NOT_EXIST \\c CL_LOG_STREAM_CREATE flag is not set in streamOpenFlags and\n  the Stream does not exist.\n\n  \\retval CL_ERR_ALREADY_EXIST \\c CL_LOG_STREAM_CREATE flag is set in streamOpenFlags but\n  the Stream already exists and was originally created with different\n  attributes than specified by pStreamAttributes.\n\n  \\retval  CL_ERR_TIMEOUT An implementation defined timeout occurred before the call\n  could complete.\n\n  \\retval  CL_ERR_TRY_AGAIN The service could not be provided at this time.\n  The process may try later.\n\n  \\retval  CL_ERR_NO_MEMORY Either the Log Service library or some other module of\n  Log Service is out of memory. Thus service can not be provided at this time. This\n  may be a transient problem.\n\n  \\retval  CL_ERR_NO_RESOURCE Either the Log Service library or some other module\n  of Log Service is out of resources (other than memory). Thus, service can not be\n  provided at this time. This may be a transient problem.\n\n  \\par Description:\n  This streamOpen callback function is getting called, when\n  clLogStreamOpenAsync() call returns from the server. It carries the\n  invocation to identify the call and return code for indicating the status\n  of the call. If the retcode is CL_OK, then hStream will be carrying\n  the proper handle of the stream which was opened on the particular\n  invocation.\n\n  \\par Library File:\n  ClLogClient\n\n  \\sa clLogOpenStreamAsync()\n"]
pub type ClLogStreamOpenCallbackT = ::std::option::Option<
    unsafe extern "C" fn(invocation: ClInvocationT, hStream: ClLogStreamHandleT, rc: ClRcT),
>;
#[doc = "  \\brief Informs the logger about a change in filter settings of a Log\n  stream opened by this logger.\n\n  \\par Header File:\n  clLogApi.h\n\n  \\param hStream (in) contains handle of the stream for which the filter\n  settings have been updated.\n\n  \\param filter (in) New filter settings of the stream.\n\n  \\retval  none\n\n  \\par Description:\n  The Log Service invokes this function when the filter associated with a Log\n  Stream identified by hStream is changed either by a Logger or north-bound\n  interface. The Log Stream must be currently opened by this Logger. If either\n  pLogCallbacks parameter to clLogInitialize call was NULL or\n  clLogFilterSetCallback of that parameter was NULL, the Logger will not be\n  informed about change in filter settings.\n\n  \\par Library File:\n  ClLogClient\n\n  \\sa clLogFilterSet()\n"]
pub type ClLogFilterSetCallbackT =
    ::std::option::Option<unsafe extern "C" fn(hStream: ClLogStreamHandleT, filter: ClLogFilterT)>;
#[doc = "  \\brief Callback function to receive log records of Log streams of\n  interest.\n\n  \\par Header File:\n  clLogApi.h\n\n  \\param hStream (in) Handle obtained through a previous invocation to\n  clLogHandlerRegister(). This handle identifies the registration of handler\n  for a stream for which the Log Records are being delivered.\n\n  \\param sequenceNumber (in): A monotonically increasing no to detect the duplicate\n  delivery of a set of Log Records. It includes the node identifier and the\n  starting sequence number of the records.\n\n  \\param numRecords (in): Number of records in the buffer pointer by logRecords.\n\n  \\param pRecords (in): Pointer to a buffer that contains numRecords number of Log\n   Records from a stream identified by hStream.\n\n  \\param filter (in) New filter settings of the stream.\n\n  \\retval  none\n\n  \\par Description:\n   This callback delivers a set of new Log Records to the handlers. These\n   records will no more be available in the Log Stream.\n   This callback may be invoked multiple times for the same set of records,\n   which can be detected by the same sequenceNumber.\n   Memory for pRecords is allocated by the Log Service and must be freed by the\n   Handler.\n\n  \\par Library File:\n   ClLogClient\n\n  \\sa clLogFilterSet()\n"]
pub type ClLogRecordDeliveryCallbackT = ::std::option::Option<
    unsafe extern "C" fn(
        hStream: ClLogStreamHandleT,
        seqNum: ClUint64T,
        numRecords: ClUint32T,
        pRecords: ClPtrT,
    ),
>;
#[doc = " This structure describes about the callbacks which can be provided by\n process while initializing with Log Service."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ClLogCallbacksT {
    #[doc = " Callback for stream open."]
    pub clLogStreamOpenCb: ClLogStreamOpenCallbackT,
    #[doc = " Callback for informing filter settings updation."]
    pub clLogFilterSetCb: ClLogFilterSetCallbackT,
    #[doc = " Callback for delivering records to stream handlers."]
    pub clLogRecordDeliveryCb: ClLogRecordDeliveryCallbackT,
}
#[test]
fn bindgen_test_layout_ClLogCallbacksT() {
    const UNINIT: ::std::mem::MaybeUninit<ClLogCallbacksT> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ClLogCallbacksT>(),
        24usize,
        concat!("Size of: ", stringify!(ClLogCallbacksT))
    );
    assert_eq!(
        ::std::mem::align_of::<ClLogCallbacksT>(),
        8usize,
        concat!("Alignment of ", stringify!(ClLogCallbacksT))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).clLogStreamOpenCb) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ClLogCallbacksT),
            "::",
            stringify!(clLogStreamOpenCb)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).clLogFilterSetCb) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ClLogCallbacksT),
            "::",
            stringify!(clLogFilterSetCb)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).clLogRecordDeliveryCb) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ClLogCallbacksT),
            "::",
            stringify!(clLogRecordDeliveryCb)
        )
    );
}
extern "C" {
    #[doc = "  \\brief  Initializes the Log service for the calling process and ensures\n  the version compatability.\n\n  \\par Header File:\n  clLogApi.h\n\n  \\param phLog (out) Handle returned by the Log Service. This handle is used\n  by the calling process for subsequent invocation LogAPIs. Each invocation of\n  clLogInitialize() returns the new log handle.\n\n  \\param pLogCallbacks (in) contains callback functions which can be invoked\n  on calling process.\n\n  \\param pVersion (in/out)  As an input parameter, version is a pointer to the required\n  Log Service version.  As an output parameter, the version actually supported by the\n  Log Service is delivered.\n\n  \\retval  CL_OK The Log Service is initialized successfully.\n\n  \\retval  CL_ERR_VERSION_MISMATCH The supplied version is not supported by current\n  implementation.\n\n  \\retval  CL_ERR_TIMEOUT An implementation defined timeout occurred before the call\n  could complete.\n\n  \\retval  CL_ERR_TRY_AGAIN The service could not be provided at this time.\n  The process may try later.\n\n  \\retval  CL_ERR_NULL_POINTER Either phLog or pVersion is passed as NULL.\n\n  \\retval  CL_ERR_NO_MEMORY Either the Log Service library or some other module of\n  Log Service is out of memory. Thus service can not be provided at this time. This\n  may be a transient problem.\n\n  \\retval  CL_ERR_NO_RESOURCE Either the Log Service library or some other module\n  of Log Service is out of resources (other than memory). Thus, service can not be\n  provided at this time. This may be a transient problem.\n\n  \\par Description:\n  This function initializes the Log Service for the invoking process, performs\n  version compatibility checks and registers various callbacks provided. This\n  function must be invoked before any other function of Log Service API. The\n  handle phLog is returned as the reference to this association of the process\n  and Log Service. The process uses this handle in subsequent interaction with\n  Log Service.\n\n  \\par Library File:\n  ClLogClient\n\n  \\sa clLogFinalize()\n"]
    pub fn clLogInitialize(
        phLog: *mut ClLogHandleT,
        pLogCallbacks: *const ClLogCallbacksT,
        pVersion: *mut ClVersionT,
    ) -> ClRcT;
}
extern "C" {
    #[doc = "  \\brief  Finalize the Log service for the calling process and ensures\n  to release all the resources.\n\n  \\par Header File:\n  clLogApi.h\n\n  \\param hLog (in) Handle obtained by the previous invocation\n  clLogInitialize. This handle identifies the association to be closed\n  between the calling process and LogService.\n\n  \\retval  CL_OK The Log Service is finalized successfully.\n\n  \\retval  CL_ERR_INVALID_HANDLE The passed handle is either not obtained\n  through clLogInitialize() or this handle association has been already closed\n  by another invocation clLogFinalize().\n\n  \\retval  CL_ERR_TIMEOUT An implementation defined timeout occurred before the call\n  could complete.\n\n  \\retval  CL_ERR_TRY_AGAIN The service could not be provided at this time.\n  The process may try later.\n\n  \\retval  CL_ERR_NO_MEMORY Either the Log Service library or some other module of\n  Log Service is out of memory. Thus service can not be provided at this time. This\n  may be a transient problem.\n\n  \\retval  CL_ERR_NO_RESOURCE Either the Log Service library or some other module\n  of Log Service is out of resources (other than memory). Thus, service can not be\n  provided at this time. This may be a transient problem.\n\n  \\par Description:\n  This function closes the association between the Log Service and the invoking\n  process, identified by the handle hLog, and frees up all the resource\n  acquired by this association. Other functions of Log Service API function\n  must not be invoked after a successful invocation to this function. Process\n  must have acquired hLog through a previous successful invocation to\n  clLogInitialize(). For each successful invocation to clLogInitialize(), the\n  process must invoke clLogFinalize() before going down gracefully. On\n  successful completion, this function frees up all the resources acquired by\n  this association. All opened Log Stream are closed, all registrations for Log\n  Stream Handlers are de-registered, and all opened Log File handles are\n  closed.\n\n  \\par Library File:\n  ClLogClient\n\n  \\sa clLogInitialize()\n"]
    pub fn clLogFinalize(hLog: ClLogHandleT) -> ClRcT;
}
extern "C" {
    #[doc = "  \\brief Opens the stream for Logging.\n\n  \\par Header File:\n  clLogApi.h\n\n  \\param hLog (in) Handle obtained by the previous invocation\n  clLogInitialize. This handle identifies the association\n  between the calling process and LogService.\n\n  \\param streamName (in) The name of the Log Stream to be opened\n  for logging. It can be one of the pre-defined (modeled) Log Streams\n  or one being dynamically created.\n\n  \\param streamScope (in) Scope of the Log Stream. It can have the following\n  values:\n  \\arg \\c CL_LOG_STREAM_GLOBAL\n  \\arg \\c CL_LOG_STREAM_LOCAL\n\n  \\param pStreamAttributes (in) Attributes of the Log Stream to be opened.\n  If a pre-defined Log Stream is being opened, then this should be NULL.\n  If the intent is only to open an existing Log Stream identified by\n  streamName and streamScope, then this value must be NULL. If the intent\n  is to open and create a non-existing Log Stream, then this parameter must\n  be filled with the attributes of the new Stream and streamOpenFlags must\n  be ORed with \\c CL_LOG_STREAM_CREATE. If the intent is to open and possibly\n  create (if not already created) Stream, then this parameter must be filled\n  with the attributes of the new Stream. These attributes must match with\n  the attributes of the Stream, if it happened to be already created.\n\n  \\param streamOpenFlags (in) flags to create/open the stream.\n  \\c CL_LOG_STREAM_CREATE must be specified if the intention is to open and\n  create a non-existent Stream or to open and possibly create (if not\n  already created) Stream. In case of pre-defined Streams, \\c CL_LOG_STREAM_CREATE\n  must not be specified.\n\n  \\param timeout (in) This is applicable only for clLogStreamOpen(). If the call does\n  not complete in this time, the call is considered to have failed. The Log\n  Stream might have been opened and/or created, but the outcome is\n  non-deterministic. A value of zero indicates no timeout.\n\n  \\param Invocation (in) This is applicable only for clLogStreamOpenAsync(). This is\n  used to co-relate the response received through ClLogStreamOpenCallbackT.\n\n  \\param phLogStream (out) Pointer to get the Log Service generated handle for this\n  Log Stream. This handle must be used for subsequent operations on this Log\n  Stream.\n\n  \\retval  CL_OK The Log stream is opened successfully.\n\n  \\retval  CL_ERR_INVALID_HANDLE The passed handle(hLog) is either not obtained\n  through clLogInitialize() or this handle association has been already closed\n  by another invocation clLogFinalize().\n\n  \\retval CL_ERR_NULL_POINTER Either pStreamAttributes or phStream is\n  passed as NULL.\n\n  \\retval CL_ERR_INVALID_PARAMETER Some of the parameters passed are not valid.\n  The conditions are:\n  \\arg \\c The streamOpenFlags does not have \\c CL_LOG_STREAM_CREATE set and\n  pStreamAttributes is not NULL.\n  \\arg \\c The streamOpenFlags has \\c CL_LOG_STREAM_CREATE set and pStreamAttributes\n  is NULL.\n  \\arg \\c Length field of streamName is set to zero.\n  \\arg \\c fileLocation member of pStreamAttributes does not follow the pattern\n  defined ::ClLogStreamAttributesT. fileName member of pStreamAttributes does\n  not follow the pattern defined in ::ClLogStreamAttributesT.\n  \\arg \\c fileUnitSize member of pStreamAttributes is the size of the individual file\n  unit, in bytes.\n  \\arg \\c fileFullAction member of pStreamAttributes does not have a value\n  defined in ::ClLogFileFullActionT.\n  \\arg \\c Both flushFreq and flushInterval members of pStreamAttributes are set to zero.\n  \\arg \\c waterMark member of pStreamAttributes have values outside 0-100 range.\n  \\arg \\c streamScope does not have a value defined in ::ClLogStreamScopeT.\n  \\arg \\c timeout is specified as a negative value.\n\n  \\retval  CL_ERR_NOT_EXIST \\c CL_LOG_STREAM_CREATE flag is not set in streamOpenFlags and\n  the Stream does not exist.\n\n  \\retval  CL_ERR_ALREADY_EXIST \\c CL_LOG_STREAM_CREATE flag is set in streamOpenFlags but\n  the Stream already exists and was originally created with different\n  attributes than specified by pStreamAttributes.\n\n  \\retval  CL_ERR_TIMEOUT An implementation defined timeout occurred before the call\n  could complete.\n\n  \\retval  CL_ERR_TRY_AGAIN The service could not be provided at this time.\n  The process may try later.\n\n  \\retval  CL_ERR_NO_MEMORY Either the Log Service library or some other module of\n  Log Service is out of memory. Thus service can not be provided at this time. This\n  may be a transient problem.\n\n  \\retval  CL_ERR_NO_RESOURCE Either the Log Service library or some other module\n  of Log Service is out of resources (other than memory). Thus, service can not be\n  provided at this time. This may be a transient problem.\n\n  \\par Description:\n  This function opens a Log Stream for logging. If the Log Stream is not a\n  pre-defined Stream and application wants to possibly create it, then\n  pStreamAttributes must be specified and \\c CL_LOG_STREAM_CREATE must be set in\n  streamOpenFlags. If \\c CL_LOG_STREAM_CREATE is set in streamOpenFlags, then\n  pStreamAttributes must be specified, otherwise it must be NULL. Further, if\n  pStreamAttributes is non-NULL, then at-least one of flushFreq and\n  flushInterval members of pStreamAttributes must be non-zero.\n  Invocation to clLogStreamOpen() is blocking. If the Log Stream is\n  successfully opened, handle to newly opened stream is returned in phStream,\n  otherwise and error is retured.\n\n  \\par Library File:\n  ClLogClient\n\n  \\sa clLogStreamClose(), clLogWriteAsync()\n"]
    pub fn clLogStreamOpen(
        hLog: ClLogHandleT,
        streamName: ClNameT,
        streamScope: ClLogStreamScopeT,
        pStreamAttr: *mut ClLogStreamAttributesT,
        streamOpenFlags: ClLogStreamOpenFlagsT,
        timeout: ClTimeT,
        phStream: *mut ClLogStreamHandleT,
    ) -> ClRcT;
}
extern "C" {
    #[doc = "  \\brief Close the stream opened for logging.\n\n  \\par Header File:\n  clLogApi.h\n\n  \\param hStream (in) Handle obtained by the previous invocation\n  clLogStreamOpen(). This handle identifies the log stream to be closed.\n\n  \\retval  CL_OK The Log Stream is closed successfully.\n\n  \\retval  CL_ERR_INVALID_HANDLE The passed Log Stream handle is not valid.\n  Either it is not received through a previous invocation to clLogStreamOpen()\n  or it has already been closed through an invocation to clLogStreamClose().\n\n  \\retval  CL_ERR_TIMEOUT An implementation defined timeout occurred before the call\n  could complete.\n\n  \\retval  CL_ERR_TRY_AGAIN The service could not be provided at this time.\n  The process may try later.\n\n  \\retval  CL_ERR_NO_MEMORY Either the Log Service library or some other module of\n  Log Service is out of memory. Thus service can not be provided at this time. This\n  may be a transient problem.\n\n  \\retval  CL_ERR_NO_RESOURCE Either the Log Service library or some other module\n  of Log Service is out of resources (other than memory). Thus, service can not be\n  provided at this time. This may be a transient problem.\n\n  \\par Description:\n  This function closes a Log Stream identified by \\e hStream. \\e hStream must have\n  been obtained through a previous invocation of either clLogStreamOpen()\n  or clLogStreamOpenAsync(). After successful completion of this function or a\n  failure with return value CL_ERR_TIMEOUT, hStream is no longer valid and must\n  not be used for any other stream related operations. If hStream represents a\n  Log Stream which is not pre-defined and that Log Stream is not opened by any\n  process in the cluster, the Log Stream is deleted. When all the Log Streams\n  being persisted in the same Log File are deleted, the Log File is closed.\n  Closing a Log Stream releases all the resources allocated by Log Service to\n  this instance of opening. If a process terminates without closing Log Streams\n  opened by it, Log Service implicitly closes all such Log Streams.\n  On successful completion of this call, all pending callbacks referring to\n  this hStream are cancelled. Since the invocation of callbacks is an\n  asynchronous operation, some callbacks may still be delivered after this call\n  returns successfully.\n\n  \\par Library File:\n  ClLogClient\n\n  \\sa clLogStreamOpen()\n"]
    pub fn clLogStreamClose(hStream: ClLogStreamHandleT) -> ClRcT;
}
extern "C" {
    #[doc = "  \\brief Logs a Log Record in the specified Log Stream.\n\n  \\par Header File:\n  clLogApi.h, clLogErrors.h\n\n  \\param hStream (in) Handle obtained by the previous invocation\n  clLogStreamOpen(). This handle identifies the Log Stream on which the log\n  record to be placed.\n\n  \\param severity (in) This field must be set to one of the values defined.\n  It defines the severity level of the Log Record being written.\n\n  \\param serviceId (in) This field identifies the module within the process\n  which is generating this Log Record. If the Log Record message is a generic\n  one like out of memory, this field can be used to narrow down on the module\n  impacted. For ASP client libraries, these values are defined in clCommon.h.\n  For application modules, it is up-to the application developer to define the\n  values and scope of those values.\n\n  \\param msgId (in) This field identifies the actual message to be Logged.\n  This is typically an identifier for a string message which the viewer is aware\n  of through off-line mechanism. Rest of the arguments of this function are\n  interpreted by the viewer based on this identifier. For application Log\n  Streams, the values and scope of each value is defined by the application\n  developer. Following two values are pre-defined:\n  \\arg \\c CL_LOG_MSGID_BUFFER\n  \\arg \\c CL_LOG_MSGID_PRINTF_FMT\n\n  In case, msgId is passed as CL_LOG_MSGID_BUFFER, it is followed by two\n  parameters:\n  \\arg \\c First one is of type ClUint32T. It is the number of bytes in the buffer\n  pointed by the second parameter.\n  \\arg \\c Second one is a pointer to a buffer. It is of type ClPtrT. The buffer may\n  contain binary or ASCII data. The number of bytes of useful data is indicated\n  by previous parameter. In case the buffer contains ASCII data, if the buffer\n  is NULL terminated, the length must include the NULL termination byte. This\n  buffer is not freed by the Log Service.\n  In case, msgId is passed as \\c CL_LOG_MSGID_PRINTF_FMT, the next argument is\n  treated as format string of printf (3). Rest of the arguments are interpreted\n  as per this format string.\n  For other values of msgId, rest of arguments are treated as a set of 3-tuples.\n  Each of these tuple is of the form <Tag, Length, Value Pointer>. The tuple of\n  3 arguments is interpreted as follows\n  First one is of type ClUint16T. It is treated as the tag to identify contents\n  of third argument in this tuple.\n  Second one is of type ClUint16T. It is treated as number of bytes in the\n  buffer pointed by third argument.\n  Third one is of type ::ClPtrT. The buffer may contain binary or ASCII data,\n  which is defined by the tag (first argument in this tuple). The Log Service\n  does not interpret this buffer. Only the Log Consumer interprets it and must\n  be aware of the semantic meaning of its contents. It simply copies this buffer\n  in the Log Record. In case of ASCII data, if the buffer is NULL terminated,\n  the length must include the NULL termination byte. This buffer is not freed by\n  the Log Service.\n  End of this set of tuple is indicated by a special tag \\c CL_LOG_TAG_TERMINATE.\n  Thus, the variable part of this argument list will always have 3*n + 1,\n  where n is the number of parameters to be logged. Following tag values are\n  defined by Log Service, rests are defined by the application.\n  \\arg \\c CL_LOG_TAG_TERMINATE\n  \\arg \\c CL_LOG_TAG_BASIC_SIGNED\n  \\arg \\c CL_LOG_TAG_BASIC_UNSIGNED\n  \\arg \\c CL_LOG_TAG_STRING\n  Log Service also defines following macros to ease the use of this function.\n  \\arg \\c CL_LOG_TLV_UINT8(var)\n  \\arg \\c CL_LOG_TLV_INT8(var)\n  \\arg \\c CL_LOG_TLV_UINT16(var)\n  \\arg \\c CL_LOG_TLV_INT16(var)\n  \\arg \\c CL_LOG_TLV_UINT32(var)\n  \\arg \\c CL_LOG_TLV_INT32(var)\n  \\arg \\c CL_LOG_TLV_UINT64(var)\n  \\arg \\c CL_LOG_TLV_INT64(var)\n  \\arg \\c CL_LOG_TLV_STRING(var)\n\n  \\retval  CL_OK The Log Record is recorded successfully. But this does not\n  mean that the record has been persisted in the Log File.\n\n  \\retval  CL_ERR_INVALID_HANDLE The passed Log Stream handle is not valid.\n  Either it is not received through a previous invocation to clLogStreamOpen()\n  or it has already been closed through an invocation to clLogStreamClose().\n\n  \\retval  CL_ERR_TIMEOUT An implementation defined timeout occurred before the call\n  could complete.\n\n  \\retval  CL_ERR_TRY_AGAIN The service could not be provided at this time.\n  The process may try later.\n\n  \\retval  CL_ERR_NO_MEMORY Either the Log Service library or some other module of\n  Log Service is out of memory. Thus service can not be provided at this time. This\n  may be a transient problem.\n\n  \\retval  CL_ERR_NO_RESOURCE Either the Log Service library or some other module\n  of Log Service is out of resources (other than memory). Thus, service can not be\n  provided at this time. This may be a transient problem.\n\n  \\retval  CL_LOG_ERR_FILE_FULL Log Stream identified by \\e hStream was created with\n  fileFullAction attribute set to CL_LOG_FILE_FULL_ACTION_HALT and the Log File\n  has become full. Thus no more Log Records can be logged into this stream. The\n  Stream must be closed.\n\n  \\par Description:\n     This function puts a Log Record in the Log Stream identified by hStream.\n  An invocation to this function is non-blocking. When this function returns,\n  it is guaranteed that the record has been recorded into Log Stream, but the\n  record might not be persisted in the Log File. Timing of persistence of this\n  Log Record in the Log File depends on the flushFreq and flushInterval\n  attributes of the Log Stream.\n  \\par\n      This function accepts variable number of arguments. Actual number of\n  arguments and their types depend on msgId parameter. If the value of msgId is\n  CL_LOG_MSGID_BUFFER, then two more arguments are expected which are length of\n  buffer and pointer to the buffer. If the value of msgId is CL_LOG_MSGID_PRINTF_FMT,\n  then next argument is treated as a C printf style format string and rest of the\n  arguments are interpreted as per the format string.\n  For all other values, the variable number of arguments are treated as\n  a set of 3-tuples. They should be 3*n+1, where n is the number of parameters\n  to be logged along with the msgId. For each such parameter, a tag identifying\n  the type of the parameter, a length denoting number of bytes in the parameter\n  and a pointer to the parameter are passed. The last argument must be a\n  special tag CL_LOG_TAG_TERMINATE. Values of msgId and tags, other than\n  defined by Log Service are not interpreted and the data is just copied into\n  the Log Record. It is the responsibility of Log Consumer to get the semantic\n  meaning of these and interpret the Log Record properly.\n  \\par\n     Certain other information like Log Timestamp and Component Id are also\n  recorded in the Log Record by the Log Service. Log Timestamp is the wall\n  clock time at the time of invocation to this function on the host where the\n  Logger is running. Component Id is the unique identifier identifying this\n  instance of the application. This is issued by Component Manager and remains\n  unchanged across process restart or cluster restart.The Log Record is written\n  in the Log Stream in an atomic fashion. Thus,concurrent recording by multiple\n  threads of the same process or multiple processes in the cluster is properly\n  handled.None of the buffers passed to this function are freed by this function.\n  It is the responsibility of the Logger to free those buffers. Thus, pointers to\n  stack variables can also be passed as pointers to this function without any\n  adverse side-effect.\n\n  \\par Library File:\n  ClLogClient\n\n  \\sa clLogStreamOpen(), clLogStreamClose()\n"]
    pub fn clLogWriteAsync(
        hStream: ClLogStreamHandleT,
        severity: ClLogSeverityT,
        serviceId: ClUint16T,
        msgId: ClUint16T,
        ...
    ) -> ClRcT;
}
extern "C" {
    pub fn clLogWriteAsyncWithHeader(
        hStream: ClLogStreamHandleT,
        severity: ClLogSeverityT,
        serviceId: ClUint16T,
        msgId: ClUint16T,
        ...
    ) -> ClRcT;
}
extern "C" {
    pub fn clLogWriteAsyncWithContextHeader(
        hStream: ClLogStreamHandleT,
        severity: ClLogSeverityT,
        pArea: *const ClCharT,
        pContext: *const ClCharT,
        serviceId: ClUint16T,
        msgId: ClUint16T,
        ...
    ) -> ClRcT;
}
extern "C" {
    #[doc = "  \\brief Changes the filter settings of a Log Stream.\n\n  \\par Header File:\n  clLogApi.h, clLogErrors.h\n\n  \\param hStream (in) Handle obtained by the previous invocation\n  clLogStreamOpen(). This handle identifies the Log Stream whose filter\n  setting have to be changed.\n\n  \\param logFilterFlags (in) This parameter identifies the way in which\n  filter parameter should be used. This filter can overwrite any previous\n  filter set or it can be used to modify a previous filter. To clear a\n  previous filter, this field should be set to CL_LOG_FILTER_ASSIGN and all\n  other fields should be set to zero.\n\n  \\param filter (in) Filter settings to be applied.\n\n  \\retval  CL_OK Changes in the filter settings have been done successfully.\n\n  \\retval  CL_ERR_INVALID_HANDLE The passed Log Stream handle is not valid.\n  Either it is not received through a previous invocation to clLogStreamOpen()\n  or it has already been closed through an invocation to clLogStreamClose().\n\n  \\retval  CL_ERR_TIMEOUT An implementation defined timeout occurred before the call\n  could complete.\n\n  \\retval  CL_ERR_TRY_AGAIN The service could not be provided at this time.\n  The process may try later.\n\n  \\retval  CL_ERR_NO_MEMORY Either the Log Service library or some other module of\n  Log Service is out of memory. Thus service can not be provided at this time. This\n  may be a transient problem.\n\n  \\retval  CL_ERR_NO_RESOURCE Either the Log Service library or some other module\n  of Log Service is out of resources (other than memory). Thus, service can not be\n  provided at this time. This may be a transient problem.\n\n  \\par Description:\n  This function sets the filter on the stream identified by \\e hStream. This\n  filter can be used to overwrite or clear or modify a previously set filter.\n  The logFilterFlags parameter is used to identify the correct operation. The\n  logSeverityFilter field of filter parameter is used to set filter setting\n  based on severity of the Log Record. All Log Records with severity bits set\n  in the filter maintained by Log Service on a per Log Stream basis enter the\n  Log Stream. Similarly, pLogMsgIdSet and pLogCompIdSet is used to specify\n  filter based on message ID and component ID respectively. Here the msgId and\n  the compId to be masked, that is, not allowed to enter the Log Stream should\n  be specified.To clear a previously set filter, all the fields of filter should\n  be set to zero and logFilterFlags should be set to CL_LOG_FILTER_ASSIGN.\n\n  \\par Library File:\n  ClLogClient\n\n  \\sa clLogStreamOpen(), clLogWriteAsync(), clLogStreamClose()\n"]
    pub fn clLogFilterSet(
        hStream: ClLogStreamHandleT,
        filterFlags: ClLogFilterFlagsT,
        filter: ClLogFilterT,
    ) -> ClRcT;
}
extern "C" {
    #[doc = "  \\brief Registers the calling process as handler for the specified stream.\n\n  \\par Header File:\n  clLogApi.h\n\n  \\param hLog (in) Handle obtained by the previous invocation\n  clLogInitialize(). This handle identifies the association between the\n  calling process and the Log service.\n\n  \\param streamName (in) Name of the stream for which this process wants\n  to become a handler.\n\n  \\param streamScope (in) Scope of the stream identified by streamName.\n\n  \\param nodeName (in) Name of the node where the Log Stream exists.\n  This is valid only if streamScope is set to CL_LOG_SCOPE_LOCAL.\n  If streamScope is set to CL_LOG_SCOPE_GLOBAL, this parameter is ignored.\n\n  \\param handlerFlags (in) It is the bitwise ORed value of flags defined in\n  ::ClLogStreamHandlerFlagsT. \\c CL_LOG_HANDLER_WILL_ACK must be specified,\n  if the handler wants to explicitly acknowledge the receipt of Log Records.\n  Typicaly, Log File Handler, which is part of Log Service, uses this flag.\n  Other handlers must pass zero as a value of this parameter.\n\n  \\param phStream (out) Pointer to memory area where the handle to the Log\n  Stream is returned. This handle must be used for further operations on\n  this stream.\n\n  \\retval  CL_OK The process has been registered as a handler for the\n  stream successfully.\n\n  \\retval  CL_ERR_INVALID_HANDLE The passed handle \\c hLog is either not obtained\n  through clLogInitialize() or this handle association has been already closed\n  by another invocation clLogFinalize().\n\n  \\retval  CL_ERR_TIMEOUT An implementation defined timeout occurred before the call\n  could complete.\n\n  \\retval  CL_ERR_TRY_AGAIN The service could not be provided at this time.\n  The process may try later.\n\n  \\retval  CL_ERR_NO_MEMORY Either the Log Service library or some other module of\n  Log Service is out of memory. Thus service can not be provided at this time. This\n  may be a transient problem.\n\n  \\retval  CL_ERR_NO_RESOURCE Either the Log Service library or some other module\n  of Log Service is out of resources (other than memory). Thus, service can not be\n  provided at this time. This may be a transient problem.\n\n  \\par Description:\n  This function registers interest of the calling process in handling the Log\n  Stream. Once the interest has been registered, the calling process will start\n  getting clLogRecordDeliverCallback as specified during the invocation to\n  clLogInitialize(). Memory for \\e phStream is allocated and freed by the calling\n  process.In case, this function is called multiple times on the same stream with\n  the same Log Service handle hLog, every time a new Log Stream handle \\e hStream\n  will be issued. During the delivery of Log Records, the callback will be called\n  once per such handle issued.\n\n  \\par Library File:\n  ClLogClient\n\n  \\sa clLogInitialize(),clLogHandlerDeregister()\n"]
    pub fn clLogHandlerRegister(
        hLog: ClLogHandleT,
        streamName: ClNameT,
        streamScope: ClLogStreamScopeT,
        nodeName: ClNameT,
        handlerFlags: ClLogStreamHandlerFlagsT,
        phStream: *mut ClLogHandleT,
    ) -> ClRcT;
}
extern "C" {
    #[doc = "  \\brief Deregisters the calling process as handler for the specified\n   stream.\n\n  \\par Header File:\n  clLogApi.h\n\n  \\param hStream (in) Handle obtained through a previous invocation to\n  clLogHandlerRegister(). This handle identifies the registration of handler\n  for a stream which is being deregistered.\n\n  \\retval  CL_OK The handle has been deregistered successfully.\n\n  \\retval  CL_ERR_INVALID_HANDLE The passed Log Stream handle is not valid.\n  Either it is not received through a previous invocation to clLogHandlerRegister()\n  or it has already been deregistered through an invocation to clLogHandlerDeregister()\n  or hLog supplied to clLogHandlerRegister() during registration of the handler has\n  been finalized.\n\n  \\retval  CL_ERR_TIMEOUT An implementation defined timeout occurred before the call\n  could complete.\n\n  \\retval  CL_ERR_TRY_AGAIN The service could not be provided at this time.\n  The process may try later.\n\n  \\retval  CL_ERR_NO_MEMORY Either the Log Service library or some other module of\n  Log Service is out of memory. Thus service can not be provided at this time. This\n  may be a transient problem.\n\n  \\retval  CL_ERR_NO_RESOURCE Either the Log Service library or some other module\n  of Log Service is out of resources (other than memory). Thus, service can not be\n  provided at this time. This may be a transient problem.\n\n  \\par Description:\n  This function deregisters interest of the calling process in handling the\n  Log Stream. Once the interest has been deregistered, the calling process will\n  stop getting clLogRecordDeliverCallback. This call cancels all the pending\n  clLogRecordDeliverCallback callbacks. Since callback invocation is\n  asynchronous, the process may still get some pending callbacks. After this\n  invocation, hStream is no longer valid. If the handler process terminates\n  without deregistering its interest, Log Service will implicitly deregisters\n  the process. If the Log Service handle \\e hLog used during clLogHandlerRegister\n  invocation is finalized without explicitly deregistering the interest in\n  handling the stream, Log Service will implicitly deregisters the process.\n\n  \\par Library File:\n  ClLogClient\n\n  \\sa clLogHandlerRegister()\n"]
    pub fn clLogHandlerDeregister(hStream: ClLogStreamHandleT) -> ClRcT;
}
extern "C" {
    #[doc = "  \\brief Function to acknowledge, receipt of Log Records, to the sender\n  of the Log Records.\n\n  \\par Header File:\n  clLogApi.h\n\n  \\param hStream (in) Handle obtained through a previous invocation to\n  clLogHandlerRegister(). This handle identifies the registration of handler\n  for a stream which is records are being acknowledged\n\n  \\param sequenceNumber (in) Number identifying the set of Log Records\n  received.This number is obtained from ClLogRecordDeliverCallbackT.\n\n  \\param numRecords (in) Number of records received successfully by\n  the handler\n\n  \\retval  CL_OK The api has successfully sent the acknowledgement.\n\n  \\retval  CL_ERR_INVALID_HANDLE The passed Log Stream handle is not valid.\n  Either it is not received through a previous invocation to\n  clLogHandlerRegister() or it has already been closed through an invocation\n  to clLogHandlerDeregister().\n\n  \\retval  CL_ERR_TIMEOUT An implementation defined timeout occurred before the call\n  could complete.\n\n  \\retval  CL_ERR_TRY_AGAIN The service could not be provided at this time.\n  The process may try later.\n\n  \\retval  CL_ERR_NO_MEMORY Either the Log Service library or some other module of\n  Log Service is out of memory. Thus service can not be provided at this time. This\n  may be a transient problem.\n\n  \\retval  CL_ERR_NO_RESOURCE Either the Log Service library or some other module\n  of Log Service is out of resources (other than memory). Thus, service can not be\n  provided at this time. This may be a transient problem.\n\n  \\retval CL_ERR_BAD_FLAG \\c CL_LOG_HANDLER_WILL_ACK flag was not set while registering\n  the handler.\n\n  \\par Description:\n  This function acknowledges the receipt of Log Records for the Log Stream that\n  this handler is interested in. Handler should acknowledge only if it\n  registered with the flag \\c CL_LOG_HANDLER_WILL_ACK in the previous invocation\n  of function, clLogHandlerRegister. The sender of the Log Records treat the\n  records as lost if the acknowledgement is not received in specified time\n  limit.\n\n  \\par Library File:\n  ClLogClient\n\n  \\sa clLogHandlerRegister()\n"]
    pub fn clLogHandlerRecordAck(
        hStream: ClLogStreamHandleT,
        sequenceNumber: ClUint64T,
        numRecords: ClUint32T,
    ) -> ClRcT;
}
extern "C" {
    #[doc = "  \\brief Opens the current logical log file for reading the log records.\n\n  \\par Header File:\n  clLogApi.h\n\n  \\param hLog (in) Handle obtained by the previous invocation\n  clLogInitialize(). This handle identifies the association between the\n  calling process and the Log service.\n\n  \\param fileName (in) Name of the file that the process wants to open for\n  reading the records.\n\n  \\param fileLocation (in) Location where the file exists.\n   refer ::ClLogStreamAttributesT.\n\n  \\param isDelete (in) Parmeter that tell the log service to delete the records\n  read by this file handler from the file for new records.\n\n  \\param phFile (out) Pointer to memory area where the handle to the Log File\n  is returned. This handle must be used for further operations on this Log File.\n\n  \\retval  CL_OK The api has successfully opened file for reading.\n\n  \\retval  CL_ERR_INVALID_HANDLE The passed Log handle is not valid.\n  Either it is not received through a previous invocation to\n  clLogInitialize() or it has already been closed through an invocation\n  to clLogFinalize().\n\n  \\retval CL_ERR_NULL_POINTER \\e phFile parameter is passed as NULL.\n\n  \\retval CL_ERR_NOT_EXITS The Log File identified by filename and fileLocation\n  does not exist.\n\n  \\retval  CL_ERR_TIMEOUT An implementation defined timeout occurred before the call\n  could complete.\n\n  \\retval  CL_ERR_TRY_AGAIN The service could not be provided at this time.\n  The process may try later.\n\n  \\retval  CL_ERR_NO_MEMORY Either the Log Service library or some other module of\n  Log Service is out of memory. Thus service can not be provided at this time. This\n  may be a transient problem.\n\n  \\retval  CL_ERR_NO_RESOURCE Either the Log Service library or some other module\n  of Log Service is out of resources (other than memory). Thus, service can not be\n  provided at this time. This may be a transient problem.\n\n  \\par Description:\n  This function opens a logical log file for the process to get records and\n  metadata. Once the file is opened the metadata can be obtained by invoking\n  clLogFileMetadataGet() and records can be obtained by invocation of\n  clLogFileRecordsGet() Memory for phFIle is allocated and freed by the\n  calling process. Each invocation of this call returns a new handle and will\n  start reading the records from the oldest record available.\n\n  \\par Library File:\n  ClLogClient\n\n  \\sa clLogInitialize\n"]
    pub fn clLogFileOpen(
        hLog: ClLogHandleT,
        fileName: *mut ClCharT,
        fileLocation: *mut ClCharT,
        isDelete: ClBoolT,
        phFile: *mut ClLogFileHandleT,
    ) -> ClRcT;
}
extern "C" {
    #[doc = "  \\brief Close the file which was opened for reading.\n\n  \\par Header File:\n  clLogApi.h\n\n  \\param hFile (in) Handle obtained through a previous invocation to\n  clLogFileOpen(). This handle identifies the Log File opened.\n\n  \\retval  CL_OK The api has successfully opened file for reading.\n\n  \\retval  CL_ERR_INVALID_HANDLE The passed file handle is not valid.\n  Either it is not received through a previous invocation to\n  clLogFileOpen() or it has already been closed through an invocation\n  to clLogFileClose().\n\n  \\retval  CL_ERR_TIMEOUT An implementation defined timeout occurred before\n  the call could complete.\n\n  \\retval  CL_ERR_TRY_AGAIN The service could not be provided at this time.\n  The process may try later.\n\n  \\retval  CL_ERR_NO_MEMORY Either the Log Service library or some other module of\n  Log Service is out of memory. Thus service can not be provided at this time. This\n  may be a transient problem.\n\n  \\retval  CL_ERR_NO_RESOURCE Either the Log Service library or some other module\n  of Log Service is out of resources (other than memory). Thus, service can\n  not be provided at this time. This may be a transient problem.\n\n  \\par Description:\n  This function closes the Log File opened by the process for reading the log\n  records, once the file is closed no more records can be read from it.\n  Metadata of the file cannot be read after that.\n\n  \\par Library File:\n  ClLogClient\n\n  \\sa clLogFileOpen\n"]
    pub fn clLogFileClose(hFileHdlr: ClLogFileHandleT) -> ClRcT;
}
extern "C" {
    #[doc = "  \\brief Gets the metadata of the file.\n\n  \\par Header File:\n  clLogApi.h\n\n  \\param hFile (in) Handle obtained through a previous invocation to\n  clLogFileOpen().This handle identifies the Log File whose meta data\n  is to be obtained.\n\n  \\param streamAttr (out) Attributes of all the stream that are being\n  persisted into the file identified by hFile\n\n  \\param pNumStreams (out) Number of streams whose records are currently\n  being persisted into the Log File identified by hFile. This indicates\n  the number of entries in ppLogStreams. Memory for pNumStreams is allocated\n  and freed by the calling process.\n\n  \\param ppLogStreams (out) Pointer to a memory area where pointer to array\n  of Log Stream information will be stored. Each entry in this array\n  corresponds to one Log Stream in the File. Memory for ppLogStreams is\n  allocated and freed by the calling process, whereas, memory for\n  \\e *ppLogStreams is allocated by the Log Service and freed by the calling\n  process.\n\n  \\retval  CL_OK The api has been successfully executed.\n\n  \\retval  CL_ERR_INVALID_HANDLE The passed file handle is not valid.\n  Either it is not received through a previous invocation to\n  clLogFileOpen() or it has already been closed through an invocation\n  to clLogFileClose().\n\n  \\retval CL_ERR_TIMEOUT An implementation defined timeout occurred before\n  the call could complete.\n\n  \\retval CL_ERR_NULL_POINTER Either pNumRecords or pLogRecords are passed\n  as NULL.\n\n  \\retval  CL_ERR_TRY_AGAIN The service could not be provided at this time.\n  The process may try later.\n\n  \\retval  CL_ERR_NO_MEMORY Either the Log Service library or some other module of\n  Log Service is out of memory. Thus service can not be provided at this time. This\n  may be a transient problem.\n\n  \\retval  CL_ERR_NO_RESOURCE Either the Log Service library or some other module\n  of Log Service is out of resources (other than memory). Thus, service can\n  not be provided at this time. This may be a transient problem.\n\n  \\par Description:\n  The function returns the Log Records from the file identified by hFile.\n  Function returns the set of record starting from the oldest record written in\n  the Log File. After sending the set, the records are cleaned up from the\n  file, that is, these records are no longer available, thus creating space for\n  new records\n\n  \\par Library File:\n  ClLogClient\n\n  \\sa clLogFileOpen\n"]
    pub fn clLogFileMetaDataGet(
        hFileHdlr: ClLogFileHandleT,
        pStreamAttr: *mut ClLogStreamAttributesT,
        pNumStreams: *mut ClUint32T,
        ppLogStreams: *mut *mut ClLogStreamMapT,
    ) -> ClRcT;
}
extern "C" {
    #[doc = "  \\brief Gets the records from the file.\n\n  \\par Header File:\n  clLogApi.h\n\n  \\param hFile (in) Handle obtained through a previous invocation to\n  clLogFileOpen().This handle identifies the Log File whose records are\n  to be read.\n\n  \\param pStartTime (out) Its the lowest timestamp in the set of\n  records being returned in this call in pLogRecords. It identifies the\n  oldest record in the current set. Memory for pStartTime is allocated\n  and freed by the calling process.\n\n  \\param pEndTime (out) Its the highest timestamp in the set of records\n  being returned in this call in pLogRecords. It identifies the freshest\n  record in the current set. Memory for pEndTime is allocated and freed\n  by the calling process.\n\n  \\param pNumRecords (in-out) Caller specifies the number of records it\n  wants.Function returns the actual number of records that are read.\n  Function always read from the oldest record written into the file, which\n  is not read till now. It reads till the number of records requested or\n  number of records available, whichever is smaller. Memory for \\e pNumStreams\n  is allocated and freed by the calling process.\n\n  \\param pLogRecords (out) Pointer to a memory area where the Log Records\n  read will be stored. Total number of Log Records stored will be specified\n  by the value of \\e pNumRecords. Memory for pLogRecords is allocated and freed\n  by the calling process.\n\n  \\retval  CL_OK The api has been successfully executed.\n\n  \\retval  CL_ERR_INVALID_HANDLE The passed file handle is not valid.\n  Either it is not received through a previous invocation to\n  clLogFileOpen() or it has already been closed through an invocation\n  to clLogFileClose().\n\n  \\retval CL_ERR_TIMEOUT An implementation defined timeout occurred before\n  the call could complete.\n\n  \\retval CL_ERR_NULL_POINTER Either pNumRecords or pLogRecords are passed\n  as NULL.\n\n  \\retval  CL_ERR_TRY_AGAIN The service could not be provided at this time.\n  The process may try later.\n\n  \\retval  CL_ERR_NO_MEMORY Either the Log Service library or some other module of\n  Log Service is out of memory. Thus service can not be provided at this time. This\n  may be a transient problem.\n\n  \\retval  CL_ERR_NO_RESOURCE Either the Log Service library or some other module\n  of Log Service is out of resources (other than memory). Thus, service can\n  not be provided at this time. This may be a transient problem.\n\n  \\par Description:\n  The function returns the Log Records from the file identified by hFile.\n  Function returns the set of record starting from the oldest record written in\n  the Log File. After sending the set, the records are cleaned up from the\n  file, that is, these records are no longer available, thus creating space for\n  new records\n\n  \\par Library File:\n  ClLogClient\n\n  \\sa clLogFileOpen\n"]
    pub fn clLogFileRecordsGet(
        hFileHdlr: ClLogFileHandleT,
        pStarTime: *mut ClTimeT,
        pEndTime: *mut ClTimeT,
        pNumRecords: *mut ClUint32T,
        pLogRecords: *mut ClPtrT,
    ) -> ClRcT;
}
extern "C" {
    #[doc = "  \\brief Gets the list of active streams available in the cluster.\n\n  \\par Header File:\n  clLogApi.h, clLogErrors.h\n\n  \\param hLog (in) Handle obtained by the previous invocation\n  clLogInitialize(). This handle identifies the association between the\n  calling process and log service.\n\n  \\param pNumStreams (out) Number of streams that are currently open in the\n  cluster. This indicates the number of entries in \\e ppLogStreams. Memory for\n  \\e pNumStreams is allocated and freed by the calling process.\n\n  \\param ppLogStreams (out) Pointer to a memory area where pointer to array\n  of Log Stream information will be stored. Each entry in this array corresponds\n  to one Log Stream in the cluster. Memory for \\e ppLogStreams is allocated and\n  freed by the calling process, whereas, memory for \\e *ppLogStreams is allocated\n  by the Log Service and freed by the calling process.\n\n  \\retval  CL_OK The API has been successfully executed.\n\n  \\retval  CL_ERR_INVALID_HANDLE The passed handle(hLog) is either not obtained\n  through clLogInitialize() or this handle association has been already closed\n  by another invocation clLogFinalize().\n\n  \\retval  CL_ERR_TIMEOUT An implementation defined timeout occurred before the call\n  could complete.\n\n  \\retval  CL_ERR_TRY_AGAIN The service could not be provided at this time.\n  The process may try later.\n\n  \\retval  CL_ERR_NULL_POINTER Either pNumStreams or ppLogStreams are passed\n  as NULL.\n\n  \\retval  CL_ERR_NO_MEMORY Either the Log Service library or some other module of\n  Log Service is out of memory. Thus service can not be provided at this time. This\n  may be a transient problem.\n\n  \\retval  CL_ERR_NO_RESOURCE Either the Log Service library or some other module\n  of Log Service is out of resources (other than memory). Thus, service can not be\n  provided at this time. This may be a transient problem.\n\n  \\par Description:\n  The function returns information about all the Log Streams in the cluster.\n  It is used by Log Handlers to find out Log Streams in which they may be\n  interested in.\n\n  \\par Library File:\n  ClLogClient\n\n  \\sa clLogStreamOpen(), clLogStreamClose()\n"]
    pub fn clLogStreamListGet(
        hLog: ClLogHandleT,
        pNumStreams: *mut ClUint32T,
        ppLogStreams: *mut *mut ClLogStreamInfoT,
    ) -> ClRcT;
}
extern "C" {
    pub fn clLogWriteDeferred(
        handle: ClHandleT,
        severity: ClLogSeverityT,
        servicId: ClUint16T,
        msgId: ClUint16T,
        pFmtStr: *mut ClCharT,
        ...
    ) -> ClRcT;
}
extern "C" {
    pub fn clLogWriteDeferredForce(
        handle: ClHandleT,
        severity: ClLogSeverityT,
        servicId: ClUint16T,
        msgId: ClUint16T,
        pFmtStr: *mut ClCharT,
        ...
    ) -> ClRcT;
}
extern "C" {
    pub fn clLogMsgWrite(
        streamHdl: ClHandleT,
        severity: ClLogSeverityT,
        serviceId: ClUint16T,
        pArea: *const ClCharT,
        pContext: *const ClCharT,
        pFileName: *const ClCharT,
        lineNum: ClUint32T,
        pFmtStr: *const ClCharT,
        ...
    ) -> ClRcT;
}
extern "C" {
    pub fn clLogMsgWriteDeferred(
        streamHdl: ClHandleT,
        severity: ClLogSeverityT,
        serviceId: ClUint16T,
        pArea: *const ClCharT,
        pContext: *const ClCharT,
        pFileName: *const ClCharT,
        lineNum: ClUint32T,
        pFmtStr: *const ClCharT,
        ...
    ) -> ClRcT;
}
extern "C" {
    pub fn clLogMsgWriteConsole(
        streamHdl: ClHandleT,
        severity: ClLogSeverityT,
        serviceId: ClUint16T,
        pArea: *const ClCharT,
        pContext: *const ClCharT,
        pFileName: *const ClCharT,
        lineNum: ClUint32T,
        pFmtStr: *const ClCharT,
        ...
    ) -> ClRcT;
}
extern "C" {
    pub fn clLogFormatRecordHeader(
        msgHeader: *mut ClCharT,
        maxHeaderLen: ClUint32T,
        msg: *mut ClCharT,
        consoleFlag: ClBoolT,
        msgIdCnt: ClUint32T,
        severity: ClLogSeverityT,
        pFileName: *const ClCharT,
        lineNum: ClUint32T,
        pArea: *const ClCharT,
        pContext: *const ClCharT,
    ) -> ClUint32T;
}
extern "C" {
    pub fn clLogFormatRecord(
        msgHeader: *mut ClCharT,
        maxHeaderLen: ClUint32T,
        msg: *mut ClCharT,
        maxMsgLen: ClUint32T,
        consoleFlag: ClBoolT,
        msgIdCnt: ClUint32T,
        severity: ClLogSeverityT,
        pFileName: *const ClCharT,
        lineNum: ClUint32T,
        pArea: *const ClCharT,
        pContext: *const ClCharT,
        pFmtStr: *const ClCharT,
        ...
    ) -> ClUint32T;
}
extern "C" {
    pub fn clLogSeverityFilterToValueGet(
        filter: ClLogSeverityFilterT,
        pSeverity: *mut ClLogSeverityT,
    ) -> ClRcT;
}
extern "C" {
    pub fn clLogSeverityValueToFilterGet(
        severity: ClLogSeverityT,
        pFilter: *mut ClLogSeverityFilterT,
    ) -> ClRcT;
}
extern "C" {
    pub fn clLogStreamFilterSet(
        pStreamName: *mut ClNameT,
        streamScope: ClLogStreamScopeT,
        pStreamScopeNode: *mut ClNameT,
        filterFlags: ClLogFilterFlagsT,
        filter: ClLogFilterT,
    ) -> ClRcT;
}
extern "C" {
    pub fn clLogStreamFilterGet(
        pStreamName: *mut ClNameT,
        streamScope: ClLogStreamScopeT,
        pStreamScopeNode: *mut ClNameT,
        pFilter: *mut ClLogFilterT,
    ) -> ClRcT;
}
extern "C" {
    pub fn clLogSeverityGet(pSevName: *const ClCharT) -> ClLogSeverityT;
}
extern "C" {
    pub fn clLogTimeGet(pStrTime: *mut ClCharT, maxBytes: ClUint32T) -> ClRcT;
}
extern "C" {
    pub static mut gClLogCodeLocationEnable: ClBoolT;
}
